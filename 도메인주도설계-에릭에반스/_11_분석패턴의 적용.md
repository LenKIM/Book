>  분석 패턴은 업무 모델링 과정에서 발견되는 공통적인 구조를 표현하는 개념의 집합이다. 분석 패턴은 단 하나의 도메인에 대해서만 적절할 수도 있고 여러 도메인에 걸쳐 적용이 가능할 수도 있다.



- 실무에서 쌓은 경험을 바탕으로 도출된 것 > 분석 패턴
- 분석 패턴이라는 이름은 분석 패턴이 지닌 개념적인 본질을 강조한다. 분석 패턴은 기술적인 해법이 아니다. **특정 도메인의 모델을 작성할 때 따를 수 있는 유용한 지침서에 해당한다.**
-  최상의 분석 패턴은 과거의 프로젝트에서 유용한 경험을 전달하고 모델에 대한 통찰력을 광범위한 설계 방침과 구현 결과에 결합시킨다. 문맥을 고려하지 않고 모델과 관련된 아이디어를 적용하기가 어려워지고 MODEL-DRIVE DESIGN의 개념에 상반되는 분석과 설계의 치명적인 분할이 발생할 위험을 무릅써야 한다.

- 마틴 파울러의 분석패턴?

### 예제

계좌의 이자 수익

![image-20230312102308218](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-12/image-20230312102308218.png)

6장 '재고와 회계' - 회계 모델

현재 저장된 총액에 이르기까지의 개별적인 변화를 통제하고 변화의 원인을 설명할 수 있어야 한다. 이것이 바로 회계 모델이 나오게 된 가장 기본적인 동기다.

![image-20230312102907229](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-12/image-20230312102907229.png)

회계의 기본 원리는 **보존(convervation)**. 

"모든 대변(credit)에는 대응하는 차변(debt)이 존재한다" - 복식부기의 기본 개념

![image-20230312103059644](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-12/image-20230312103059644.png)

개1: 새로운 모델에서는 이자에 대한 interestDueAmount를 조정하는 대신 이자 Entry를 Interest Account(이자 계정)에 기입할 생각입니다. 그러면 상황 Entry가 기입될 때 대차 잔액이 맞춰지는 거죠.

전: 그럼 이제 상환 이력뿐 아니라 모든 이자 발생 이력도 확인 할 수 있겠군요? 바로 저희가 원했던 기능입니다.

개2: 여기서 "Transaction(거래)"을 올바른 방식으로 사용하고 있는지 확신이 잘 안서네요. 정의에 따르면 Transaction은 하나의 Account에서 다른 Account로 금액을 옮기는 것이지 동일한 Account안에서 Entry의 대차 잔액을 맞추는 용도로 사용하는 것은 아니라서요.

전: 꼭 늦게 상환되는 것은 아닙니다. 상환 시기는 꽤나 유동적으로 조정이 가능해요.

개1: 그렇다면, 현재 방식으로 해결할 수 없겠네요. 암시적인 개념을 식별했다고 생각했는데 방향을 잘못 잡은 것 같습니다. 제가 보기에는 Interest Calculator가 Entry 객체를 생성하게 하는 편이 더 명확하게 의미를 전달하는 것 같아요. 그리고 Transaction은 계산된 이자와 이자상환은 깔끔하게 하나로 묶는 것으로 보이는 군요.

전: 왜 이자 발생을 상환과 묶어야 하죠? 이자 발생과 상환은 회계 시스템에서 별도의 기입항목 > 중요한 것은 Account의 잔액이죠. 이자와 상환을 개별적인 Entry로 구성하는 것만으로도 충분합니다.

개2: 그럼 이자 상환 여부를 추적할 필요가 없다는 말씀이세요?

전: 물론 추적을 해야지만, 말씀하신 것처럼 "한 번의 이자 발생에 대해 오직 한 번의 상환(one-accrual/one-payment)"이 이뤄지는 단순한 구조가 아닙니다.

개2: 그렇다면 이자 발생과 상환 간의 관게를 무시하는 편이 더 낫겠군요.

개1: 그럼 발생(accrual)이라는 단어를 무슨 뜻인지 명확하게 설명해줄수 있나요?

전: 발생이라는 것은 지출이나 수입이 발생한 시점을 의미할 뿐, 실제로 돈이 오갔는지 여부와는 무관합니다. 예를 들어 월 단위로 이자를 상환하기로 돼 있다면 이자는 매일 발생하지만 매달 말이 되어서야 이자에 대한 상환액을 받게 되는 식이죠

개1: 저희에게 정말로 필요했던 용어를 알게 된 것 같아요. 



![image-20230312103845694](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-12/image-20230312103845694.png)

개1: 발생(accrual)이라는 용어를 사용해서 의도를 더 명확하게 드러나도록 수정했습니다.

![image-20230312103952052](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-12/image-20230312103952052.png)



회의를 마친 후 새로운 모델을 토대로 리팩터링을 시작했다.

 애플리케이션 내에서 Payment와 Accrual이 미묘하게 다른 책임을 나타낸다는 사실을 알게 됐고 두 가지 모두 도메인의 중요한 개념을 표현하고 있기에 Entry를 상속하는 하위 클래스 Payment와 Accrual을 추가했다.

![image-20230312104157961](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-12/image-20230312104157961.png)

--

**야간 배치 프로그램에 대한 통찰력**

 몇 주가 지난 뒤 개선된 Account 기반 모델이 자리를 잡아가기 시작했다. 

![image-20230312104807846](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-12/image-20230312104807846.png)

**기입 규칙 실행**

Posting Rule을 사용해서 Account 간에 개념적 의존성을 설정했지만 ,만약 패턴에 대한 설명이 여기까지밖에 없었다면 패턴을 적용하기가 아려웠을 것. 의존성을 설계할 때 까다로운 부분 중 하나는 갱신의 시기와 제어 방식이다. 마틴 파울러는 3가지 선택안을 논한다.

1. "적극적인 실행"방식은 가장 명확하지만 동시에 가장 비효율적인 방법. Account에 Entry가 삽입될 때마다 곧바로 Posting Rule을 실행하기 때문에 모든 갱신 작업이 즉시 이뤄진다.
2. "Account 기반 실행"방식은 처리 시기를 연기할 수 있다. 특정 시점에 Account로 메시지가 전달되고, Posting Rule이 실행되어 마지막으로 실행된 후에 삽입된 모든 Entry를 처리한다.
3. 마지막으로 "Posting-Rule 기반 실행"방식은 Posting Rule을 실행하는 외부 에이전트에 의해 시작된다. Posting Rule은 최종 실행 시점 이후로 입력 계정에 추가된 모든 Entry를 찾아야 하는 책임이 있다.

시스템 내에서 세 가지 실행 방식을 혼용해서 사용할 수도 있지만 각 실행 방식과 연관된 규칙에는 실행을 시작하고 입력 Account Entry를 식별할 책임을 지닌 하나의 명확한 지점이 있어야 한다. 세 가지 실행 모드를 유비쿼터스언어에 추가하는 것은 모델 내에 객체를 정의하는 것만큼이나 패턴을 성공적으로 적용하는 데 중요하다. 이렇게 해서 모호함을 제거하고 분명하게 정의된 선택사항을 기반으로 의사결정을 내릴 수 있다. 

![image-20230312105825892](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-12/image-20230312105825892.png)



## 분석 패턴은 참고할 수 있는 지식이다.

 운 좋게 적용가능한 분석패턴을 알고 있더라도 분석 패턴이 현재의 특정 요구사항에 딱 들어맞는 경우는 거의 없다. 분석 패턴은 도메인을 파악하는 과정에서 훌륭한 길잡이 역할을 하며 깔끔하게 추상화된 어휘집을 제공한다. 이뿐만 아니라 구현할 때 고려해야 할 영향력에 대한 지침을 제공함으로써 장차 겪게 될 고통을 덜어주기도 한다.



 이 모든 것이 지식 탐구와 심층적인 통찰력을 향한 리팩터링이라는 발전기의 연료가 되어 개발을 촉진한다. 그 결과로 작성된 모델은 분석 패턴에 적힌 형태와 유사하지만 완전히 동일하지는 않으며 각기 특수한 상황에 적합하도록 수정하고 개선된 것이다. 이따금 분석 패턴과의 눈에 띄는 관련성을 확인하기 어려운 경우도 있지만 이것은 패턴을 적용하면서 얻게 되는 통찰력의 결과다.



 한 가지 변경하지 말아야 할 것 > 널리 알려진 분석 패턴을 적용할 때는 패턴의 외견상의 형태는 변경해도 무방하지만 패턴이 의미하는 기본적인 개념만큼은 손대지 말아야 한다. 1. 패턴에는 문제의 발생을 미연에 방지할 수 있는 지식이 포함돼 있다. 2. 널리 이해되거나 적어도 잘 설명된 용어를 포함심으로써 유비쿼터스언어의 품질을 높일 수 있다.



분석 패턴은 가장 중요하고 어려운 결정 사항에 집중하고 어떤 것을 선택해야 하는지와 그 외의 대한으로는 어떤 것이 있는지 명확하게 제시한다. 또한 분석 패턴은 그것이 없다면 알아내는 데 큰 비용이 드는 하부 활동에 대한 영향력을 예측할 수 있게 만들어준다.