# 모델의 무결성 유지



Charge 가 이미 다른 곳에서 구현되있어서 그것을 재사용과정에서 실제로 동작되는 코드에서 문제가 발생했다.

문제는 두 팀에서 서로 다른 모델을 보유했지 그것을 알아차리지 못했으며, 이를 탐지하는 프로세스조차 마련돼 있지 않았다는 데 있다. 각 팀은 자신들만의 유효한 요금 속성을 대상으로 가정을 세웠던 것이다.

- 모델의 가장 근본적인 요구사항은 모델은 내적으로 일관성을 유지하고 모델의 용어는 언제나 의미가 동일하며, 모델에는 어떠한 모순되는 규칙도 없어야 한다는 것
- **내적일관성을 단일화(unification)**
- 대규모 시스템의 도메인 모델을 완전하게 단일화한다는 것은 타당하지 않거나 비용 대비 효과적이지 않을 것이다.



--

1. 한 번에 지나치게 많은 레거시를 교체하려 할지도 모른다.
2. 대규모 프로젝트에서는 능력에 비해 조율에 드는 비용이 너무 커서 난관에 처할지도 모른다.
3. 특화된 요구사항이 있는 애플리케이션에서는 요건을 완전하게 충족하지 못해 애플리케이션의 행위를 다른 곳에 둘 수 밖에 없는 모델을 사용해야될지 모른다.
4. 반대로 단일 모델로 모두를 만족시키려 해서 모델을 사용하기 어렵게 만드는 복잡한 대안으로 이어질지도 모른다.



CONTEXT MAP이 프로젝트의 컨테스트와 각 컨텍스트 간의 관계를 전체적인 개관을 제공해주는 반면 BOUNDED CONTEXT는 각 모델의 적용가능성의 범위를 정의한다. 이처럼 모호함이 줄어드는 것 자체가 프로젝트의 진행 방식을 바꾸겠지만 이것만으는 충분하지 않다. 일단 컨텍스트가 제한되면 CONTINUOUS INTEGRATION 프로세스를 토대로 모델의 단일화를 유지할 수 있다.



BOUNDING CONTEXT(제한하는 컨텍스트)와 SHARED KERNAL(공유커널)과 밀접하게 관련된 컨텍스트에서 SEPARATE WAYS(각자의 길)를 취하는 느슨하게 결합된 모델에 이르는) 각 BOUNDING CONTEXT를 연결하기 위한 더욱 효과적인 전략으로 이어갈 수 있다.

![image-20230319151223040](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-19/image-20230319151223040.png)



## BOUNDED CONTEXT(제한된 컨텍스트)

- 서로 다른 시스템에서 관리하는 데이터의 형식이 자신의 시스템과 다른 탓에 데이터 변환 작업이 필요하다는 사실은 단지 기계적인 차원의 문제이다. 근본적으로는 두 시스템 내에 존재하는 암시적인 모델 간의 차이다. 
- 모순을 조심해야 한다.
- 규모가 큰 프로젝트에서는 다수의 모델이 사용되기 마련이다. 그러나 개별적인 모델을 기반으로 작성된 코드가 한데 섞이면 많은 버그가 발생하고 신뢰성이 떨어지며 이해하기 힘든 소프트웨어가 만들어진다. 아울러 팀 구성원 간의 의사소통이 혼란스러워진다. 종종 어떤 컨테스트에서 어떤 모델을 사용해서는 안 되는지 불분명한 경우도 있다.
- 모델은 컨텍스트에 적용된다. **모델 컨텍스트란 모델에서 사용된 용어를 특정한 의미로 의사소통하기 위한 조건의 집합**
- 모델이 적용되는 컨텍스트를 명시적으로 정의하라. 컨텍스트의 경계를 팀 조직, 애플리케이션의 특정 부분에서의 사용법, 코드 기반이나 데이터베이스 스키마와 같은 물리적인 형태의 관점에서 명시적으로 설정하라. 이 경계 내에서는 모델을 엄격하게 일관된 상태로 유지하고 경계 바깥의 이슈 때문에 초점이 흐려지거나 혼란스러워져서는 안 된다.

- 스키마는 모델에 의해 주도되며, 따라서 구획 안에 존재한다.



**BOUNDED CONTEXT 를 정의해서 얻을 수 있는 것은 무엇일까?**

- CONTEXT 안에서 업무를 진행하는 팀에서 얻게 되는 것은 바로 **명확함** . 두 팀은 자신들이 하나의 모델과 일관성을 유지해야 한다는 점을 알고 있다.

CONTINUOUS INTEGRATION 프로세스가 BOUNDED CONTEXT안의 미묘하게 예상치 못한 행위의 신호를 알 수 있는데, 도움을 준다.



## CONTINUOUS INTEGRATION(지속적인 통합)

 BOUNDED CONTEXT를 정의했다면 이를 건전한 상태로 유지해야 한다.

- 다수의 사람이 동일한 CONTINUOUS INTEGRATION 내에서 작업할 경우 모델이 단편화될 가능성이 높다. 팀의 규모가 커지면 문제도 증폭되지만 서너 명정도에 달하는 소수의 인원으로 구성된 팀도 심각한 문제에 마주칠 수 있다. 그렇다고 시스템을 더 작은 CONTEXT로 분할한다면 결국 가치있는 수준의 통합과 응집성을 잃게 되는 결과를 초래한다.
- 이런 상황에서 익스트림 프로그래밍이 진가를 발휘한다. XP에서 제시하는 각종 실천상항의 목표는 결국 응집도 높은 설계를 유지하는 문제를 해결하는 데 있다.
- CONTINUOUS INTEGRATION 역시 **모델 개념의 통합**과 **구현 수준에서의 통합**이라는 두 가지 수준에서 작용한다.



**개념은 팀 구성원 간의 부단한 의사소통을 토대로 통합.** 팀은 끊임없이 변화하는 모델을 함께 이해하고 이를 발전시켜야 한다.통합을 위한 효과적인 프로세스는 다음과 같다.

- 단계적이고 재생 가능한 병합/빌드 기법
- 자동화된 테스트 스워트
- 수정사항이 통합되지 않은 상태로 존재할 수 있는 시간을 적당히 짧게 유지하는 규칙

단편화가 발생했다는 사실을 빠르게 알려줄 수 있는 자동화된 테스트와 함께 모든 코드와 그 밖의 구현 산출물을 빈번하게 병합하는 프로세스를 수립하라. 개념이 각자의 머릿속에서 발전해감에 따라 모델에 관한 시간의 차이를 해소하기 위해 끊임없이 유비쿼터스 언어를 사용하라.



## CONTEXT MAP(컨텍스트 맵)

![image-20230319153122955](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-19/image-20230319153122955.png)

 개별적인 BOUNDED CONTEXT로는 전체를 조망할 수 없다. 그래서 다른 모델의 컨텍스트는 여전히 모호하고 유동적이다.

- 다른 팀에 속한 사람들은 CONTEXT간의 경계를 인식하지 못할 것이며, 따라서 자신도 모르는 사이에 CONTEXT의 경계를 흐리게 하거나 연결되는 방식을 복잡하게 바꿀 것이다. 서로 다른 CONTEXT를 연결해야 하는 경우 CONTEXT는 서로에게 스며드는 경향이 있다.

- CONTEXT MAP은 프로젝트 관리와 소프트웨어 설계 영역 사이에 걸쳐 있는 개념.

- 물리적인 사무 공간 역시 컨텍스트 분리에 영향을 미칠 수 있는데, 서로 다른 도시는 말할 것도 없이 건물의 반대편에서 일하는 팀 구성원조차 통합을 위해 별도의 노력을 기울이지 않는다면 아마 서로 다른 컨텍스트로 나뉘고 말 것이다.



> 프로젝트 상의 유요한 모델을 식별하고 각 BOUNDED CONTEXT를 정의하라. 여기에는 비객체지향적인 하위 시스템에 대한 암시적인 모델도 포함된다. 각 BOUNDED CONTEXT에 이름을 부여하고 이 이름을 UBIQUITOUS LANGUAGE의 일부로 포함시켜라
>
>  의사소통을 위해 컨텍스트 간의 번역에 대한 윤곽을 명확하게 표현하고 컨텍스트 간에 공유해야 하는 정보를 강조함으로써 모델과 모델이 만나는 경계 지점을 서술하라.
>
>  각 컨텍스트의 현재 영역을 나타내는 지도를 작성하라. 컨텍스트의 배치를 바꾸는 일은 나중에 하라.

- MAP 어떤 형태가 없다. 다만 프로젝트에 속한 모든 사람들은 MAP을 이해하고 공유할 수 있으면 된다. 거기에서 명확한 이름을 제공하고, 경계 지점과 경계 지점의 특성을 명확하게 표현해야 한다.

- 두 팀에서 같은 목적으로 테스트 스위트를 두고 협업하는 것은 좋은 생각이다.

![image-20230319154126397](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-19/image-20230319154126397.png)

![image-20230319154134869](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-19/image-20230319154134869.png)

# CONTEXT MAP의 테스트

## CONTEXT MAP의 조직화와 문서화

> 신뢰하되, 검증하라 - 레이건 대통령

1. BOUNDED CONTEXT의 이름은 해당 BOUNDED CONTEXT에 관해 이야기할 수 있는 것이라야 한다. 그러한 이름은 팀의 유비쿼터스언어에 들어가야 한다.
2. 모든 이들이 경계가 어디에 위치하는지 알아야함, 어떠한 코드나 환경의 CONTEXT도 인식할 수 있어야 한다.

## BOUNDED CONTEXT 간의 관계

### SHARED KERNEL

![image-20230319154600652](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-19/image-20230319154600652.png)

 밀접하게 연관된 애플리케이션을 대상으로 작업 중인 팀 간의 협력이 조율되지 않는다면 잠시 동안은 작업을 진행할 수 있겠지만 각 팀이 만들어낸 결과물을 함께 조합하기는 쉽지 않을 것이다. 결국 처음부터 CONTINUOUS INTEGRATION을 적용했을 때보다 더 많은 시간을 번역 계층을 개발하고 구조를 개선하는 데 허비하게 될 것이며, 동시에 공통 UBIQUITOUS LANGUAGE를 구축하는 작업이 중복되고 UBIQUITOUS LANGUAGE로 얻을 수 있는 이점을 잃어버릴 것



> 두 팀 간에 공유하기로 한 도메인 모델의 부분집합을 명시하라. 물론 여기에는 모델의 부분집합뿐 아니라 모델 요소와 연관된 코드나 데이터베이스 설계의 부분집합까지도 포함된다. 명시적으로 공유하는 부분들은 특별한 상태를 가지며, 다른 팀과의 협의 없이는 변경할 수 없다.
>
>  기능 시스템을 자주 통합하라. 하지만 개별 팀에서 수행하는 CONTINUOUS INTEGRATION 빈도보다는 더 적은 빈도로 통합하라. 통합할 때는 양 팀에서 작성한 테스트를 모두 실행하라.

### CUSTOMER/SUPPLIER(고객/공급자)관계

 한 하위 시스템이 다른 시스템에 본질적으로 데이터를 공부할 때가 있다. "하류"컴포넌트는 "상류"컴포넌트에 피드백을 거의 제공하지 않는 분석 작업이나 여타 다른 기능을 수행하며, 모든 의존성은 단방향으로 흐른다.

- 두 팀 간에 명확한 고객/공급자 관계를 확립하라. 계획 회의에서 하류 팀이 상류 팀에 대한 고객 역할을 맡게 하라. 하류 요구사항에 대한 작업을 협상하고 이에 대한 예산을 책정해서 모든 이들이 일정과 약속을 이해할 수 있게 하라.
- 결과로 예상되는 인터페이스를 검증하게 될 자동화된 인수 테스트(acceptance test)를 함께 개발하라. 이 테스트를 상류팀의 테스트 스트위트에 추가해서 지속적인 통합의 일부로 실행되게 하라. 이러한 테스트를 토대로 상류 팀은 하류 시스템에서 발생할지도 모르는 부수효과를 두려워하지 않고 자유로이 코드를 변경할 수 있을 것이다.

### CONFORMIST(준수자)

- 두 개발 팀이 상류/하류 관계를 맺고 있고 상류 팀이 하류 팀의 필요성을 충족시킬 충분한 동기를 느낄 수 없다면 하류 팀은 속수 무책으로 무력해질 수밖에 없다. 이타주의를 발판 삼아 상류 개발자들이 약속을 할 수는 있어도 그 약속을 이행할 가능성은 희박하다. 상류 팀의 선한 의도를 신뢰한 하류 팀은 결코 사용할 수 없을 기능을 기반으로 게획을 작성하게 된다. 결국 현재 주어진 것만으로 진행해야 한다는 사실을 깨닫게 되기까지 하류 팀의 프로젝트는 지연될 것이다. 아울러 하류 팀의 필요에 맞춰진 인터페이스는 존재하지도 않을 것이다.

> 맹목적으로 상류 팀의 모델을 준수해서 BOUNDED CONTEXT 간의 변역에 따른 복잡도를 제거하라. 
>
>  CONFORMIST를 따를 경우 하류 팀 설계자들이 설계 형식이 상류 팀에 속박되고 애플리케이션을 위한 이상적인 모델을 만들지는 못해도 통합 자체는 매우 단순해질 수 있다. 또한 SUPPLIER 팀과 유비쿼터스언어를 공유할 수 있다. SUPPLIER가 주도적인 위치에 있으므로 SUPPLIER를 위해 의사소통을 용이하게 하는 것이 좋다. SUPPLIER가 여러분과 정보를 공유하게 하는 데 필요한 것은 이타주의 정도면 충분할 것이다.



CONFORMIST는 동일한 모델을 이용하는 영역과 추가를 통해 모델을 확장한 영역, 다른 모델이 영향을 미치는 영역을 보유한다는 점에서 SHARED KERNEL과 유사하다. 두 패턴 간의 차이점은 의사결정과 개발 과정에 있다. SHARED KERNEL이 밀접하게 조율하는 두 팀 간의 협력관계를 다룬다면 CONFORMIST는 협력에 관심이 없는 팀과의 통합 문제를 다룬다.



- 매우 협력지향적인 SHARED KERNEL
- CUSTOMER/SUPPLIER DEVELOPMENT TEAM
- 편향적인 CONFORMIST

BOUNDED CONTEXT 간의 통합과 관련된 다양한 스펙트럼의 협력관계를 다뤘다.



마지막으로 **다른 애플리케이션에는 협력이나 유용한 설계가 존재하지 않는다고 가정하는 더 비관적인 관점의 협력관계의** ANTICORRUPTION LAYER 를 보자.



### ANTICORRUPTION LAYER

 협력이 원활한 팀 간에 잘 설계된 BOUNDED CONTEXT를 연결하면 번역 계층은 단수하면서도 심지어 우아해질 수도 있지만, 경계의 다른 측면에서 누수가 발생하기 시작하면 번역 계층은 좀더 방어적인 형태를 취할지도 모른다.



> 다른 시스템과 상호작용하기 위한 거대한 인터페이스를 보유한 새로운 시스템을 구축할 경우 두 모델을 연계하는 데 따르는 어려움 때문에 임시방편으로 새로운 모델을 다른 시스템의 모델과 유사해지게끔 수정해서 새로운 모델의 의도가 전체적으로 매몰돼 버릴 수 있다. 레거시 시스템의 모델은 취약하고, 심지어 예외적으로 잘 설계된 경우라도 현재 프로젝트의 필요에 적합하지 않은 경우가 대부분이다. 그러나 통합을 거쳐 커다란 가치를 얻을지도 모르고 어떤 경우에는 통합이 절대적인 요구사항인 경우도 있다.



 외부 모델에 포함된 충분히 이해하지 못한 요소 탓에 모델이 손상되지 않게끔 다른 모델을 따르는 부분 간에 번역을 수행할 필요가 있다.

그러므로

 **클라이언트 고유의 도메인 모델 측면에서 기능을 제공할 수 있는 격리 계층을 만들어라. 격리 계층은 기존에 이미 존재하는 인터페이스를 거쳐 다른 시스템과 통신하므로 다른 시스템을 거의 수정하지 않아도 된다. 해당 계층에서는 내부적으로 필요에 따라 두 모델을 상대로 양방향으로 번역을 수행한다.**



**ANTICORRUPTION LAYER는 개념적인 객체와 행위를 하나의 모델과 프로토콜에서 다른 모델과 프로토콜로 변환하기 위한 메커니즘에 해당**



#### ANTICORRUPTION LAYER의 인터페이스 설계

 간혹 ENTITY의 형태를 띠기도 하지만 보통 SERVICE의 집합으로 표현된다. 두 시스템의 의미체계 간 번역을 담당하는 전반적으로 새로운 계층을 구축하다 보면 타 시스템의 행위를 새롭게 추상화하고 현재 시스템에 제공되는 타 시스템의 서비스와 정보를 현재 모델에 일관성 있게 제공할 기회를 얻는다. **외부 시스템을 우리의 모델 내에서 단일 컴포넌트로 표현한다는 것은 말이 되지 않는다.** 우리의 모델 관점에서 응집력 있는 책임을 맡는 여러 개의 SERVICE를 사용하는 것이 최선의 방법.



####  ANTICORRUPTION LAYER 구현

여러 시스템간의 상호작용에 필요한 통신 및 전송 메커니즘과 FACADE, ADAPTER, 번역기를 조합하는 것.



**FACADE** 는 하위 시스템에 대한 클라이언트의 접근을 단순화하고 더 쉽게 하위 시스템을 사용할 수 있게 만들어주는 대안 인터페이스.

 **ADAPTER** 는 행위를 구현하는 측에서 이해한 것과 다른 프로토콜을 클라이언트에서 사용하게 해주는 래퍼에 해당한다. 클라이언트에서 ADAPTER에 메시지를 전송하면 메세지는 의미상 동등한 메시지로 변환되어 "어탭티(ADAPTEE)"에 전송된다. **즉, 응답이 변환되어 재전송 되는 것.**



**번역기**. ADAPTER가 하는 일은 요청 방법을 파악하는 데 있다. 개념 객체나 데이터의 실제 변환은 자체적인 객체에 둘 수 있는 개별적이고 복잡한 작업이며, 변환을 거쳐 개념 객체나 데이터를 모두 쉽게 이해할 수 있다.

![image-20230324222720064](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-24/image-20230324222720064.png)



몇 가지 고려해야 할 사항

-  ANTICORRUPTION LAYER는 양방향일 수도 있으며, 자체적인 ADAPTER를 토대로 인터페이스 양측에 대한 SERVICE를 정의하는데, 잠재적으로는 **대칭적인 번역**을 거쳐 동일한 번역기를 이용. ANTICORRUPTION LAYER를 구현할 때 다른 하위 시스템이 바뀔 필요는 없지만 다른 시스템에서 ANTICORRUPTION LAYER의 SERVICE를 호출할 수 있게 바뀌어야 할지도 모른다.
- 다른 하위 시스템에 접근할 수 있다면 해당 접근 지점을 상대로 약간의 리팩터링을 거쳐 업무가 더욱 간편해질지도 모른다. 특히 가능한 한 자동화 테스트부터 시작하고 여러분이 사용할 기능에 대해 좀더 명시적인 인터페이스를 작성하려고 노력한다.
- 통합을 위한 요구사항이 광범위할수록 번역에 따르는 비용이 높아진다. 번역이 더욱 용이하게 하려면 설계 중인 시스템 가운데 외부 시스템에 근접한 모델을 선택할 필요가 있다.
- 다른 하위 시스템이 단순하거나 해당 하위 시스템에 포함돼 있는 인터페이스가 깔끔하다면 FACADE가 필요하지 않을지도 모른다.
- 기능이 **두 하위 시스템의 관계에만 국한된다면** ANTICORRUPTION LAYER에 해당 기능을 추가할 수 있다.

ANTICORRUPTION LAYER은 두 BOUNDED CONTEXT를 잇는 수단이다.



### SEPARATE WAYS

 **철저하게 요구사항들을 조사해야 한다.**

두 기능 간의 관계가 필수적인 것이 아니라면 두 기능은 서로 관계를 끊을 수도 있다.



**통합에는 언제나 비용이 많이 든다. 때로는 통합의 혜택이 적은 경우도 있다.**

**BOUNDED CONTEXT가 다른 것과 아무런 관계도 맺지 않도록 선언해서 개발자들이 이 작은 범위 내에서 단순하고 특화된 해결책을 찾을 수 있게 하라.**



### OPEN HOST SERVICE(공개 호스트 서비스)

 **어떤 하위 시스템을 다른 여러 하위 시스템과 통합해야 할 경우 각 하위 시스템에 대한 번역기를 조정한다면 팀 전체가 교착 상태에 빠질 수 있다. 변경이 발생할 때는 유지보수하고 걱정해야 할 일이 더욱 더 많은 법이다.**

>  하위 시스템 접근과 관련된 프로토콜을 일련의 SERVICE로 정의하라. 프로토콜을 공개해서 개발중인 시스템과 통합하고자 하는 모든 이들이 해당 프로토콜을 사용할 수 있게 하라. 새로운 통합 요구사항을 처리하게끔 프로토콜을 개선하고 확장하되 특정한 한 팀에서 요청해 오는 독특한 요구사항은 제외하라. 그와 같은 특수한 경우에는 일회성 번역기로 프로토콜을 보강해서 공유 프로토콜을 단순하고 일관되게 유지하라.

### 

### PUBLISHED LANGUAGE(공표된 언어)

XML??



#### 모델의 컨텍스트 전략 선택

- 실제로 우리는 우리가 작업 중인 주요 **CONTEXT의 일부를 구성하며,** 그리고 그와 같은 사실은 CONTEXT MAP에 반영되기 마련이다.

---

#### 경계의 변형

*문제는 아래의 요인들 사이에서 균형을 유지하는 데 있다.*

**규모가 큰 BOUNDED CONTEXT가 선호되는 경우**

- 사용자의 작업 흐름이 단일화된 모델을 토대로 처리될 때 더 매끄럽게 진행된다.
- 개별적인 두 모델의 매핑을 더하는 것보다 일관성 있는 하나의 모델을 이해하기가 더 쉽다.
- 두 모델 간의 번역이 어려울 수 있다(불가능한 경우도 있다)
- 공유 언어를 토대로 팀의 의사소통이 명확해진다.

**규모가 작은 BOUNDED CONTEXT가 선호되는 경우**

- 개발자 간의 의사소통에 따른 과부하가 줄어든다.
- 소규모 팀과 코드 기반의 토대로 CONTINUOUS INTEGRATION이 쉬워진다.
- 대형 컨텍스트에서는 용도가 다양한 추상화 모델을 요구할 수도 있는데, 이 경우 제공하기 힘든 기술이 필요할 때가 있다.
- 각기 다른 모델은 특수한 요구사항을 해결하는 데 도움되거나 유비쿼터시 언어의 특화된 방언과 전문적인 사용자 집단의 전문 용어를 포괄할 수 있다.



#### 변경할 수 없다는 사실을 인정하기: 외부 시스템의 묘사

- BOUNDED CONTEXT는 일정한 경계 내에서 모델을 통합하겠다는 **의도**에 따라 정의된다.

#### 외부 시스템과의 관계

적용할 수 있는 패턴 3가지

1. SEPARATE WAYS
2. CONFORMIST
3. ANTICORRUPTION LAYER

#### 설계 중인 시스템

- BOUNDED CONTEXT를 선언하고 각 BOUNDED CONTEXT안에서 CONTINUOUS INTEGRATION을 적용해 BOUNDED CONTEXT의 단일화를 유지할 수 있다.

#### 타협점

 ![image-20230325003919635](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-25/image-20230325003919635.png)

---

#### CONTEXT 병합: SEPARATE WAYS > SHARED KERNEL

번역에 따르는 과부하가 너무 높다. 중복이 너무나도 명백하게 드러난다. BOUNDED CONTEXT를 병합하는 이유는 다양하다. 하지만 병합하기가 쉽지 않다. 너무 늦지는 않았지만 어느 정도의 인내심이 필요하다.



 궁극적인 목표가 CONTINUOUS INTEGRATION을 토대로 단 하나의 CONTEXT로 완벽하게 병확하는 것이더라도 우선은 SHARED KERNEL로 옮기자.

1. 초기 상황 평가
2. 프로세스 수립
3. 병합을 시작할 대상으로 CORE DOMAIN의 일부가 **아닌** 두 CONTEXT에서 중복되는 부분을 포함하는 규모가 작은 하위 도메인을 선택
4. 하위 도메인에 대한 공유 모델을 만들어 내기 위해 두 팀에서 데려온 2명에서 4명의 개발자로 구성된 집단을 만든다. 모델의 도출 방식과는 관계없이 모델은 상세하게 작성해야 한다. 여기에는 동의어를 식별하고 아직 번역되지 않은 용어를 매핑하는 것과 같은 고된 작업이 포함된다.
5. 양쪽 팀의 개발자들은 모델을 구현하고(혹은 기존 공유 코드를 변경하고), 세부사항을 산출해내며, 그러한 세부사항을 기능으로 만드는 작업에 착수하낟. 개발자들이 모델과 관련된 문제에 봉착하면 그들은 3단계에서 팀을 재소집해서 필요한 개념을 개정하는 작업에 참여한다.
6. 각 팀의 개발자들은 새로운 SHARED KERNEL에 통합하는 작업에 착수
7. 더는 필요없는 변역 제거



#### CONTEXT 병합: SHARED KERNEL > CONTINUOUS INTEGRATION

1. CONTINUOUS INTEGRATION에 필요한 모든 프로세스(공유 코드 소유권, 빈번한 통합 등)가 각 팀에 개별적으로 갖춰져 있는지 확인한다. 모든 이들이 동일한 방식으로 업무를 수행할 수 있게 두 팀을 상대로 통합 절차를 일치시킨다.
2. 팀 간의 팀원 교류를 시작한다. 이렇게 하면 두 모델을 모두 이해하는 인력 풀(pool)이 조성되고 두 팀의 사람들이 서로 연결될 것
3. 각 모델의 디스틸레이션 과정을 각기 명확하게 만든다



#### 레거시 시스템의 단계적 폐기

 테스트 전략을 결정하는 것. 신규 시스템의 새로운 기능에 대해서는 자동화된 단위 테스트를 작성해야 하겠지만 레거시 시스템을 단계적으로 폐기하는 데는 특별한 테스트 요건이 생긴다. 어떤 조직에서는 일정 시간 동안 신규 시스템과 구형시스템을 나란히 운영하기도 한다.

1. 단일 반복주기 내에서 신규 시스템에 추가될 수도 있는 레거시의 특정기능을 파악
2. ANTICORRUPTION LAYER에 필요한 추가사항을 파악
3. 구현
4. 배치
5. ANTICORRUPTION LAYER에서 불필요한 부분을 파악해 이를 제거
6. 지금은 사용되지 않는 레거시 시스템 모듈을 삭제하는 것을 고려한다.