

본질적으로 사물이 아닌 활동(activity)이나 행동(action) 들이 우리의 모델링 패러다임이 객체이므로 그러한 연산이 객체와 잘 어울리게끔 노력해야 한다.



 적절한 객체로 다듬는 것을 쉽게 포기해서 점점 절차적 프로그래밍에 빠지게 된다.



 서비스는 특정 연산을 수행하는 것 이상의 의미는 없는 모델 객체로 가장해서 나타나 행위자(doer) 끝에 "Manager" 같은 것이 붙는다. 행위자는 자신의 상태를 비롯해 도메인에서 맡고 있는 연산 이상으로는 어떠한 의미도 갖지 않는다. 그럼에도 이러한 해법은 적어도 설제 모델 객체를 어지럽히지 않고도 뚜렷이 구분되는 행위의 근거지를 만들어준다.

> 도메인의 개념 가운데 객체로는 모델에 어울리지 않는 것이 있다. 필요한 도메인 기능을 ENTITY나 VALUE에서 억지로 맡게 하면 모델에 기반을 둔 객체의 정의가 왜곡되거나, 또는 무의미하고 인위적으로 만들어진 객체가 추가될 것이다.

 SERVICE는 모델에서 독립적인 인터페이스로 제공되는 연산으로서 ENTITY나 VALUE OBJECT와 달리 상태를 캡슐화하지 않는다. 



 **서비스** 라는 이름은 다른 객체와의 관계를 강조. 순전히 클라이언트에 무엇을 제공할 수 있느냐에 있다.



잘 만들어진 SERVICE 에는 세 가지 특징이 있다.

1. 연산이 원래부터 ENTITY나 VALUE OBJECT의 일부를 구성하는 것이 아니라 도메인 개념과 관련돼 있다.
2. 인터페이스가 도메인 모델의 외적 요소의 측면에서 정의된다.
3. 연산이 상태를 갖지 않는다.


 상태를 갖지 않는다는 것은 클라이언트가 특정 SERVICE 인스턴스의 개별 이력과는 상관없이 SERVICE의 모든 인스턴스를 사용할 수 있다는 의미다. SERVICE를 수행하면 전역적으로 접근 가능한 정보를 사용할 것이며, 심지어 그러한 전역 정보를 변경할 수도 있다.(다시 말해 부수효과(side effect)가 발생할 수 있다.) 그러나 **SERVICE는 대부분의 도메인 객체와 달리 자신의 행위에 영향을 줄 수 있는 상태를 갖지 않는다.**

> 도메인의 중대한 프로세스나 변환 과정이 ENTITY나 VALUE OBJECT의 고유한 책임이 아니라면 연산을 SERVICE로 선언되는 독립 인터페이스로 모델에 추가하라. 모델의 언어라는 측면에서 인터페이스를 정의하고 연산의 이름을 유비쿼터스언어의 일부가 되게끔 구성하라. SERVICE는 상태를 갖지 않게 만들어라.



서비스는 도메인 뿐만아니라, 다른 계층에서도 사용될 수 있다.

응용 SERVICE , 도메인 SERVICE, 인프라스트럭쳐의 SERVICE.
예를 들면 은행에서 계좌 잔고가 일정 금액 아래로 떨어지면 고객에게 이메일을 발송하는 애플리케이션이 있을지도 모른다. 이때 이메일 시스템과 통지 수단을 캡슐화하는 인터페이스는 인프라스트럭쳐 계층의 SERVICE에 해당한다.



도메인간에 애매한 것을 해결하는 것이 Service / 도메인과 무관한 프로세스를 가진 것은 어플리케이션 Service.

![image-20230313174254133](https://raw.githubusercontent.com/LenKIM/images/master/2023-03-13/image-20230313174254133.png)

**구성단위**

 SERVICE로 모델링할 때의 표현력에 비중을 두고는 있지만 이 패턴은 ENTITY와 VALUE OBJECT로부터 클라이언트를 분리하는 것과 함께 도메인 계층의 인터페이스 구성 단위를 제어하는 수단으로서도 매우 가치가 있다.



 구성 단위가 중간 크기(medium-grained) 무상태 SERVICE는 대형 시스템에서 재사용하기가 더 쉬울 수 있는데, 왜냐하면 그러한 서비스는 단순한 인터페이스 너머에 중요한 기능을 캡슐화하고 있기 때문. 

 앞서 논의한 바와 같이 구성 단위가 세밀한 도메인 객체는 도메인에서 지식이 새어 나오게 해서 도메인 객체의 행위를 조정하는 응용 계층으로 흘러가게 할 수 있다,. 그렇게 되면 고도로 세분화된 상호작용의 복잡성이 결국 응용 계층에서 처리되고, 도메인 게층에서 사라진 도메인 지식이 응용 계층의 코드나 사용자 인터페이스 계층의 코드로 스며든다. 도메인 서비스를 적절히 도입하면 계층 간의 경계를 선명하게 하는 데 도움될 수 있다.

 이 패턴은 클라이언트 제어와 융통성보다는 인터페이스의 단순함을 선호한다. 이는 대형 시스템이나 분산 시스템에서 컴포넌트를 패키지화하는 데 매우 유용한 구성 단위의 기능성을 제공한다. 때로는 Service가 도메인 개념을 표현하는 가장 자연스러운 방법이다.



--



 애그리게잇이나 값 객체 상에서 수행해야 하는 오퍼레이션이 메소드로는 부적절하게 느껴질 때. 우린 이러한 불편한 느낌을 지우려고 애그리게잇 루트의 클래스상에 아무렇지도 않게 정적 메소드를 생성하는 경향이 있다.





바깥에서 바라보는 관점과 내부에서 보는 관점에 따라 달라야 한다.

SRP 위반

각 레이어드 아키텍쳐의 역할은?