# 01. 스트림이란 무엇인가?

**컬렉션**은 만들고 처리하는 과정을 포함. 대부분의 작업에서 필수적인 요소.

그러나 우리는 여기서 컬렉션이 가지지 못한 2가지 단점을 이야기해볼 수 있다.

1. SQL과 같은 질의를 할 수 있는가?
2. 많은 요소를 포함하는 커다란 컬렉션은 어떻게 처리해야 될까?

이 두가지 단점을 해결하기 위해 스트림이 출연.



스트림이란, 선언현(즉, 데이터를 처리하는 임시 구현 코드 대신 질의로 표현할 수 있다.)으로 컬렉션 데이터를 처리할 수 있다. 또한, 스트림을 이용하면 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다.

```java
import static java.util.Comparator.comparing;

List<String> lowCaloricDishesName =  
                menu.stream()
                        .filter(d -> d.getCalories() < 400)
                        .sorted(comparing(Dish::getCalories))
                        .map(Dish::getName)
                        .collect(toList());
```

대표적인 스트림 예제를 위에서 보였다.



스트림의 장점은 뭘까?

- **선언형** 으로 코드를 구현할 수 있다. 즉, 루프와 if조건문 등의 제어 블록을 사용해서 **어떻게** 동작을 구현할지 지정할 필요 없이 '저칼로리의 요리만 선택하라' 같은 동작의 수행을 지정할 수 있다.
- filter, sorted,map,collect 같은 여러 빌딩 블록 연산을 연결해서 복잡한 데이터 처리 파이프라인을 만들 수 있다.  여러 연산을 *파이프라인* 으로 만들어도 여전히 가독성과 명확성은 유지.

- 그 외 특징으로
  - 선언형  
    : 더 간결하고 가독성이 좋아진다.
  - 조림할 수 있음  
    : 유연성이 좋아진다.
  - 병렬화  
    : 성능이 좋아진다.



다시 정리해보자. ***스트림이란 무엇일까?***

**'데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소'** 로 정의할 수 있다.

- 연속된 요소  
  : 컬렉션은 자료구조이므로 컬렉션에서는 시간과 공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룬다. 반면 스트림은 filter, sorted, map처럼 표현 계산식이 주를 이룬다. 즉, 컬렉션의 주제는 데이터고 스트림의 주제는 계산이다.
- 소스  
  : 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 **소비(consume)** 한다. 정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지. 
- 데이터 처리 연산  
  : filter, map, reduce, find, match, sort 등으로 데이터를 조작.
- 파이프라이닝  
  : 게으름(laziness), 쇼트서킷(short-circuiting)
- 내부 반복  
  : 추상적으로 가려져 함수 내부에서 반복되는 것
- filter  
  :특정요서 제외
- map
- limit
- collect  
  : 스트림을 다른 형식으로 변환. collect가 다양한 변환 방법을 인수로 받아 스트림에 누적된 요소를 특정 결과로 변환시키는 기능을 수행.

![image-20190810104827293](http://ww2.sinaimg.cn/large/006tNc79gy1g5uccrfyfyj314w0u0npi.jpg)

# 02. 컬렉션과 스트림

컬렉션과 스트림 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공. 여기서 **연속된(sequenced)** 표현은 순서와 상관없이 아무 값에나 접속하는 것이 아니라 순차적으로 값에 접근한다는 것을 의미.



***데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이.***

컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조. 즉, 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다. 

반면, 스트림은 이론적으로 요쳥할 때만 요소를 계산하는 고정된 자료구조.(스트림에 요소를 추가하거나 스트림에서 요소를 제거할 수 없다.)



![image-20190810105331170](http://ww1.sinaimg.cn/large/006tNc79gy1g5uci9kmgxj31400u0qvg.jpg)



*스트림은 반복자와 마찬가지로 딱 한 번만 탐색할 수 있다.*

즉, 탐색된 스트림의 요소는 소비(consume) 된다. 반복자와 마찬가지로 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다.

```java
List<String> title = Arrays.asList("Java8", "In", "Action");
Stream<String> s = title.stream();
s.forEach(System.out::println); // title의 각 요소가 출력
s.forEach(System.out::println); // java.lang.IllegalstateException 발생.
```

>*스트림과 컬렉션의 철학적 접근*
>
>스트림을 시간적으로 흩어진 값의 집합으로 간주한다면, 컬렉션은 특정 시간에 모든 것이 존재하는 공간(컴퓨터 메모리)에 흩어진 값으로 비유할 수 있다.

# 03. 내부 반복과 외부 반복

- 컬렉션은 외부 반복(예를 들어 for-each 등을 사용해서)

- 스트림은 내부 반복(반복을 알아서 처리하고 결과 스트림 값을 어딘가에 저장해주는)



**내부 반복이 주는 이점은 뭘까?**

작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다. 지연평가가 가져다주는 이점과 비슷.

![image-20190810110308482](http://ww2.sinaimg.cn/large/006tNc79gy1g5ucrxmn66j310c0u07wn.jpg)



# 04. 중간 연산과 최종 연산

중간연산과 최종연산까지 가는데의 과정을 설명해보자.

- 질의를 수행할 (컬렉션 같은) **데이터 소스**
- 스트림 파이프라인을 구성할 **중간 연산** 연결
- 스트림 파이프라인을 실행하고 결과를 만들 **최종 연산**

스트림 파이프라인의 개념은 빌더패턴(builder pattern) 과 비슷하다. 빌더 패턴에서는 호출을 연결해서 설정을 만든다.

![image-20190810110939786](http://ww1.sinaimg.cn/large/006tNc79gy1g5ud5vmrpij31ga0u0e85.jpg)

# 05. 요약

- 스트림은 소스에서 추출된 연속 요소로, 데이터 처리 연산을 지원
- 스트림은 내부 반복을 지원, 내부 반복은 filter, map, sorted 등의 연산으로 반복을 추상화
- 스트림에는 중간 연산과 최종연산이 있다.
- filter와 map 처럼 스트림을 반환하면서 다른 연산과 연결될 수 있는 연산을 중간 연산이라고 한다. 중간 연산을 이용해서 파이프라인을 구성할 수 있지만 중간 연산으로는 어떤 결과도 생성할 수 없다
- forEach나 count 처럼 스트림 파이프라인을 처리해서 스트림이 아닌 결과를 반환하는 연산을 최종연산이라고 한다.
- 스트림의 요소는 요청할 때만 계산된다.

