# Java 8 In Action

1장. 자바 8을 눈여겨봐야 하는 이유  
1.1 왜 아직도 자바는 변화하는가?  
1.2 자바 함수  
1.3 스트림  
1.4 디폴트 메서드  
1.5 함수형 프로그래밍에서 가져온 다른 유용한 아이디어  
1.6 요약  
  
  
  
2장. 동작 파라미터화 코드 전달하기  
2.1 변화하는 요구사항에 대응하기  
2.2 동작 파라미터화  
2.3 복잡한 과정 간소화  
2.4 실전 예제  
2.5 요약  
  
3장. 람다 표현식  
3.1 람다란 무엇인가  
3.2 어디에, 어떻게 람다를 사용할까?  
3.3 람다 활용: 실행 어라운드 패턴  
3.4 함수형 인터페이스 사용  
3.5 형식 검사, 형식 추론, 제약  
3.6 메서드 레퍼런스  
3.7 람다, 메서드 레퍼런스 활용하기!  
3.8 람다 표현식을 조합할 수 있는 유용한 메서드  
3.9 비슷한 수학적 개념  
3.10 요약  
  
<2부 함수형 데이터 처리>  
  
4장. 스트림 소개  
4.1 스트림이란 무엇인가?  
4.2 스트림 시작하기  
4.3 스트림과 컬렉션  
4.4 스트림 연산  
4.5 요약  
  
5장. 스트림 활용  
5.1 필터링, 슬라이싱  
5.2 매핑  
5.3 검색과 매칭  
5.4 리듀싱  
5.5 모든 기법 활용  
5.6 숫자형 스트림  
5.7 스트림 만들기  
5.8 요약  
  
6장. 스트림과 데이터 수집  
6.1 컬렉터란 무엇인가?  
6.2 리듀싱과 요약  
6.3 그룹화  
6.4 분할  
6.5 Collector 인터페이스  
6.6 커스텀 컬렉터를 구현해서 성능 개선하기  
6.7 요약  
  
7장. 병렬 데이터 처리와 성능  
7.1 병렬 스트림  
7.2 포크/조인 프레임워크  
7.3 Spliterator  
7.4 요약  
  
<3부 효과적인 자바 8 프로그래밍>  
  
8장. 리팩토링, 테스팅, 디버깅  
8.1 가독성과 유연성을 개선하는 리팩토링  
8.2 람다로 객체지향 디자인 패턴 리팩토링하기  
8.3 람다 테스팅  
8.4 디버깅  
8.5 요약  
  
9장. 디폴트 메서드  
9.1 변화하는 API  
9.2 디폴트 메서드란 무엇인가?  
9.3 디폴트 메서드 활용 패턴  
9.4 해결 규칙  
9.5 요약  
  
10장. null 대신 Optional  
10.1 값이 없는 상황을 어떻게 처리할까?  
10.2 Optional 클래스 소개  
10.3 Optional 적용 패턴  
10.4 Optional을 사용한 실제 예제  
10.5 요약  
  
11장. CompletableFuture: 조합할 수 있는 비동기 프로그래밍  
11.1 Futures  
11.2 비동기 API 구현  
11.3 비블록 코드 만들기  
11.4 비동기 작업 파이프라인 만들기  
11.5 CompletableFuture의 종료에 대응하는 방법  
11.6 요약  
  
12장. 새로운 날짜, 시간 API  
12.1 LocalDate, LocalTime, Instant, Duration, Period  
12.2 날짜 조정, 파싱, 포매팅  
12.3 다양한 시간대와 캘린더 활용 방법  
12.4 요약  
  
<4부 자바 8의 한계를 넘어서>  
  
13장. 함수형 관점으로 생각하기  
13.1 시스템 구현과 유지보수  
13.2 함수형 프로그래밍이란 무엇인가?  
13.3 재귀와 반복  
13.4 요약  
  
14장. 함수형 프로그래밍 기법  
14.1 함수는 모든 곳에 존재한다  
14.2 영속 자료구조  
14.3 스트림과 게으른 평가  
14.4 패턴 매칭  
14.5 기타 정보  
14.6 요약  
  
15장. OOP와 FP의 조화: 자바 8과 스칼라 비교  
15.1 스칼라 소개  
15.2 함수  
15.3 클래스와 트레이트  
15.4 요약  
  
16장. 결론 그리고 자바의 미래  
16.1 자바 8의 기능 리뷰  
16.2 자바의 미래  
16.3 결론  
  
---  
  
TODO   
  
CHAPTER 8 컬렉션 API 개선  
8.1 컬렉션 팩토리  
8.2 리스트와 집합 처리  
8.3 맵 처리  
8.4 개선된 ConcurrentHashMap  
8.5 마치며  
  
CHAPTER 10 람다를 이용한 도메인 전용 언어  
10.1 도메인 전용 언어  
10.2 최신 자바 API의 작은 DSL  
10.3 자바로 DSL을 만드는 패턴과 기법  
10.4 실생활의 자바 8 DSL  
10.5 마치며  
  
CHAPTER 14 자바 모듈 시스템  
14.1 압력 : 소프트웨어 유추  
14.2 자바 모듈 시스템을 설계한 이유  
14.3 자바 모듈 : 큰 그림  
14.4 자바 모듈 시스템으로 애플리케이션 개발하기  
14.5 여러 모듈 활용하기  
14.6 컴파일과 패키징  
14.7 자동 모듈  
14.8 모듈 정의와 구문들  
14.9 더 큰 예제 그리고 더 배울 수 있는 방법  
14.10 마치며  
  
[ PART V 개선된 자바 동시성 ]  
  
CHAPTER 15 CompletableFuture와 리액티브 프로그래밍 컨셉의 기초  
15.1 동시성을 구현하는 자바 지원의 진화  
15.2 동기 API와 비동기 API  
15.3 박스와 채널 모델  
15.4 CompletableFuture와 콤비네이터를 이용한 동시성  
15.5 발행-구독 그리고 리액티브 프로그래밍  
15.6 리액티브 시스템 vs 리액티브 프로그래밍  
15.7 마치며  
  
CHAPTER 16 CompletableFuture : 안정적 비동기 프로그래밍  
16.1 Future의 단순 활용  
16.2 비동기 API 구현  
16.3 비블록 코드 만들기  
16.4 비동기 작업 파이프라인 만들기  
16.5 CompletableFuture의 종료에 대응하는 방법  
16.6 로드맵  
16.7 마치며  
  
CHAPTER 17 리액티브 프로그래밍  
17.1 리액티브 매니패스토  
17.2 리액티브 스트림과 플로 API  
17.3 리액티브 라이브러리 RxJava 사용하기  
17.4 마치며  
  
  
CHAPTER 18 함수형 관점으로 생각하기  
18.1 시스템 구현과 유지보수  
18.2 함수형 프로그래밍이란 무엇인가?  
18.3 재귀와 반복  
18.4 마치며  
  
CHAPTER 19 함수형 프로그래밍 기법  
19.1 함수는 모든 곳에 존재한다  
19.2 영속 자료구조  
19.3 스트림과 게으른 평가  
19.4 패턴 매칭  
19.5 기타 정보  
19.6 마치며  
  
부록  
APPENDIX A 기타 언어 업데이트  
APPENDIX B 기타 라이브러리 업데이트  
APPENDIX C 스트림에 여러 연산 병렬로 실행하기  
APPENDIX D 람다와 JVM 바이트코드  
