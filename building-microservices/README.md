# 마이크로서비스 아키텍처 구축

1장. 마이크로서비스
- [X] 1.1 마이크로서비스란  
- [X] 1.2 주요 혜택  
- [X] 1.3 서비스 지향 아키텍처란  
- [X] 1.4 기타 분해 기술  
- [X] 1.5 은총알은 없다  
- [X] 1.6 마치며  

2장. 진화적 아키텍트
- [X] 2.1 부정확한 비교  
- [X] 2.2 아키텍트에 대한 진화적 관점  
- [X] 2.3 구역화  
- [X] 2.4 원칙적인 접근법  
- [X] 2.5 필수 기준  
- [X] 2.6 코드를 통한 통제  
- [X] 2.7 기술 부채  
- [X] 2.8 예외 처리  
- [X] 2.9 중앙에서의 거버넌스와 지휘  
- [X] 2.10 팀 만들기  
- [X] 2.11 마치며  

3장. 서비스 모델링하기
- [x] 3.1 뮤직코퍼레이션 소개  
- [x] 3.2 무엇이 좋은 서비스를 만드는가?  
- [x] 3.3 경계가 있는 콘텍스트  
- [x] 3.4 비즈니스 능력  
- [x] 3.5 거북이 밑에 거북이  
- [x] 3.6 비즈니스 콘셉트 관점에서의 커뮤니케이션  
- [x] 3.7 기술적 경계  
- [x] 3.8 마치며  

4장. 통합
- [ ] 4.1 이상적인 통합 기술 모색  
- [ ] 4.2 고객과의 인터페이싱  
- [ ] 4.3 공유 데이터베이스  
- [ ] 4.4 동기와 비동기  
- [ ] 4.5 오케스트레이션과 코레오그래피  
- [ ] 4.6 원격 프로시저 호출  
- [ ] 4.7 REST  
- [ ] 4.8 비동기 이벤트 기반의 협업 구현  
- [ ] 4.9 상태 기계로서의 서비스  
- [ ] 4.10 반응형 확장  
- [ ] 4.11 마이크로서비스 세계에서 코드 재사용의 위험과 DRY  
- [ ] 4.12 참조에 의한 접근  
- [ ] 4.13 버전 관리  
- [ ] 4.14 사용자 인터페이스  
- [ ] 4.15 외부 소프트웨어와 통합  
- [ ] 4.16 마치며  

5장. 모놀리스 분해하기
- [ ] 5.1 접합부가 중요하다  
- [ ] 5.2 뮤직코퍼레이션 분해하기  
- [ ] 5.3 모놀리스를 분리하는 이유  
- [ ] 5.4 뒤엉킨 의존성  
- [ ] 5.5 데이터베이스  
- [ ] 5.6 문제에 대처하기  
- [ ] 5.7 예: 외부 키 관계 깨뜨리기  
- [ ] 5.8 예: 공유된 정적 데이터  
- [ ] 5.9 예: 공유 데이터  
- [ ] 5.10 예: 공유된 테이블  
- [ ] 5.11 데이터베이스 리팩토링  
- [ ] 5.12 트랜잭션의 경계  
- [ ] 5.13 리포팅  
- [ ] 5.14 리포팅 데이터베이스  
- [ ] 5.15 서비스 호출을 통한 데이터 추출  
- [ ] 5.16 데이터 펌프  
- [ ] 5.17 이벤트 데이터 펌프  
- [ ] 5.18 백업 데이터 펌프  
- [ ] 5.19 실시간을 향해  
- [ ] 5.20 변경 비용  
- [ ] 5.21 원인 파악  
- [ ] 5.22 마치며  

6장. 배포
- [ ] 6.1 지속적 통합이란  
- [ ] 6.2 지속적 통합을 마이크로서비스로 매핑하기  
- [ ] 6.3 빌드 파이프라인과 지속적 배포  
- [ ] 6.4 플랫폼별 산출물  
- [ ] 6.5 운영 체제 산출물  
- [ ] 6.6 커스텀 이미지  
- [ ] 6.7 환경  
- [ ] 6.8 서비스 환경 구성  
- [ ] 6.9 서비스와 호스트 매핑  
- [ ] 6.10 자동화  
- [ ] 6.11 물리 머신에서 가상화로  
- [ ] 6.12 배포 인터페이스  
- [ ] 6.13 마치며  

7장. 테스팅
- [ ] 7.1 테스트의 종류  
- [ ] 7.2 테스트의 범위  
- [ ] 7.3 서비스 테스트 구현하기  
- [ ] 7.4 까다로운 엔드 투 엔드 테스트  
- [ ] 7.5 엔드 투 엔드 테스팅의 단점  
- [ ] 7.6 신뢰할 수 없고 취약한 테스트  
- [ ] 7.7 스토리가 아닌 테스트 여정  
- [ ] 7.8 우리를 구할 소비자 주도 테스트  
- [ ] 7.9 엔드 투 엔드 테스트를 사용해야 하는가?  
- [ ] 7.10 출시 후의 테스팅  
- [ ] 7.11 교차기능 테스트  
- [ ] 7.12 마치며  

8장. 모니터링
- [ ] 8.1 단일 서비스, 단일 서버  
- [ ] 8.2 단일 서비스, 다수 서버  
- [ ] 8.3 다수 서비스, 다수 서버  
- [ ] 8.4 로그, 로그, 더 많은 로그...  
- [ ] 8.5 다수 서비스 간의 측정지표 추적  
- [ ] 8.6 서비스 측정지표  
- [ ] 8.7 합성 모니터링  
- [ ] 8.8 상관관계 ID  
- [ ] 8.9 전파  
- [ ] 8.10 표준화  
- [ ] 8.11 관객 고려하기  
- [ ] 8.12 앞으로  
- [ ] 8.13 마치며  

9장. 보안
- [ ] 9.1 인증과 권한부여  
- [ ] 9.2 서비스 대 서비스 인증과 권한부여  
- [ ] 9.3 보관 중인 데이터 보호하기  
- [ ] 9.4 심층 방어  
- [ ] 9.5 시범 예제  
- [ ] 9.6 절약하라  
- [ ] 9.7 인적 요소  
- [ ] 9.8 황금률  
- [ ] 9.9 보안 탑재  
- [ ] 9.10 외부 검증  
- [ ] 9.11 마치며  

10장. 콘웨이의 법칙과 시스템 설계
- [ ] 10.1 증거  
- [ ] 10.2 넷플릭스와 아마존  
- [ ] 10.3 이것으로 무엇을 할 수 있을까?  
- [ ] 10.4 의사소통 경로 적응  
- [ ] 10.5 서비스 소유권  
- [ ] 10.6 공유된 서비스의 추진  
- [ ] 10.7 내부 오픈 소스  
- [ ] 10.8 경계가 있는 콘텍스트와 팀 구조  
- [ ] 10.9 방치된 서비스  
- [ ] 10.10 사례 연구: RealEstate.com.au  
- [ ] 10.11 콘웨이의 역법칙  
- [ ] 10.12 사람  
- [ ] 10.13 마치며  

11장. 대규모 마이크로서비스
- [ ] 11.1 장애는 어디에서나 발생한다  
- [ ] 11.2 얼마나 많아야 너무 많은 건가?  
- [ ] 11.3 기능 분해  
- [ ] 11.4 아키텍처 안전 조치  
- [ ] 11.5 안티프래질 조직  
- [ ] 11.6 멱등성  
- [ ] 11.7 확장  
- [ ] 11.8 데이터베이스 확장  
- [ ] 11.9 캐싱  
- [ ] 11.10 자동 확장  
- [ ] 11.11 CAP 정리  
- [ ] 11.12 서비스 발견  
- [ ] 11.13 동적 서비스 레지스트리  
- [ ] 11.14 문서화 서비스  
- [ ] 11.15 자기 기술 시스템  
- [ ] 11.16 마치며  

12장. 종합 정리
- [ ] 12.1 마이크로서비스의 원칙  
- [ ] 12.2 언제 마이크로서비스를 사용하지 않아야 하는가?  
- [ ] 12.3 이 책을 마치며  
