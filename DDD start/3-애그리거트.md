# 애그리거트

Goal
> 애그리거트 역할 
> 애그리거트 루트와 역할 
> 애그리거트와 리포지터리
> ID을 이용한 애그리거트 참조 


## 애그리거트

애그리거트는 무엇인가?

`관련된 객체를 하나의 군으로 묶어주는 것이다.`

상위 수준 개념을 이요해서 전체 모델을 정리하면 전반적인 관계를 이해하는데 도움을 주는데, 이때 사용될 수 있는 개념이 바로 애그리거트이다.

![image-20221214231424339](/Users/len/Library/Application Support/typora-user-images/image-20221214231424339.png)



> 애그리거트는 복잡한 모델을 관리하는 기준을 제공한다.



애그리거트는 모델을 이해하는 데 도움을 줄 뿐만아니라 일관성을 관리하는 기준도 된다. 모델을 보다 잘 이해할 수 있고 애그리거트 단위로 일관성을 관리하기 때문에, 애그리거트는 복잡한 도메인을 단순한 구조로 만들어 준다. 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력(개발 시간)도 줄어든다.



애그리거트는 경계를 갖는다. 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. **경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.** 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다. 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높다.



그럼 둘 이상의 애그리거트는 어떻게 해야될까?



> 주의!
>
> 흔히 'A가 B를 갖는다'로 설계할 수 있는 요구사항이 있다면 A와 B를 한 애그리거트로 묶어서 생각하기 쉽다. 주문의 경우 Order가 ShippingInfo와 Orderer를 가지므로 이는 어느 정도 타당해 보인다. 하지만 'A가 B를 갖는다'로 해석할 수 있는 요구사항이 있다고 하더라도 이것이 반드시 A와 B가 애그리거트에 속한다는 것을 의미하는 것은 아니다.
>
>  상품과 리뷰을 예시로 보면 같은 애그리거트에 속하는 것처럼 오해할 수 있다. 그러나 같은 애그리거트에 속한다고 말할 수는 없다. 그 이유는 상품과 리뷰는 함께 생성되거나 변경되지 않고 변경 주체도 다르기 때문에 서로 다른 애그리거트에 속한다.

## 애그리거트 루트

애그리거트 루트는 애그리거트가 여러 객체로 구성되기 때문에 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트 루트 엔티티이다. 애그리거트 루트 엔티티는 애그리거트의 대표 엔티티다. 



### 도메인 규칙과 일관성

 애그리거트 루트의 책임은 무엇인가? 바로 애그리거트의 일관성을 깨지지 않도록 하는 것이다. 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다. **예를 들어, 주문 애그리거트는 배송지 변경, 상품 변경과 같은 기능을 제공하고, 애그리거트 루트인 Order가 이 기능을 구현한 메서드를 제공한다.**



***애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다.***

이 말이 의미하는 바는 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다는 말이다. 그렇게 되면 일관성을 깨는 원인이 된다.

```java
ShippingInfo si = order.getShippingInfo();
si.setAddress(newAddress);
```



  직접 정보를 변경하는 것은 업무 규칙을 무시하고 DB 테이블의 데이터를 수정하는 것과 같은 결과를 만든다. 즉 논리적인 데이터 일관성이 깨지게 되는 것이다. 일관성을 지키기 위해 다음과 같이 상태 확인 로직을 응용서비스에 구현할 수도 있다. 하지만 이렇게 되면 **동일한 검사 로직을 여러 응용 서비스**에서 중복으로 구현할 가능성이 높아져 유지보수에 도움이 되지 않는다.

```java
ShippingInfo si = order.getShippingInfo();

// 주요 도메인 로직이 중복되는 문제
if(state != OrderState.PAYMENT_WAITING && state != OrderState.PREPARING) {
  throw new IllegalArgumentException();
}
si.setAddress(newAddress);
```



애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 

- 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
- 밸류 타입은 불변으로 구현한다.



#### 애그리거트 루트의 기능 구현

 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다. 예를 들어 Order는 총 주문 금액을 구하기 위해 OrderLine 목록을 사용한다.

 ```java
 public class OrderLines {
   private List<OrderLine> lines;
   
   public Money getTotalAmounts(){...구현;}
   public void changeOrderLines(List<OrderLine> newLines) {
     this.lines = newlines;
   }
 }
 ```

 이 경우 Order의 changeOrderLines() 메서드는 다음과 같이 내부의 orderLines필드에 상태 변경을 위임하는 방식으로 기능을 구현한다.



#### 트랜잭션 범위

- 동일하게 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다. 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 더 높아지기 때문에 한 번에 수정하는 애그리거트 개수가 많아질수록 전체 처리량이 떨어지게 된다.
- 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현한다.

```java
public class ChangeOrderService {
  // 두 개 이상의 애그리거트를 변경해야 하면,
  // 응용 서비스에서 각 애그리거트의 상태를 변경한다.
  @Transactional
  public void changeShippingInfo(OrderId id, ShippingInfo newShippingInfo, boolean useNewShippingAddrAsMemberAddr) {
    Order order = orderRepository.findById(id);
    order.shipTo(newShippingInfo);
    if(useNewShippingAsMemberAddr) {
      Member member = findMember(order.getOrderer());
      member.changeAddress(newShippingInfo.getAddress());
    }
  }
}
```



도메인 이벤트를 사용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있다.

 한 트랜잭션에서 한 개의 애그리거트를 변경하는 것을 권장하지만, 다음 경우에는 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.

- 팀 표준: 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우가 있다.
- 기술 제약: 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 한다.
- UI 구현의 편리: 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 것이다. 이 경우 한 트랜잭션에서 여러 주문 애그리거트의 상태를 변경해야 한다.

## 리포지터리와 애그리거트

애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다. 

어떤 기술을 이용해서 리포지터리를 구현하느냐에 따라 애그리거트의 구현도 영향을 받는다.



## 3.4 ID를 이용한 애그리거트 참조

 한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다. 애그리거트 관리 주체는 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트 루트를 참조한다는 것과 같다.

ID를 이용해서 다른 애그리거트를 참조하자. DB 테이블에서 외래키로 참조하는 것과 비슷하게 ID를 이용한 참조는 다른 애그리거트를 참조할 때 ID를 사용한다.

이는 애그리거트의 경계를 명확히 하고 애그리거트 간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰준다.

구현 복잡도도 낮아진다. 다른 애그리거트를 직접 참조하지 않으므로 애그리거트 간 참조를 지연 로딩으로 할지 즉시 로딩으로 할지 고민하지 않아도 된다. 참조하는 애그리거트가 필요하면 응용 서비스에서 ID를 이용해서 로딩하면 된다.



**ID참조 방식을 사용하면서 N+1 조회와 같은 문제가 발생하지 않도록 하려면 조회 전용 쿼리를 사용하면 된다. 또는 조회 전용 저장소를 따로 구성하는것이다.**



## 3.5 애그리거트 간 집합 연관

애그리거트 간 1-N 과 M-N 연관에 대해서 살펴보자.

Product < -N----1- >  Category 가 있다.

이라면,  카테고리 하나에 많은 프로덕트가 포함된다면 조회시 문제가 발생할 수 있다. 그러므로, N-1로 연관 지어 구해야 한다?



## 3.6 애그리거트를 팩토리로 사용하기



