# CQRS 패턴

CQRS 패턴을 논하기 위해서는 단일 모델에 대한 단점을 이해해야 한다.



 어떤 조회기능을 구현하는 과정에서 우리는 아래와 같은 상황에 놓인다. 특히 MSA 환경에서 말이다.

<img src="https://s2.loli.net/2023/02/01/qKCoQpF1R7mLirx.png" alt="image-20230201113624931" style="zoom:50%;" />

Order, Product, Member 각각은 동작되는 마이크로서비스로서 각각의 API 을 요청해서 조합하는 형태로 주문 상세 조회 화면을 만들 것이다. 이때 만들 수 있는 방식은 다양하게 가져갈 수 있는데, 정답은 없다.

 만약 하나의 단일모델의 경우 SELECT 쿼리로 해결 할 수 있을 것이다. 그러나, 여러번의 조회가 이뤄질 수 있기 때문에 성능상에 문제가 발생할 여지가 있다.



어떤 방식으로든 단순한 방식으로는 여러 곳의 AGGREGTE을 조회해야만 하는 문제를 심플하게 해결할 수 없다. 주문 상세 조회 화면이 복잡해지거나 도메인의 기능이 추가될 경우 구현 복잡도는 점점더 복잡해질 수 밖에 없다.

 이런 구현 복잡도를 낮추는 간단한 방법이 있는데, 그것은 바로 **상태 변경을 위한 모델**과 **조회를 위한 모델을 분리하는 것**이다.

### CQRS

 시스템이 제공하는 기능은 크게 두 가지로 분리할 수 있다.

**하나는 상태를 변경하는 기능**

 흔히 우리가 아는 도메인 모델을 만드는 곳이다.  
예를 들어, 새로운 주문을 생성하거나, 배송지 정보를 변경하거나, 회원 암호를 변경하는 기능등 애그리거트의 상태를 변경하는 것이다.

또다른 하나라는 **사용자입장에서 상태 정보를 조회하는 기능**

오직 조회만을 위한 도메인 모델을 만드는 곳으로 익숙하지 않을 수 있다. 
 게시글 목록보기, 회원 정보 보기, 판매 통계 보기가 이에 해당한다.



CQRS 는 Command Query Responsiblity Segregation 약자로 상태를 변경하는 명령을 위한 모델과 상태를 제공하는 조회를 위한 모델을 분리하는 패턴이다.



<img src="https://s2.loli.net/2023/02/01/pC2rJyAFfkdw3Tj.png" alt="image-20230201114916297" style="zoom:50%;" />



 CQRS는 복잡한 도메인에 적합하다. 복잡할수록 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 난다. 만약 이 두 기능을 단일 모델로 처리하면 조회 기능의 로딩 속도를 위해 도메인 구현이 필요 이상으로 복잡해진다. 하지만 이런 복잡한 도메인에 CQRS를 적용하면 통계를 위한 조회 모델을 별도로 만들기 때문에 조회 기능때문에 도메인 모델이 복잡해지는 것을 막을 수 있다.



분리함으로써 주어지는 또다른 이점으로 각 모델에 맞는 구현 기술을 선택할 수 있다. Command 모델은 JPA 로 Query 모델은 JDBC 로 구현할 수 있다.

<img src="https://s2.loli.net/2023/02/01/tbdiCLxnyFkvY8J.png" alt="image-20230201115517032" style="zoom:50%;" />



또는 같은 구현 기술을 사용하더라도 서로 다른 데이터 저장소를 사용할 수도 있다.

Command 영역은 RDBMS를 사용하고, 조회 모델은 조회 성능이 좋은 메모리기반 NOSQL을 사용할 수 있다.

<img src="https://s2.loli.net/2023/02/01/TVdgBJICeziKFta.png" alt="image-20230201120337854" style="zoom:50%;" />

 두 데이터 저장소 간 데이터 동기화는 이벤트를 활용해 처리할 수 있다. 명령 모델에서 상태를 변경하면 이에 해당하는 이벤트가 발생하고, 그 이벤트를 조회 모델에 전달해서 변경 내역을 반영하면 된다.

 그러나, 서로 다른 저장소를 사용할 경우 데이터 동기화 시점에 따라 구현 방식이 달라질 수 있다. 명령 모델에서 데이터가 바뀌자마자 변경 내역을 바로 조회 모델에 반영해야 한다면 동기 이벤트와 글로벌 트랜잭션을 사용해서 실시간으로 동기화할 수 있다.



**CQRS의 장단점**

**장점**

- 명령 모델을 구현할 때 도메인 자체에 집중할 수 있다는 점이다. 복잡한 도메인은 주로 상태 변경 로직이 복잡한데 명령 모델과 조회 모델을 구분하면 조회 성능을 위한 코드가 명령 모델에 없으므로 도메인 로직을 구현하는 데 집중할 수 있다. 당연히 명령 모델에 조회관련 코드가 사라지므로 복잡도가 낮아진다.
- 조회 성능을 향상시키는 데 유리하다. 조회 단위로 캐시 기술을 적용할 수 있고, 조회에 특화된 쿼리를 마음대로 사용할 수 있다. 캐시뿐만 아니라 조회 전용 저장소를 사용하면 조회 처리량을 대폭 늘릴 수도 있다. 조회 전용 모델을 사용하기 때문에 조회 성능을 높이기 위한 코드가 명령 모델에 영향을 주지 않는다.

**단점**

- 구현의 복잡도다. 구현해야할 코드가 많아진다는 점이다. 구현 기술이 필요하게 된다는 것
