# 도메인 모델과 바운디드 컨텍스트



## 1. 바운디드 컨텍스트와 도메인 모델간의 관계에 대해서

 처음 도메인 모델을 만들 때 빠지기 쉬운 함정이 도메인을 완벽하게 표현하려는 단일 모델을 만드는 시도하면 오히려 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.



*상품이라는 모델만 살펴보자.*

카탈로그에서 **상품**.

재고 관리에서 **상품**.

주문에서 **상품**.

배송에서 **상품**

이름만 같지 실제로 의미하는 것은 모두 다르다.

*카탈로그*가 상품 이미지, 상품명, 상품 가격, 옵션 목록, 상세 설명과 같은 상품 정보 위주라면

*재고 관리*에서는 실존하는 개별 객체를 추적하기 위한 목적으로 상품을 사용한다.



논리적으로는 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용한다.

<img src="https://s2.loli.net/2023/01/19/2dPlI4vuYHkxc3D.png" alt="image-20230119144853990" style="zoom:50%;" />



이렇게 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 **한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다.**

- 용어에 따라 올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야 함. 각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야 한다.
- 모델은 특정한 컨텍스트(문맥) 하에서 완전한 의미를 갖는다. 같은 제품이라도 카탈로그 컨텍스트와 재고 컨텍스트에서 의미가 서로 다르다. 이렇게 *구분되는 경계를 갖는 컨텍스트를 DDD*에서는 **바운디드 컨텍스트**라고 부른다.

- 바운디드 컨텍스트 = 경계를 갖는 컨텍스트



## 2. 바운디드 컨텍스트(Bounded Context)

 바운디드 컨텍스트안에서는 하나의 용어가 독립적인 의미를 갖는다. 이 말은 즉슨 용어를 기준으로 구분된다는 의미이다.

 하위 도메인과 바운디드 컨테스트가 일대일 관계를 가지면 좋지만 현실은 그렇지 않을 때가 많다. 하나의 바운디드 컨테스트에 여러 도메인이 존재할 수 있다.

 어떤 상황에서 그럴까?

<img src="https://s2.loli.net/2023/01/19/FEmenPqGDrWYQd8.png" alt="image-20230119150934159" style="zoom:50%;" />

 



*바운디드 컨텍스트을 구성하면서 주의해야 될 점은 하위 도메인의 모델이 섞이지 않도록 하는 것!*

 한 프로젝트에 각 하위 도메인의 모델이 위치하면 아무래도 전체 하위 도메인을 위한 단일 모델을 만들고 싶은 유혹에 빠지기 쉬운데, 그렇게 되면 결과적으로 도메인 모델이 개별 하위 도메인을 제대로 반영하지 못해서 하위 도메인별로 기능을 확장하기 어렵게 되고 이는 서비스 경쟁력을 떨어뜨리는 원인이 됨.

한 개의 바운디드 컨텍스트가 여러 하위 도메인을 포함하더라도 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 하며, 이렇게 함으로써 하위 도메인을 위한 모델이 서로 뒤섞이지 않으면서 각각의 바운디드 컨텍스트에 의미있는 하위 도메인을 가질 수 있다.



## 3. 바운디드 컨텍스트 구현

바운디드 컨텍스트가 도메인 모델만 포함하는 것은 아니다.

>  바운디드 컨텍스트는 도메인 기능을 사용자에게 제공하는 데 필요한 표현 영역, 응용 서비스, 인프라스트럭쳐 영역을 모두 포함한다. 그 이유는 도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야 하므로 테이블도 바운디드 컨텍스트에 포함된다.

  솔직히 납득하기 어려운 듯, 마치 DB와 도메인 모델을 하나로 보는 듯한 느낌이라 동의하지 못함.

<img src="https://s2.loli.net/2023/01/19/8LsE4mItiVReyKj.png" alt="image-20230119152455614" style="zoom:50%;" />



**모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.** 복잡하지 않는 도메인이라면 CRUD 방식으로 구현해도 문제되지 않는다. 이말 은 어느 한 곳에 매몰될 필요가 없음을 의미한다.

<img src="https://s2.loli.net/2023/01/19/ac8ntbHpiFZBAOY.png" alt="image-20230119152905058" style="zoom:50%;" />



## 4. 바운디드 컨텍스트 간 통합

 EX -  기존 카탈로그 시스템을 개발하던 팀과 별도로 추천 시스템을 담당하는 팀이 새로 생겨서 이 팀에서 주도적으로 추천 시스템을 만들기도 했다면? 이렇게 되면 카탈로그 하위 도메인에는 기존 카탈로그를 위한 바운디드 컨텍스트와 추천 기능을 위한 바운디드 컨텍스트가 생긴다.

![image-20230119153449365](https://s2.loli.net/2023/01/19/IfEkwmPclTSdb5L.png)

 

 두 팀이 관련된 바운디드 컨텍스트를 개발하면 자연스럽게 두 바운디드 컨텍스트 간 통합이 발생한다. 카탈로그와 추천 바운디드 컨텍스트 간 통합이 필요한 기능은 

- 사용자가 제품 상세 페이지를 볼 때, 보고 있는 상품과 유사한 상품 목록을 하단에 보여준다.



 카탈로그 시스템은 추천 시스템으로부터 추천 데이터를 받아오지만, 카탈로그 시스템에서는 추천의 도메인 모델을 사용하기보다는 카탈로그 도메인 모델을 사용해서 추천 상품을 표현해야 한다. 즉 다음과 같이 **카탈로그의 모델을 기반으로 하는 도메인 서비스를** 이용해서 상품 추천 기능을 표현해야 한다.

```java
public interface ProductRecommendationSerivce {
	List<Product> getRecommendationOf(ProductId id);
}
```

  도메인 서비스를 구현한 클래스는 인프라스트럭처 영역에 위치한다.

해당 클래스는 외부 시스템과의 연동을 처리하고 외부 시스템의 모델과 현재 도메인 모델 간의 변환을 책임진다.

<img src="https://s2.loli.net/2023/01/19/FK59sVJh8HazrZ4.png" alt="image-20230119153936136" style="zoom:50%;" />



REST API를 호출하는 것은 두 바운디드 컨텍스트를 직접 통합하는 방법(**두 하위 도메인 간의 메세지 전달**)이다. 또는 큐를 사용하는 방법도 간접적인 통합 방식이다.

<img src="https://s2.loli.net/2023/01/19/g32Urw8vdzu7lWS.png" alt="image-20230119154544234" style="zoom:50%;" />



 메세지 큐에 담는 방식은 Pub-Sub 모델로도 할 수 있으며, API와 Queue 을 사용하는 방식에 따라 차이가 있다.

<img src="https://s2.loli.net/2023/01/19/GSP6VZDvH7znxOs.png" alt="image-20230119155208889" style="zoom:50%;" />



비동기이냐? 동기냐? 에 따라 어떤 차이가 있는지 이해할 필요가 있다.

*API **VS** MessageQueue*

API - 즉각성을 띄고, 결과를 바로 받기, 롤백을 할 수 있죠.

MessageQueue - FireAndForget. 롤백을 할 수 없습니다.



## 5. 바운디드 컨텍스트 간 관계

  두 바운디드 컨테스트 간 관계 중 가장 흔한 관계는 한쪽에서 API를 제공하고 다른 한쪽에서 그 API를 호출하는 형태. 이렇게 되면 API를 사용하는 바운디드 컨텍스트는 API를 제공하는 바운디드 컨텍스트에 의존하게 된다.

<img src="https://s2.loli.net/2023/01/19/C6HIf5Ee9Ubi1x4.png" alt="image-20230119155444260" style="zoom:50%;" />

 물은 상류에서 하류로 흐르듯, 상류에서 API 을 만들면, 하류인 카탈로그는 상류에 의존하게 된다.



상류 컴포넌트는 일종의 서비스 공급자 역할을 하며 하류 컴포넌트는 그 서비스를 사용하는 고객 역할을 한다. 고객과 공급자 관계에 있는 두 팀은 상호 협력이 필수적이다. 

 상류 컴포넌트는 보통 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의하고 이를 공개한다. 예를 들어 하류 컴포넌트를 의한 REST API 을 정의한 통신 프로토콜 or 프로토콜 버퍼와 같은 것을 이용해 서비스를 제공할 수도 있다.



상류 팀의 고객인 하류 팀이 다수 존재하면 상류팀은 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들고 이를 서비스 형태로 공개해서 서비스의 일관성을 유지할 수 있다. 이런 서비스를 가리켜 **공개 호스트 서비스(OHS)**라 한다.



 공개 호스트 서비스의 대표적인 예시가 바로 **검색**

 블로그, 카페, 게시판과 같은 서비스를 제공하는 포탈은 각 서비스별로 검색 기능을 구현하기보다는 검색을 위한 전용 시스템을 구축하고 검색 시스템과 각 서비스를 통합한다. 이때 검색 시스템은 상류 컴포넌트가 되고, 블로그, 카페, 게시판은 하류 컴포넌트가 된다.

 상류 팀은 각 하류 컴포넌트의 요구사항을 수용하는 단일 API를 만들어 이를 공개하고 각 하류 팀은 공개된 API 를 사용해서 검색 기능을 구현한다.

<img src="https://s2.loli.net/2023/01/19/bSBWADerEjn4LG3.png" alt="image-20230119161132378" style="zoom:50%;" />

 상류 컴포넌트의 서비스는 상류 바운디드 컨텍스트의 도메인 모델을 따른다. 따라서 하류 컴포넌트는 상류 서비스의 모델이 자신의 도메인 모델에 영향을 주지 않도록 보호해 주는 완충지대를 만들어야 한다. 

![image-20230119161321374](https://s2.loli.net/2023/01/19/NH8UDA24mb9GwJi.png)



여기서 RecSystemClient 가 **안티코럽션 계층 역할**을 함으로써, 외부 시스템의 도메인모델이 내 도메인 모델을 침범하지 않도록 막아주는 역할을 한다. 즉, 내 모델이 깨지는 것을 막아주는 안티코럽션 계층이 된다.

 이 계층에서 두 바운디드 컨텍스트 간의 모델 변환을 처리해주기 때문에 다른 바운디드 컨텍스트의 모델에 영향을 받지 않고 내 도메인 모델을 유지할 수 있다.



 반대로, 두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있다. 예를 들어 **운영자를 위한 주문 관리도구를 개발하는 팀**과 **고객을 위한 주문 서비스를 개발하는 팀**이 다르다고 가정하면, 두 팀은 **주문을 표현하는 모델**을 공유함으로써 주문과 관련된 중복 설계를 막을 수 있다. 이렇게 두 팀이 공유하는 모델을 **공유 커널(SHARED KERNAL)** 이라 한다.

 공유 커널의 장점은 중복을 줄여준다는 것. 두 팀이 하나의 모델을 개발해서 공유하기 때문에. 하지만 두 팀이 한 모델을 공유하기 때문에 한 팀에서 임의로 모델을 변경하면 안 되며 두 팀이 밀접한 관계를 유지해야 한다. 두 팀이 밀접한 관계를 형성할 수 없다면 공유 커널을 사용할 때의 장점보다 공유 커널로 인해 개발이 지연되고 정체되는 문제가 더 커지게 된다.



**독립 모델** 두 바운디드 컨텍스트 간의 통합은 수동으로 이뤄지며, 예를 들어 온라인 쇼핑몰 솔루션과 외부의 ERP 서비스를 사용한다고 하자. 온라인 쇼핑몰 솔루션은 외부 ERP 서비스와의 연동을 지원하지 않으므로 온라인 쇼핑몰에서 판매가 발생하면 쇼핑몰 운영자는 쇼핑몰 시스템에서 판매 정보를 보고 ERP 시스템에 입력한다.

![image-20230119162600196](https://s2.loli.net/2023/01/19/RQ2cTfW9rI16dNX.png)

![image-20230119162617291](https://s2.loli.net/2023/01/19/JQDPimztq5FUZpW.png)



## 컨텍스트 맵

 컨텍스트 맵이란, 전체 비지니스를 조망할 수 있는 지도가 필요한데 그것이 바로 컨텍스트 맵이다.

컨텍스트 맵은 아래 그림과 같이 바운디드 컨텍스트 간의 관계를 표시한 것이다.

![image-20230119162734248](https://s2.loli.net/2023/01/19/fVzdqeSjHBkwxNT.png)

OHS 는 오픈 호스트 서비스

ACL 은 안티코럽션 계층



위 컨텍스트 맵을 보고, 하위 도메인이나 조직 구조를 함께 표시하면 도메인을 포함한 전체 관게를 이해하는 데 도움이 된다.

컨텍스트 맵은 시스템의 전체 구조를 보여준다. 이는 하위 도메인과 일치하지 않는 바운디드 컨텍스트를 찾아 도메인에 맞게 바운디드 컨텍스트를 조절하고 사업의 핵심 도메인을 위해 **조직 역량을 어떤 바운디드 컨텍스트에 집중할지 파악하는 데 도움**을 준다.



**컨텍스트 맵을 그리는 규칙은 따로 없다.** 간단한 도형과 선을 이용해서 각 컨텍스트의 관계를 이해할 수 있는 수준으로 그리면 된다. 컨텍스트 맵은 단순하기 때문에 화이트보드나 파워포인트와 같은 도구를 이용해서 쉽게 그릴 수 있다.