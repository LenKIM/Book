# 도메인 모델 시작하기



 *오늘은 도메인에 대한 전체적인 내용을 빠르게 흟어본다. 그 과정에서 내가 이야기할 수 있는 부분은 이야기하고 그렇지 않은 부분은 뒷장에서 함께한다.*



**도메인이란 무엇인가? 왜 도메인을 말하고 있는가?**

도메인이란, 소프트웨어를 통해 **해결하고자 하는 문제 영역**을 의미한다.

각자의 회사에서 자신이 풀고자하는 문제 영역이다.

아래 그림에서는 큰 그림이다. 전략적인 부분이고, 

<img src="https://camo.githubusercontent.com/1a28e3a172d69d0d072331b65af35bf7188409fe0569e1de40345eac8141c43a/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030387678766747677931683866747a71613576766a33307761306f6d6a73782e6a7067" alt="image-20221124074820571" style="zoom:50%;" />

만약 고객이 물건을 구매한다면- 하나의 도메인이 아닌, 주문/결제/배송/혜택 하위 도메인의 기능이 협력한다.



도메인 하나는 여러 하위 도메인으로 나뉘게 된다. 어떤 고정된 하위 도메인이 있는 것은 아니지만, 하위 도메인에 따라 도메인 하나의 성격이 결정된다.

<img src="https://camo.githubusercontent.com/a7fbcaa120661add32dc43d22a5f3ec023e8b4412e1c29b8cfe25b7f099a1401/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303876787667476779316838676466646a757a736a33313173306a73646b322e6a7067" alt="image-20221124190049083" style="zoom:50%;" />



> (궁금증)
>
> 1. 누가/언제 도메인이 결정되는걸까?
>
> 2. 도메인 이름은 어디서 출발하는가?
> 3. 만약 도메인 주도 설계가 아니였다면 어떻게 해결했을지?



**전문가와 개발자 간 지식 공유**

도메인 전문가와의 **대화**를 통해 더 나은 방법을 제시할 수 있다.

<img src="https://camo.githubusercontent.com/7d18c0275abceb7de6c6f8f9ce1d5d77ad528a52bda884bf6cfcd3a1a67d95e1/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386675336a6a7677366a33307530307771307a612e6a7067" alt="image-20221124075201719" style="zoom:50%;" />

우리의 개발문화는 어떠한가? 위 처럼 대화를 통해 해결 할 수 있는 곳인가? 그렇지 못하다면 왜 그런가?

> **물음표**
>
> 비지니스 규칙을 선정하는데, 개발자가 참여하는가?
>
> 참여하지 못한다면, 왜 참여하지 못하는지?
>
> 타 회사 유즈케이스 공유하기
>
> ex) 스프레드시트



**도메인 모델**

누군가 도메인 모델은 무엇이냐 묻는다면, 어떻게 대답할 것인가?

**= 도메인 모델은 특정 도메인을 개념적으로 표현한 것이다.**

예를 들면 아래와 같은 그림을 의미한다.

온라인 쇼핑몰에서 주문을 하려면 상품을 몇개 살지 선택하고 배송지를 입력한다. 선택한 상품 가격을 이용해서 총 지불 금액을 계산하고, 금액 지불을 위한 결제 수단을 선택한다. 주문한 뒤에도 배송 전이면 배송지 주소를 변경하거나 주문을 취소할 수 있다.

<img src="https://camo.githubusercontent.com/b22bc6c15cf4d5b43973053b81390a5287ea4dc99f63595af52484580d48bb9c/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386675386b787066686a333134673074696e306d2e6a7067" alt="image-20221124075654711" style="zoom:50%;" />

주문(Order)은 주문정보(orderNumber)와 지불할 총금액(totalAmounts)가 있다.

배송정보(ShippingInfo)를 변경(changeShipping) 할 수 있음을 도메인 모델을 보고 알 수 있다.



위와 같은 내역은 이해관계자와 함께 도메인 지식을 습득하고, 탐구하는 방법으로도 좋은 시도가 될 수 있다.

도메인에 대해서 탐구할 때, 위와 같은 도메인 모델 하나로 이해관계자와 얼라인을 맞추는 것은 쉽지 않다. 그러므로 여러 UML 차트을 그리면서 문제를 해결해야 한다. 

<img src="https://camo.githubusercontent.com/942f06ced96071426b3a30406de22dec4d953840119d1ca534dc0cea04a8f061/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303876787667476779316838667563306e7a386b6a333135713074617135362e6a7067" alt="image-20221124080013170" style="zoom:50%;" />

그 외에도 유즈케이스, 빈 메모장 등이 있을 수 있다.



> 개념 모델과 구현 모델
>
> 도메인 자체를 이해하기 위한 것은 개념 모델이다. 대표적으로 그림 1.3 이다. 구현 모델은 클래스 다이어그램과 같이 코드에 보다 더 가까운 부분을 의미한다.
>

>  물음표?
>
> 모든 도메인에 대해서 모델링해야 하는가? NO 필요한건 다른데 쓰면됩니다.
>
> 상태 모델링, 객체 모델링 그 외 또 어떤 모델링이 있는지? 시퀀스 다이어그램 / 



**도메인 모델 패턴** VS **트랜잭션 스크립트 패턴**

<img src="https://camo.githubusercontent.com/34a270eb6c54bb7ff7d874a22f37def99ef4ddabbd662c90aceb4d0ea9ab7615/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303876787667476779316838667569687a7863626a333069323075387766662e6a7067" alt="image-20221124080628089" style="zoom:50%;" />

도메인 모델 패턴은 단순하다. 도메인에 대한 내역이 도메인에 머물러야 한다는 것을 의미한다.

위 아키텍쳐에서 중간에 **도메인** 이 가장 뚱뚱하게 표현한 것도 도메인 모델을 풍부하게 표현하려고 그러는건 아닐까?

[도메인 모델 패턴 VS 트랜잭션 패턴](https://www.youtube.com/watch?v=26S4VFUWlJM&ab_channel=WorkerKSUG)

'엔터프라이즈 애플리케이션 아키텍쳐 패턴' 책에도 **도메인 모델 패턴**이라는 용어가 출연한다. 여기서 도메인 모델은 아키텍쳐 상의 **도메인 계층을 객체 지향 기법으로 구현하는 패턴**을 의미한다.

그리고, **도메인을 우리의 핵심 규칙으로 정의한다.**

이것이 의미하는 바가 무엇일까? 주문 도메인의 경우 '출고 전에 배송지를 변경할 수 있다'라는 규칙과 '주문 취소는 배송 전에만 할 수 있다'라는 규칙을 구현한 코드가 도메인 계층에 위치하게 된다.



 그럼 서비스 레이어와 도메인은 무엇이 다른걸까? 코드을 작성하다보면 서비스 레이어에 비지니스 로직에 추가하는 행위를 자주 목격한다. 이 문제을 우리는 어떻게 해결하는가?

[계층형 아키텍처](https://jojoldu.tistory.com/603)



**도메인 모델 도출**

도메인을 모델링한다는 것은 기본이 되는 작업으로, 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다. 이 과정은 요구사항을 탐구하는 것에서 시작된다. 더하여, 탐구된 요구사항이 내가 만들 도메인 모델에 녹아있어야 한다.

책에서 본 예시을 따라가 보자.

*주문 도메인에 대안 예시로 모델링 도출을 함께 보자*

- 최소 한 종류 이상의 상품을 주문해야 한다.

- 한 상품을 한 개 이상 주문할 수 있다.

- 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.

- 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.

- 주문할 때 배송지 정보를 반드시 지정해야 한다.

- 배송지 정보는 받는 사람 이름, 전화번호, 주소로 구성된다.

- 출고를 하면 배송지를 변경할 수 없다.

- 출고 전에 주문을 취소할 수 있다.

- 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.



(점진적으로 도메인 모델이 도출되는 것을 PDF 을 통해서 함께 확인하기)

<img src="https://camo.githubusercontent.com/85a9156925f77164e94470fc9eff0990a70bbdd7ba7eefb43bd90e00a8560bc3/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303876787667476779316838676576786a366a6c6a33313430306c796e32682e6a7067" alt="image-20221124195120020" style="zoom:50%;" />

>  우리의 회사 요구사항은 예시와 같이 나와 있는가? 개인적을 생각으로는 도메인 모델을 구축하는 것은 어떻게 하면 된다고 생각한다. 그것이 어려운 작업은 아닐 수 있다고 생각한다.
>
> 그러나, 핵심은 저 한 줄의 문자을 만들어내는 것에 있다고 생각한다.

이해관계자와 주문에 대한 도메인 이야기를 하면서 위와 같이 한 줄을 문장을 만들어 낼 수 있을까?



**엔티티와 벨류**

<img src="https://camo.githubusercontent.com/87f57fbb20ca871d26ee672d49aa889f33c2a861776d356ade094273807a222e/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386676336c6239726f6a3331306930726971366a2e6a7067" alt="image-20221124082642586" style="zoom:50%;" />

**엔티티**는 식별자를 가지며, Order 라는 도메인 관점에서 살펴보면 Order는 다른 Order와 식별할 수 있는 OrderNumber 을 식별자로 가진다.

<img src="https://camo.githubusercontent.com/3361633f9dc270aa42ac81f3b985294cccaa0c4a7603e396ab4e58028a46a15f/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386676353372626f6a6a3330726730636f3735362e6a7067" alt="image-20221124082810799" style="zoom:50%;" />

식별자의 생성은 여러가지가 있다.

- 특정 규칙에 따라 생성
- UUID나 NanoID 와 같은 고유 식별자 생성기 사용
- 값을 직접 입력
- 일련번호 사용(@Autoincrement)

> https://happy-coding-day.tistory.com/entry/DB-AutoIncrement-%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%99%9C-%EA%B5%B3%EC%9D%B4-IDGenerator-Server-%EC%9D%84-%EB%A7%8C%EB%93%A4%EC%97%88%EC%9D%84%EA%B9%8C

**Value** 은 값 객체라고도 말한다.

값 객체는 불멸하게 작성되어져야 하며, Value 자체가 의미을 가진다. 책에서 Receiver 을 예시로 들었다.

<img src="https://camo.githubusercontent.com/967163e492ac1e5d5cd4e911971a13cdf1b59ce5599d51dad8c77b6c5f3b1c07/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303876787667476779316838667665656d7870386a333075713075306162742e6a7067" alt="image-20221124083706084" style="zoom:50%;" />

Receiver 라는 것 자체가 **'받는 사람'** 이라는 도메인 개념을 표현한다. 그리고 **'받는 사람'** 이란 name 과 phoneNumber 라는 속성을 가지는데, *이것이 개념적으로 완전한 하나를 잘 표현한다.*

<img src="https://camo.githubusercontent.com/30d1b6bafce021e0b94f50e950b03c697c3c266248d9c874289f003fc75028e0/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386676683061676b356a333130343068793075392e6a7067" alt="image-20221124083936217" style="zoom:50%;" />

<img src="https://camo.githubusercontent.com/6fb0e0f464e13ea16291015a07f45ccd6f3f2e6da9410f2ec70344380fd7ad65/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030387678766747677931683866766861743067326a3331366f306f3830776d2e6a7067" alt="image-20221124083954818" style="zoom:50%;" />

 밸류 객체의 데이터를 변경할 때는 기존 데이터를 변경하기보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 방식을 선호한다. 예를 들어 Money 클래스의 add() 메서드를 보면 Money를 새로 생성하고 있다.

<img src="https://camo.githubusercontent.com/055d7059b5f30dadf9c40adb57793402e268ca8d0192841f4a3d619a144aa6c1/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386676696c30736f6f6a33307136306a386162302e6a7067" alt="image-20221124084108222" style="zoom:50%;" />

이렇게 하는 이유는 불변을 표현하기 위해서. 나아가 왜 불변을 지켜야하는가? 라고 묻는다면 사이드이펙트가 없는 안전한 코드을 작성하기 위해서 일 것이다.

책에서 나오는 OrderLine 의 예시를 살펴보자.

```java
Money price = ...;
OrderLine line = new OrderLine(product, price, quantitiy);
// 만약 price.setValue(0) 로 값을 변경할 수 있다면?
--

Money price = ...;
OrderLine line = new OrderLine(product, price, quantitiy);
price.setValue(2000);
```

> 불변객체 링크
>
> https://ko.wikipedia.org/wiki/%EB%B6%88%EB%B3%80%EA%B0%9D%EC%B2%B4

**엔티티 식별자와 밸류 타입**

<img src="https://camo.githubusercontent.com/ddbd8f8e3e4802df3b213bfbbda4e89960b4e07aec2fb06a120ad9a9364f8fda/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030387678766747677931683866767037636562716a3330737530676964676d2e6a7067" alt="image-20221124084729906" style="zoom:50%;" />



위 코드는 엔티티 식별자의 실제 데이터는 프리미티브한 타입으로 구성되는 경우가 많은데. 이것을 밸류 객체 OrderNo 넣어 변경했다. 왜 그랬을까?

[기본 타입에 대한 강박관념(primitive Obsession) 에 대한 이해](https://happy-coding-day.tistory.com/entry/%EA%B8%B0%EB%B3%B8-%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%95%EB%B0%95%EA%B4%80%EB%85%90primitive-Obsession-%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4)

 id 는 단순히 Long 이라는 타입에 국한된 의미를 가지지 않을 수 있다. 단순한 Long 이 아니라 도메인에서 특별한 의미를 지니는 경우가 많기 때문에 Value 타입을 사용하는 것이다.

> 장/단점이 무엇이 있을까?
>
> ID 가 Long > String 변경한다.



**도메인 용어와 유비쿼터스 용어**

 지금까지 도메인 모델에 대해서 빠르게 흟어봤다. 개념 모델과 구현 모델에 대해서도 이야기했으며 엔티티와 값 객체에 대해서도 이야기했다.



 우리가 빠르게 살펴본 내용의 중심에는 도메인이 있고, 이것을 통해 이해관계자와 소통한다. 그러므로, 우리가 만들 코드도 우리가 이해관계자와 소통하던 용어와 비지니스 규칙이 그대로 적용되어져야 한다.

```
public OrderState {
	STEP1, STEP2, STEP3, STEP4, STEP5, STEP6,
}
```

위와 같은 형태라면 어떤 주문 상태인지 이해하기 어렵다. 실제로 코드에도 **STEP2** 라는 용어가 사용될 것이다. 각각의 STEP N 은

 *'결제 대기 중', '상품 준비 중', '출고 완료됨', '배송 중', '배송 완료 됨', '주문 취소됨'* 을 의미한다.

```
public enum OrderState {
	PAYMENT_WAITING, PREPARING, SHIPPED, DELIVERING, DELIVERY_COMPLETED;
}
```

용어에 맞지 않는 단어을 사용하게 되면, 앞서 말한 것과 같이 소통을 하기 어려워진다. 도메인 주도 설계에서는 언어의 중요성을 끊임없이 이야기한다.

*에릭에반스의 도메인 주도 설계 책에 나오는 이 부분을 유비쿼터스 언어라 표현한다.*

 **전문가, 관계자, 개발자가 도메인과 관련된 공통의 언어를 만들고** 이를 대화, 문서, 도메인 모델, 코드, 테스트 등 모든 곳에서 같은 용어를 사용함으로써, 소통과정에서 발생하는 용어의 모호함을 줄일 수 있고, 개발자는 도메인과 코드 사이에서 불필요한 해석 과정을 줄일 수 있다.

 또한, 시간이 지날수록 도메인 용어는 진화할 것이고, 이것은 또다시 이해관계자와 함께 발견될 수 있는 부분이다.