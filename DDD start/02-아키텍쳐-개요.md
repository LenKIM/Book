# 아키텍쳐 개요

- **아키텍쳐**

- **DIP**

- **도메인 영역의 주요 구성요소**

- **인프라스트럭쳐**

- **모듈**

## 네 개의 영역

 '표현', '응용', '도메인', '인프라스트럭쳐'는 아키텍처를 설계할 때 출현하는 전형적인 네 가지 영역.

<img src="https://camo.githubusercontent.com/22f281e92990db7cca5d7a16d75829952540dec1d5f788370fa776ae1f71e717/68747470733a2f2f747661312e73696e61696d672e636e2f6d77313032342f303038767876674767793168386e7977307a656d6b6a333075363063677439682e6a7067" alt="image-20221201084220177" style="zoom:50%;" />

> 웹 애플리케이션을 개발할 때 많이 사용하는 스프링 MVC 프레임워크가 표현 영역을 위한 기술에 해당한다. 웹 애플리케 이션에서 표현 영역의 사용자는 웹 브라우저를 사용하는 사람일 수도 있고, REST API 를 호출 하는 외부 시스템일 수도 있다.

![image-20221201084505118](https://camo.githubusercontent.com/7c62b6c182484307f5fda3ca95601f03341e05585bf5f0841cb5dc26287f6256/68747470733a2f2f747661312e73696e61696d672e636e2f6d77313032342f303038767876674767793168386e7979747a356b346a3331317130656d7766632e6a7067)

도메인 영역은 도메인 모델을 구현한다. 도메인 모델은 도메인의 핵심 로직을 구현하는 것이다.

<img src="https://camo.githubusercontent.com/a6fe3f94f3850ea52c1d5e4da51d214ca5c868aac813e83007bad7dc4242daa4/68747470733a2f2f747661312e73696e61696d672e636e2f6d77313032342f303038767876674767793168386e7a30396c7a62386a33306a713065673734712e6a7067" alt="image-20221201084627374" style="zoom:50%;" />

인프라스트럭처 영역은 구현 기술에 대한 것을 다룬다.

인프라스트럭쳐 영역은 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.

## 계층 구조 아키텍처

 표현 영역과 응용 영역은 도메인 영역을 사용하고, 도메인 영역은 인프라스트럭쳐 영역을 사용하므로 계층구조를 적용하기에 적당해 보인다.

<img src="https://camo.githubusercontent.com/d3bc1c62dca88ae730f3b3ab7896337c3910f7bc54e14732cc71d9a75eb40092/68747470733a2f2f747661312e73696e61696d672e636e2f6d77313032342f303038767876674767793168386e7a3431326a37746a33306677306b777133652e6a7067" alt="image-20221201085004231" style="zoom:50%;" />

 계층 구조를 엄격하게 적용한다면 상위 계층은 바로 아래의 계층에만 의존을 가져야 하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 한다.

<img src="https://camo.githubusercontent.com/8a46ab56b453e0417fd5795d02dfd3905d9cc9a8f67d76f77740512b07aef20e/68747470733a2f2f747661312e73696e61696d672e636e2f6d77313032342f303038767876674767793168386e7a363179326c706a3330736b306b326a73392e6a7067" alt="image-20221201085201587" style="zoom:50%;" />



<img src="https://camo.githubusercontent.com/66c2f6d41ff1d6ef6746840d5b60953cc62604b8edea56853a25a4b8fc3b07ed/68747470733a2f2f747661312e73696e61696d672e636e2f6d77313032342f303038767876674767793168386e7a3836713035346a33307867306c6f3077362e6a7067" alt="image-20221201085403735" style="zoom:50%;" />

위 코드의 문제점은 무엇일까?  2가지 문제가 있다.

1. CalculateDiscountService 자체를 테스트 하기 어렵다.
2. 구현 방식을 변경하기 어렵다는 점이다.



이 두 가지를 어떻게 해결할 수 있을까? 정답은 DIP 에 있다.

## DIP

<img src="https://camo.githubusercontent.com/9b5f002f69866c85a890e6f70e3d5f80e232b4d886f8b9edbbde1fadf3ba0aca/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386e7a646b6c3435326a333132363069387461682e6a7067" alt="image-20221201085913919" style="zoom:50%;" />



CalculateDiscountService 는 고수준 모듈이다. 고수준 모듈은 **의미 있는 단일 기능을 제공하는 모듈**로 CalculateDiscountService는 '가격 할인 계산'이라는 기능을 구현한다.

 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 그런데 고수준 모듈이 저수준 모듈을 사용하면 앞서 계층 구조 아키텍쳐에서 언급했던 두 가지 문제가 발생한다.



<img src="https://camo.githubusercontent.com/636f3e5b18ea7c34d6ea419c1f028e97b2c2f79bb1e746ea72ecf1c96cd4942b/68747470733a2f2f747661312e73696e61696d672e636e2f6d77313032342f303038767876674767793168386e7a6a69617637356a3330756130666d3074722e6a7067" alt="image-20221201090456813" style="zoom:50%;" />

<img src="https://camo.githubusercontent.com/650bf18af100409f7a996945ee96adeb5c5db829e47a7481a83c6d5ab085f125/68747470733a2f2f747661312e73696e61696d672e636e2f6d77313032342f303038767876674767793168386e7a723372647a6a6a333070653063616161772e6a7067" alt="image-20221201091214566" style="zoom:50%;" />

이렇게 할 경우에 위에서 말한 2가지 문제점을 해결할 수 있게 된다.

1. CalculateDiscountService 자체를 테스트 하기 쉬워집니다.
2. 구현 방식을 변경하기 쉬워집니다.



**DIP 주의사항**

 DIP 의 핵심은 고수준 > 저수준 모듈에 의존하지 않도록 하기 위함인데 DIP를 적용한 결과 구조만 보고 아래와 같이 저수준 모듈에서 인터페이스를 추출하는 경우가 있다.

 **저수준과 고수준에 대한 고찰이 필요하다.**

<img src="https://camo.githubusercontent.com/1ac89c2aeadbac114e499172d85ac5c6ce8c2df4393188a6840dd8ba5de8cf20/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386e7a72757978616d6a333132773068736d79312e6a7067" alt="image-20221201091258192" style="zoom:50%;" />

## 도메인 영역의 주요 구성요소

- 엔티티(ENTITY)

고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 가진다. 주문, 회원, 상품과 같이 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다.

- 벨류(VALUE)

 고유의 식별자를 갖지 않는 객체로 주료 개념적으로 하나의 값을 표현할 때 사용된다. 배송지 주소를 표현하기 위한 주소(address)나 구매 금액을 위한 금액(money)와 같은 타입이 밸류 타입이다. 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다.

- 애그리거트(AGGREGATE)

 애그리거트는 연관된 엔티티와 벨류 객체를 개념적으로 하나로 묶은 것이다. 예를 들어 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 '주문' 애그르거트로 묶을 수 있다.

- 리포지터리(REPOSITORY)

도메인 모델의 영속성을 처리한다. 예를 들어 DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공

- 도메인 서비스(DOMAIN SERVICE)

특정 엔티티에 속하지 않은 도메인 로직을 제공한다. '할인 금액 계산'은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다.



**엔티티와 밸류**

<img src="https://camo.githubusercontent.com/324f190c2942bacda3a57cf3ae645006a339954a5be7c42a71e3385582ff7154/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386f3034307435316c6a33313330306f363430772e6a7067" alt="image-20221201092440168" style="zoom:50%;" />

**애그리거트**

 도메인이 커질수록 개발할 도메인 모델도 커지면서 많은 엔티티와 밸류가 출현한다. 엔티티와 밸류 개수가 많아질수록 모델은 점점 더 복잡해진다.

<img src="https://camo.githubusercontent.com/7477bc0e96d2673ea6824a976b7220fd8a5bf462d9942d10476894fc7339bdf8/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386f30356c3564326b6a33313036306a71676d712e6a7067" alt="image-20221201092608895" style="zoom:50%;" />

 도메인 모델이 복잡해지면 개발자가 전체 구조가 아닌 한 개 엔티티와 밸류에만 집중하는 상황이 발생한다. 이때 상위 수준에서 모델을 관리하지 않고 개별 요소에만 초점을 맞추다 보면, 큰 수준에서 모델을 이해하지 못해 큰 틀에서 모델을 관리할 수 없는 상황에 빠질 수 있다.

> 지도를 볼 때 매우 상세하게 나온 대축척 지도를 보면 큰 수준에서 어디에 위치하고 있는지 이 해하기 어려우므로 큰 수준에서 보여주는 소축척 지도를 함께 봐야 현재 위치를 보다 정확하게 이해할 수 있다. 이와 비슷하게 도메인 모델도 개별 객체뿐만 아니라 상위 수준에서 모델을 볼 수 있어야 전체 모델의 관계와 개별 모델을 이해하는 데 도움이 된다. 도메인 모델에서 전체 구 조를 이해하는 데 도움이 되는 것이 바로 애그리거트 AGGREGATE 이다.

 **애그리거트는 관련 객체를 하나로 묶은 군집.**

주문이라는 도메인 개념은 '주문', '배송지 정보', '주문자', '주문 목록', '총 결제 금액'의 하위 모델로 구성된다. 이 하위 개념을 표현한 모델이다.

<img src="https://camo.githubusercontent.com/5ff88e6f2415f903ecf29c7743b9a44862d1f2f8cc9360d4d2f2dce5a541c9a6/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386f306538377676746a3330766d3069386467782e6a7067" alt="image-20221201093428622" style="zoom:50%;" />

 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있게 된다. 개별 객체 간의 관계가 아닌 애그리거트 간의 관계로 도메인 모델을 이해하고 구현하게 되면, 이를 통해 큰 틀에서 도메인 모델을 관리할 수 있다.

3장에서 학습 예정

**리포지터리**

*리포지터리는 어그리거트 단위로 도메인 객체를 저장하고 조화하는 기능을 정의한다.*

![image-20221201094350424](https://camo.githubusercontent.com/2e6f1592073668fc433e9e347c727c95af05ee4090905727587de367be70e484/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386f306e797771316e6a333131303071327767322e6a7067)

응용서비스는 의존 주입과 같은 방식을 사용해서 실제 리포지터리 구현 객체에 접근한다.

응용 서비스와 리포지터리는 밀접한 연관이 있다. 그 이유는 다음과 같다.

- 응용 서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지터리를 사용한다.
- 응용 서비스는 트랜재션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술의 영향을 받는다.

## 요청 처리 흐름

<img src="https://camo.githubusercontent.com/2ea96c1b14057c98b957cb0ba3e48bcb6a7c96ed98a75bc59a8209e48fc1f8f0/68747470733a2f2f747661312e73696e61696d672e636e2f6d77313032342f303038767876674767793168386f307539393335676a33313230306d6971346a2e6a7067" alt="image-20221201094952126" style="zoom:50%;" />



## 인프라스트럭쳐 개요

인프라스트럭쳐는 표현 영역, 응용 영역, 도메인 영역을 지원한다.

>  DIP 에서 언급한 것처럼 도메인 영역과 응용 영역 에서 인프라스트럭처의 기능을 직접 사용하는 것보다 이 두 영역에 정의한 인터페이스를 인프 라스트럭처 영역에서 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게 만들어준다.

## 모듈 구성

아키텍쳐의 각 영역은 별도 패키지에 위치한다. 패키지 구성 규칙에 정답이 존재하는 것은 아니지만, 영역별로 모듈이 위치할 패키지를 구성하거나, 하위 도메인 별 모듈을 구성할 수 있다.

<img src="https://camo.githubusercontent.com/094894e8f32b41c0434de2a59213ae767265c04cdb6976941bd3f786d0dad1e7/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386f3132673076317a6a33307373306e3264676f2e6a7067" alt="image-20221201095745127" style="zoom:50%;" />

<img src="https://camo.githubusercontent.com/a923e4eeb7d862e096d0ea0a24e459d62f28c1b2cefc76ea704f651177e70751/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386f31327335316c376a333078693071616163332e6a7067" alt="image-20221201095804262" style="zoom:50%;" />

 만약 도메인 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성하는데, 카탈로그 하위 도메인이 상품 애그리거트와 카테고리 애그리거트로 구성될 경우 도메인을 두 개의 하위 패키지로 구성할 수 있다.

<img src="https://camo.githubusercontent.com/add9eaee1aae95a1ba863bbaa8707ed0f4d033e67c1bd72f37bd11c3ec7c6fc6/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038767876674767793168386f3133726b756a796a33307677306f676d79662e6a7067" alt="image-20221201095901799" style="zoom:50%;" />

 애그리거트, 모델, 리포지터리는 같은 패키지에 위치시킨다. 예를 들어 주문과 관련된 Order, OrderLine, Orderer, OrderRepository 등은 com.myshop.order.domain 패키지에 위치시킨다.

> 한 패키지에 너무 많은 타입이 몰려서 코드를 찾을 때 불편한 정도만 아니면 된다. 개인적으로는 한 패키지에 가능하면 10 ~ 15 개 미만으로 타입 개수를 유지하려고 노력한다. 이 개수가 넘어가면 패키지를 분리하는 시도를 해본다.
