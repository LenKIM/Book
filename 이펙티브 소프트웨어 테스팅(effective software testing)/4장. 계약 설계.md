# 계약 설계

> 사전 / 사후 / 불변식 설계 방법
> 계약과 유효성 검사의 차이점


메소드에서 발생하는 제약 사항을 어떻게 모델링 할 수 있을까?

예를 들어) 루틴 수행 도중 어떤 시점에 다다르면 (특정 세금을 계산하는) TaxCalculator 클래스가 호출된다고 가정하자. 선택할 수 있는 선택지는 3가지다.

1. 클래스가 유효하지 않은 입력으로 다른 클래스를 절대로 호출하지 못하도록 함. 
2. 프로그램을 방어적으로 작성하는 방법. 만약 유효하지 않은 입력이면 시스템을 중단하고 사용자에게 알려줌
3. 개발 중인 각 클래스에 대해 명확한 계약을 정의하는 것.


## 1. 사전 / 사후 조건

사전조건? 메서드가 제대로 동작하도록 하는 것

사후 조건? 메서드가 산출물로 보장되는 조건



```java
class TaxCalculator {
  public double calculateTax(double value) {
    if (value < 0) {
      throw new RuntimeException("value cannot be negative.")
    }
    
    double taxValue = 0;
    
    // 여기에 복잡한 비즈니스 규칙 작성
    // 최종 계산 결과가 taxValue 에 담김
    if (value < 0) {
      throw new RuntimeException("Calculated tax value cannot be negative.")
    }
    return taxValue;
  }
}
```

 사전/사후 조건은 서로 다른 내용을 보장. 



**'메서드를 구현할 때 어떻게 사후 조건을 위반하는 값을 가질 수 있을까?'**

구현이 매우 복잡하게 진행되는 경우 버그가 스며든다.  그러므로 **문서에 사전/사후 조건을 명확히 기술하는 일은 중요하다**



```java
/**
* 세금 계산한다
* 이는 .. 여기에 설명 추가
** @param value 세금 계산을 위한 기본값. 값은 양수여야 한다.
* @return 계산한 세금. 세금은 항상 양수여야 한다.            
**/
```



### 1.2 강한 조건과 약한 조건

조건의 강도를 어느 정도로 해야 할까? 사실 정답이 없다. 개발하는 시스템의 종류에 따라 다르고, 모델링하고 있는 클래스의 소비자에게서 기대하는 바가 무엇인지에 따라 다르기 때문이다. 

**위반사항이 일어날 경우 수행해야 하는 사항을 클래스나 메서드가 다룰 수 있는지를 반영하는 일**



## 2. 불변식

 메서드가 실행되기 전에 사전 조건이 유지. 실행 후에 사후 조건이 유지되어야 한다는 것 확인

메서드의 사전, 사후 **모두의** 경우에서 유지되어야 하는 조건을 **불변식**

```java
class Basket {
  void add(Product product, int qtyToAdd) {
    // 메서드 구현사항
    assert invariant(): "Invariant does not hold";
  }
  
  void remove(Product product) {
    // 메서드 구현사항
    assert invariant(): "Invariant does not hold";
  }
  
  private boolean invariant() {
    return totalValue.compareTo(BigDecimal.ZERO) >= 0;
  }
}
```



## 3. 계약 변경과 리스코프 치환법칙

만약 클래스나 메서드의 계약을 바꾸면 어떤 일이 일어날까?

<img src="https://raw.githubusercontent.com/LenKIM/images/master/2024-01-09/image-20240109135158248.png" alt="image-20240109135158248" style="zoom:50%;" />

 TaxCalculator 입장에서는 누가 calculateTax 를 사용하는지 알 수 없다. 강한 조건에서 약한 조건으로 변경하면 문제가 생기지 않는다는 것이다. 변경된 클래스는 클라이언트와 맺은 계약을 깨뜨리지 않는다.

### 3.1 상속과 계약

 상속을 사용할 때 일어나는 일을 논의

<img src="https://raw.githubusercontent.com/LenKIM/images/master/2024-01-09/image-20240109135214105.png" alt="image-20240109135214105" style="zoom:50%;" />

여기서 리스코프 치환 원칙을 이야기할 수 있다.

만약 상속받는 TaxCalculatorNN 가 자신들만의 사전/사후 조건을 가진다면, 부모클래스의 사전/사후 조건을 존중할 거라 가정하지만 각각이 서로다른 조건을 가진다면 `시스템에 기대하는 동작을 깨뜨리지 않고 자식 클래스를 부모 클래스로 치환할 수 있는 개념을 리스코프 치환 법칙(LSP)` 가 깨지게 된다.



## 4. 계약에 의한 설계가 테스트와 어떤 관련이 있는가?

사전/사후/불변식을 정의하면 개발자는 어떤 도움을 받을 수 있을까?

1. 단언문을 통해 제품 코드에서 버그를 일찍 발견할 수 있다.
2. 사전/사후/불변식은 개발자에게 테스트 대상을 제공
3. 명시적인 계약은 소비자의 삶을 편안하게 해준다.



## 5. 현업에서의 계약에 의한 설계

실용적인 팀?

### 5.1 강한 사전 조건 vs 약한 사전 조건

약한 사전 조건은 입력값으로 어떤 것이든 받을 수 있다. 클라이언트가 사용하기 편하다. 하지만 이는 메서드에 유효하지 않은 입력을 다루도록 추가 부담을 준다.

강한 조건은. 양수만 받아들이고 널 값은 받지 않는다. 추가 부담은 이제 클라이언트에게 있다. 

명확한 방법은 없고, 전체 맥락을 고려해서 결정을 내려야 한다. 

### 5.2 입력 유효성 검사인가? 계약인가? 아니면 둘 다인가?

**유효성 검사**와 **계약** 간의 차이점을 이해하자.

유효성 검사는 사용자로부터 들어올 수 있는 불량 데이터나 유효하지 않은 데이터가 시스템에 침투하지 않도록 한다. 예를 들어 수량 필드에 문자가 들어갈 경우, 숫자값이여야 하는 것은 유효성 검사이다. 반면에 계약은 클래스 간의 의사소통이 문제없이 일어나도록 하는 것이다. 

<img src="https://raw.githubusercontent.com/LenKIM/images/master/2024-01-09/image-20240109141509570.png" alt="image-20240109141509570" style="zoom:50%;" />

문제는 어떻게 유효성과 계약 간의 반복을 피할 수 있는 하는 것.

이건 개발자에 따라 다르다.

> 아리 반 뒤르센이 계약에 의한 설계와 유효성 검사의 차이에 대해 스택 오버플로우에 답변을 남기.
>
> https://stackoverflow.com/questions/5049163/when-should-i-use-apache-commons-validate-istrue-and-when-should-i-just-use-th/5452329#5452329



### 5.3 단언과 예외: 둘 중 하나를 사용해야 하는 경우

### 5.4 예외 vs 부드러운 반환값

### 5.5 계약에 의한 설계를 사용하지 않는 경우

언제 계약에 의한 설계를 사용하지 말아야할까? 객체 지향 시스템을 개발하는 일은 객체가 제대로 소통하고 협업할 수 있도록 보장.

### 5.6 사전 조건, 사후 조건, 불변식에 대해 테스트를 작성해야 할까?
