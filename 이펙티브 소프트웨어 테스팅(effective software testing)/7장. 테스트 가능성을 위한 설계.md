# 테스트 가능성을 위한 설계



모든 소프트웨어 시스템을 테스트할 수 있지만, 어떤 시스템에서는 테스트하기 힘들다.

소프트웨어 시스템은 때때로 테스트를 할 수 있도록 설계되어 있지 않다.

**테스트 가능성** 이라는 말은 테스트 대상 시스템이나 클래스, 메서드에 대해 자동 테스트를 얼마나 쉽게 작성할 수 있는지를 말한다.

> 테스트 가능성을 위한 설계는 체계적인 테스트를 수행하기 위한 핵심사항이다. 코드가 테스트하기 어려우면 테스트를 하지 않으려고 할 것 이다. 테스트 가능성을 위한 설계는 언제 진행해야 할까? 테스트 가능성을 생각해야 하는 적당한 때는 언제일가? **항상 고려해야 한다.**

## 1. 도메인 코드에서 인프라 코드 분리

도메인 코드에서 인프라 코드 분리하기.

```java
package com.likelen.openapi;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

class InvoiceFilter {

    private List<Invoice> all() {
        try {
            Connection connection = DriverManager.getConnection("db", "root", "");
            PreparedStatement ps = connection.prepareStatement("select * from invoice");
            ResultSet rs = ps.executeQuery();

            List<Invoice> allInvoices = new ArrayList<>();
            while (rs.next()) {
                allInvoices.add(new Invoice(rs.getString("name"), rs.getInt("value")));
            }
            ps.close();
            connection.close();
            return allInvoices;
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }

    }

    public List<Invoice> lowValueInvoices() {
        List<Invoice> issuedInvoices = all();
        return issuedInvoices.stream().filter(invoice -> invoice.value < 100).collect(Collectors.toList());
    }

    private class Invoice {

        private final String name;
        private final int value;

        public Invoice(String name, int value) {

            this.name = name;
            this.value = value;
        }
    }
}
```

문제점은

1. 도메인 코드와 인프라 코드가 뒤섞여 있다. lowValueInvoices호출 시 DB 접속을 피할 수 없다. public 메서드를 수행하면서 어떻게 private 메서드를 스텁으로 만들 수 있을까? DB를 다루는 부분은 스텁으로 만들 수 없다.
2. 책임이 클수록 더 복잡해지고 버그가 발생할 가능성이 증가한다. 덜 응집된 클래스는 코드양이 많다. 코드양이 많다는 것은 버그가 발생할 확률이 크다는 뜻. 



이 책에서는 핵사고날 아키텍쳐를 언급하는데, 이 부분에 대해서 논쟁이 있다. 인터페이스를 무조건 만들어야 하는가?

**'모든 포트에 대해 인터페이스를 만들어야 하나요?' 옭고 그른 것은 없고, 모든 것은 상황에 따라 다르며, 실용성이 관건이라는 것을 납득시키고자 한다. 소프트웨어 시스템의 모든 것에 대해 인터페이스를 생성할 필요는 없다. 필자는 구현체가 두 개 이상이 되는 포트에 대해서는 인터페이스를 만든다. 또한 추상적 행위를 표현하는 인터페이스를 만들지 않을 때는, 구체적인 구현에서 구현 세부사항이 유출되지 않도록 한다. 언제나 문맥에 따라 판단하는 실용주의가 최고의 방법이다.**

## 2. 의존성 주입과 제어 가능성

클래스 수준에서 필자는 클래스를 완전히 **제어**할 수 있고(즉 테스트 대상 클래스의 행위를 쉽게 제어할 수 있고), **관찰**할 수 있도록(테스트 대상 클래스에서 무슨 일이 일어나는지 알 수 있고 출력 결과를 검사할 수 있도록)해야 한다는 것.

제어 가능성은 일반적으로 테스트 스위트(모의 객체, 페이크, 스텝)을 활용한다.

의존성 주입의 경우, 생성자를 통해서 주입하는 것을 설명한다.

핵사고날 아키텍쳐의 포트는 의존성 역전 원칙을 도입한 것인데, 다음과 같은 공식화를 가진다.

- (비지니스 클래스 같은) 고수준 모듈은 저수준 모듈에 의존해서는 안 된다. 이 둘 모두는(인터페이스 같은)추상화에 의존해야 한다.
- 추상화는 세부사항에 의존하면 안 된다. 세부사항(구체적인 사항)은 추상황에 의존해야 한다.

![image-20240127122838067](https://raw.githubusercontent.com/LenKIM/images/master/2024-01-27/image-20240127122838067.png)

우리의 코드는 언제나 가능한 한 추상황에 의존해야 하고 세부사항에 거의 의존하지 않도록 해야 한다. 이 패턴의 이점은 추상화가 저수준의 세부사항보다 덜 취약하고 변경하기 쉽다는 점. 그러나, 모든 것을 인터페이스로 만드는 것은 폼이 많이 든다.

## 3. 클래스 및 메서드를 관찰 가능하게 하기

클래스 수준에서 관찰 가능성은 기능이 기대했던 대로 동작하는지를 얼마나 쉽게 단언할 수 있는가에 관한 것.

1. 예제1 - 단언을 보조하는 메서드 도입
   ```java
   public class ShoppingCart {
     private boolean readyForDelivery = false;
     // 장바구니에 대한 정ㅂ
     
     public void markAsReadyForDelivery(Calendar estimatedDayOfDelivery) {
       this.readyForDelivery = true;
       // ...
     }
     public boolean isReadyForDelivery(){
       return readyForDelivery
     }
   }
   ```

   여기서 isReadyForDelivery 메서드는 테스트 코드 작성시 단언을 보조해주는 역할을 한다.

2. 예제2 - void 메서드의 행위를 관찰하기
   ```java
   public class InstallmentGenerator {
     private InstallmentRepository repo;
     
     public void generateInstallments(ShoppingCart cart, int numberOfInstallments) {
       ...
     }
   }
   ```

   generateInstallments 메서드를 어떻게 테스트할 수 있을까? 모키토를 잘 알고 있다면 모의 객체에 전달된 모든 인스턴스를 얻는 방법(argumentCaptor)을 사용하는 것이다. '테스트 도중에 전달된 모든 인스턴스를 돌려줄래?'

   ```java
   public class InstallmentGeneratorTest {
   	@Mock private InstallmentRepository repository;
     
     @Test
     void checkInstallments() {
       InstallmentGenerator generator = new InstallmentGenerator(repository);
       ShoppingCart cart = new ShoppingCart(100.0);
       generator.generateInstallments(cart,10);
       
       ArgumentCaptor<Installment> captor = ArgumentCaptor.forClass(Installment.class);
       
       verify(repository, times(10)).persist(captor.capture());
       List<Installment> allInstallments = captor.getAllValues();
     }
   }
   ```

   또는 리스트를 반환하게 해서 테스트 코드를 변경할 수도 있다.

    핵심은 실용주의이다. 테스트 가능성을 개선해주는 작은 설계 변경은 괜찮다는 점만 기억하자. 가끔은 변경사항이 코드 설계를 망치지 않을지 판단하기 어려울 수 있다. 시도해보고 마음에 안들면 폐기하자.

## 4. 의존성 전달 방법: 클래스생성자와 메서드 매개변수

## 5. 현업에서의 테스트 가능성 설계