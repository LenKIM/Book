# Index
 
1장. 이 책의 개요  
- [ ] 다이어그램의 유형  
- [ ] 클래스 다이어그램  
- [ ] 객체 다이어그램  
- [ ] 시퀀스 다이어그램  
- [ ] 협력 다이어그램  
- [ ] 상태 다이어그램  
- [ ] 결론  
  
2장. 다이어그램으로 작업하기  
- [ ] 왜 모델을 만들어야 하는가?  
- [ ] 왜 소프트웨어 모델을 만드는가?  
- [ ] 반드시 코딩을 시작하기에 앞서 포괄적인 설계를 해야 하는가  
- [ ] UML을 효과적으로 사용하기  
- [ ] 다른 사람들과 의사소통하기  
- [ ] 로드맵  
- [ ] 백엔드(back-end) 문서  
- [ ] 무엇을 보관하고 무엇을 버려야 하는가  
- [ ] 반복을 통해 다듬기  
- [ ] 행위를 제일 먼저  
- [ ] 구조를 점검하기  
- [ ] 코드를 마음속으로 그려보기  
- [ ] 다이어그램의 진화  
- [ ] 미니멀리즘  
- [ ] 언제 다이어그램을 그려야 하며, 어떻게 그려야 하는가  
- [ ] 언제 다이어그램을 그려야 하며 언제 멈춰야 하는가  
- [ ] CASE 도구  
- [ ] 하지만 문서화는 어떻게 합니까  
- [ ] 그러면 Javadoc은?  
- [ ] 결론  
  
3장. 클래스 다이어그램  
- [ ] 기본 개념  
- [ ] 클래스  
- [ ] 연관  
- [ ] 상속  
- [ ] 예제 클래스 다이어그램  
- [ ] 세부사항  
- [ ] 클래스 스테레오타입  
- [ ] 추상 클래스  
- [ ] 프로퍼티  
- [ ] 집합  
- [ ] 합성  
- [ ] 다수성  
- [ ] 연관 스테레오타입  
- [ ] 내부 클래스  
- [ ] 익명 내부 클래스  
- [ ] 연관 클래스  
- [ ] 연관 한정사  
- [ ] 결론  
  
4장. 시퀀스 다이어그램  
- [ ] 기본 개념  
- [ ] 객체, 생명선, 메시지 등  
- [ ] 생성과 소멸  
- [ ] 단순한 반복  
- [ ] 사례와 시나리오  
- [ ] 고급 개념  
- [ ] 반복과 조건  
- [ ] 시간이 걸리는 메시지들  
- [ ] 비동기 메시지  
- [ ] 다중 스레드  
- [ ] 활동적인 객체  
- [ ] 인터페이스에 메시지 보내기  
- [ ] 결론  
  
5장. 유스케이스  
- [ ] 유스케이스 적기  
- [ ] 유스케이스란 무엇인가  
- [ ] 기본 흐름  
- [ ] 대체 흐름  
- [ ] 나머지는?  
- [ ] 유스케이스 다이어그램  
- [ ] 시스템 경계 다이어그램  
- [ ] 유스케이스 관계  
- [ ] 결론  
  
6장. OOD(객체 지향 개발)의 원칙  
- [ ] 설계의 품질  
- [ ] 나쁜 설계의 냄새  
- [ ] 의존 관계 관리하기  
- [ ] 단 하나의 책임 원칙(The Single Responsibility Principle)  
- [ ] 개방-폐쇄 원칙(The Open-Closed Principle)  
- [ ] 리스코프 교체 원칙(Liskov Substitution Principle)  
- [ ] 의존 관계 역전 원칙(Dependency Inversion Principle)  
- [ ] 인터페이스 격리 원칙(Interface Segregation Principle)  
- [ ] 결론  
  
7장. 실천방법 : dX  
- [ ] 반복적인 개발(Iterative Development)  
- [ ] 최초의 탐사 작업  
- [ ] 각 기능의 추정치 잡기  
- [ ] 스파이크  
- [ ] 계획 짜기  
- [ ] 릴리스 계획하기  
- [ ] 반복 주기를 계획하기  
- [ ] 중간 지점  
- [ ] 결과를 속도에 반영하기  
- [ ] 반복 주기를 관리 단계로 조직하기  
- [ ] 반복 주기에서는 어떤 일이 일어나는가  
- [ ] 짝을 이뤄 개발하기  
- [ ] 인수 테스트  
- [ ] 단위 테스트  
- [ ] 리팩터링  
- [ ] 개방된 작업 공간  
- [ ] 끊임없는 통합 작업  
- [ ] 결론  
  
8장. 패키지  
- [ ] 자바 패키지  
- [ ] UML 패키지  
- [ ] 의존 관계  
- [ ] 바이너리 컴포넌트 - .jar 파일  
- [ ] 패키지 설계의 원칙들  
- [ ] 패키지 릴리스／재사용 등가 원칙(Release／Reuse Equivalency Principle)  
- [ ] 공통 폐쇄 원칙(Common Closure Principle)  
- [ ] 공통 재사용 법칙(Common Reuse Principle)  
- [ ] 의존 관계 비순환 원칙(Acyclic Dependencies Principle)  
- [ ] 안정된 의존 관계 원칙(Stable Dependencies Principle)  
- [ ] 안정된 추상화 원칙(Stable Abstractions Principle)  
- [ ] 결론  
  
9장. 객체 다이어그램  
- [ ] 어떤 순간의 스냅샷  
- [ ] 활동적인 객체  
- [ ] 결론  
  
10장. 상태 다이어그램  
- [ ] 기본 개념  
- [ ] 특수 이벤트  
- [ ] 상위 상태  
- [ ] 최초 의사-상태와 최종 의사-상태  
- [ ] FSM 다이어그램을 사용하기  
- [ ] SMC  
- [ ] ICE : 사례 연구  
- [ ] 결론  
  
11장. 휴리스틱과 커피  
- [ ] 마크 IV 특수 커피메이커  
- [ ] 도전  
- [ ] 자주 제시되긴 하지만, 엉망인 커피메이커 해결 방안  
- [ ] 사라진 메서드  
- [ ] 허깨비 클래스  
- [ ] 상상뿐인 추상화  
- [ ] 하나님 클래스  
- [ ] 커피메이커 해결 방안  
- [ ] 선을 넘어간 연결  
- [ ] 커피메이커 사용자 인터페이스  
- [ ] 유스케이스 1 : 사용자가 끓임(Brew) 버튼을 누른다  
- [ ] 유스케이스 2 : ContainmentVessel이 준비되어 있지 않다  
- [ ] 유스케이스 3 : 커피가 다 끓었다  
- [ ] 유스케이스 4 : 커피를 모두 마셨다  
- [ ] 추상 모델을 실제로 구현하기  
- [ ] 유스케이스 1 : 사용자가 끓임 버튼을 누른다  
- [ ] isReady() 함수들을 구현하기  
- [ ] start() 함수들을 구현하기  
- [ ] M4UserInterface.checkButton은 어떻게 호출되는가  
- [ ] 커피메이커를 마무리짓기  
- [ ] 이 설계의 장점  
- [ ] 어떻게 이런 설계를 떠올릴 수 있었을까  
- [ ] 객체지향의 과잉(OOverkill)  
  
12장. SMC 원격 서비스 : 사례 연구  
- [ ] 독자에게 보내는 경고  
- [ ] 단위 테스트  
- [ ] SMCRemote 시스템  
- [ ] SMCRemoteClient  
- [ ] SMCRemoteClient 명령줄  
- [ ] SMCRemote 통신 프로토콜  
- [ ] SMCRemoteClient(SMC 원격 클라이언트)  
- [ ] 메시지 로거  
- [ ] 원격 세션  
- [ ] RemoteSessionBase(원격 세션 베이스)  
- [ ] RemoteRegistrar(원격 등록자)  
- [ ] RemoteCompiler(원격 컴파일러)  
- [ ] FileCarrier(파일 운반자)  
- [ ] SMCRemoteClient에 대한 결론  
- [ ] SMCRemoteServer  
- [ ] SocketService(소켓 서비스)  
- [ ] SMCRemoteService(SMC 원격 서비스)  
- [ ] SMCRemoteServer  
- [ ] ServerSession(서버 세션)  
- [ ] THREE-LEVEL FSM  
- [ ] UserRepository(사용자 저장소)  
- [ ] OReillyEmailSender(오라일리 전자우편 전송자)  
- [ ] PasswordGenerator(비밀번호 생성기)  
- [ ] 결론  
- [ ] SMCRemoteClient를 위한 테스트  
- [ ] SocketService를 위한 테스트  
- [ ] SMCRemoteServer를 위한 테스트  
- [ ] 나머지 테스트  
- [ ] (SMC가 자동 생성한) 서버 컨트롤러(ServerController)  
  
부록 1. 분로(分路) 단위 테스팅 패턴  
역사  
이름의 유래  
  
부록 2. 프로세스(RUP vs. dX)  
권리  
목표  
가치 시스템  
RUP(Rational Unified Process)  
dX : 가장 작은 RUP 공정  
요약  
