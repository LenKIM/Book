# 도메인 객체의 생명주기

- 모든 객체에는 생명주기가 있다.

- 한 객체는 생성되어 다양한 상태를 거친 후 결국 저장되거나 삭제되면서 소멸.

- 그러나 대부분 단순한 일시적인(transient) 객체이다.

- 이런 객체는 복잡하게 만들 필요가 없다.

  ![image-20200403152828165](https://tva1.sinaimg.cn/large/00831rSTgy1gdgkb5d2lyj31400u0hdy.jpg)



도메인 객체의 **관리**와 관련된 문제는 두 가지 범주로 나뉜다.

1. 생명주기 동안의 무결성 유지
2. 생명주기 관리의 복잡성으로 모델이 난해해지는 것을 방지.



DDD는 이런 문제를 해결 하기 위해 3가지 패턴

- AGGREGATE(집합체)
  - 소유권과 경계를 명확히 정의함으로써 모델을 엄격하게 만들어 객체 간의 연관관계가 혼란스럽게 얽히지 않게 함
- FACTOR(팩토리)
  - 생명 주기의 초기 단계로 초점을 바꿔 복잡한 객체와 AGGREGATE를 생성하고 재구성함으로써 그것들의 내부 구조를 캡슐화한다.
- REPOSITORY(리파지터리)
  - 생명주기의 중간과 마지막을 다루며, 거대한 관련 인프라스트럭처를 캡슐화하면서 영속 객체를 찾아 조회하는 수단을 제공.



`AGGREGATE`를 모델링하고 설계에` FACTORY와 REPOSITORY`를 추가하면 모델 객체의 생명주기 동안 그것들을 체계적이고 의미 있는 단위로 조작.



`AGGREGATE` 는 생명주기의 전 단계에서 불변식이 유지돼야 할 범위를 표시해 준다. 그리고 `FACTORY`와 `REPOSITORY` 는 `AGGREGATE` 를 대상으로 연산을 수행하며 특정 생명주기로 옮겨가는데 따르는 복잡성을 캡슐화.





## AGGREGATE(집합체)

**우리가 데이터 변경의 단위(TransAction 이 될 수 있음.)로 다루는 연관 객체의 묶음을 말함**

 모델 내에서 복잡한 연관관계를 맺는 객체를 대상으로 변경의 일관성을 보장하기란 쉽지 않다. **그 까닭은 단지 개별 객체만이 아닌 서로 밀접한 관계에 있는 객체 집합에도 불변식이 적용돼야 하기 때문이다.** 그렇다고 변경의 일관성을 보장하고자 신중 잠금 기법을 쓴다면 다수의 사용자가 서로 부적절하게 간섭해서 시스템이 사용할 수 없는 상태가 될 것.



-  우리는 모델 내의 참조에 대한 캡슐화를 추상화할 필요가 있음.



AGGREGATE는 루트(root)와 경계(boundary) 가 존재.

- **경계**는 AGGREGATE에 무엇이 포함되고 포함되지 않는지를 정의
- 루트는 단 하나, AGGREGATE에 포함된 특정 ENTITY
- 경계 안의 객체는 서로 참조할 수 있지만, 경계 바깥의 객체는 해당 AGGREGATE의 구성요소 가운데 **루트**만 참조.



**개념적인 AGGREGATE**를 구현하기 위해서는 다음과 같은 규칙이 필요하다.

- 루트 ENTITY는 전역 식별성을 지니며 궁극적으로 불변식을 검사할 책임이 있다.
- 각 루트 ENTITY는 전역 식별성을 지닌다. 경계 안의 ENTITY는 지역 식별성을 지니며, 이러한 지역 식별성은 해당 AGGREGATE 안에서만 유일
- AGGREGATE 의 경계 밖에서는 루트 ENTITY를 제외한 AGGREGATE 내부의 구성요소를 참조할 수 없다.
- 데이터베이스 질의를 이용하면 AGGREGATE의 루트만 직접적으로 획득할 수 있다. 다른 객체는 모두 AGGREGATE를 탐색해서 발견.
- AGGREGATE 안의 객체는 다른 AGGREGATE의 루트만 참조.
- 삭제 연산은 AGGREGATE의 객체 안에 모든 요소를 한 번에 제거해야 한다.
- AGGREGATE 경계 안의 어떤 객체를 변경하더라도 전체 AGGREGATE의 불변식은 모두 지켜져야 한다.



### **AGGREGATE**  는 생명주기의 전 단계에서 불변식이 유지돼야 할 범위를 표시ㅣ.





## FACTORY(팩토리)

 어떤 객체나 전제 AGGREGATE 를 생성하는 일이 복잡해지거나 내부 구조를 너무 많이 드러내는 경우 **FACTORY**가 캡슐화 제공.



 어떤 객체를 생성하는 것이 그 자체로도 주요한 연산이 될 수 있지만 복잡한 조립 연산은 생성된 객체의 책임으로 어울리지 않는다. **이런 책임을 클라이언트에 두면 이해하기 힘든 볼품없는 설계가 만들어질 수 있다. 클라이언트에서 직접 필요로 하는 객체를 생성하면 클라이언트 설계가 지저분해지고 조립되는 객체나 AGGREGATE의 캡슐화를 위반하며, 클라이언트와 생성된 객체의 구현이 지나치게 결합된다.**



 *자신의 책임이 다른 객체를 생성하는 것인 프로그램 요소를 FACTORY라 한다.*

![image-20200403160912901](https://tva1.sinaimg.cn/large/00831rSTgy1gdglhopx9yj32ml0u0b2c.jpg)



 복잡한 객체와 `AGGREGATE`의 인스턴스를 생성하는 책임을 별도의 객체로 옮겨라. 이 객체 자체는 도메인 모델에서 아무런 책임도 맡지 않을 수도 있지만 여전히 도메인 설계의 일부를 구성한다. 모든 복잡한 객체 조립 과정을 캡슐화하는 동시에 클라이언트가 인스턴스되는 객체의 구상 클래스를 참조할 필요가 없는 인터페이스를 제공하라. 

**전체 AGGREGATE를 하나의 단위로 생성해서 그것의 불변식이 이행되게 하라.**



FACTORY를 잘 설계하기 위한 두 가지 기본 요건

1. 각 생성 방법은 원자적(atomic)이어야 하며, 생성된 객체나 AGGREGAT의 불변식을 모두 지켜야 한다. FACTORY는 일관성 있는 상태에서만 객체를 만들어 낼 수 있어야 한다. ENTITY의 경우 이것은 전체 AGGREGATE를 생성하는 것을 의미하며, 이때 모든 불변식을 충족하고 선택적인 요소도 추가 될 것. 불변적인 VALUE OBJECT의 경우에는 모든 속성이 올바른 최종 상태로 초기화된다는 것을 의미. 인터페이스를 통해 올바르게 생성할 수 없는 객체를 요청할 수 있다면 예외가 발생하거나 또는 다른 어떤 메커니즘이 작동해서 더는 적절하지 않은 반환값이 사용될 수 없도록 보장.
2. FACTORY는 생성된 클래스보다는 생성하고자 하는 타입으로 추상화돼야 한다.















