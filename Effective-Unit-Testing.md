### 왜 이 책을 읽어야 하는가?

- *효과적인* 테스트 코드를 작성해야 하기 때문에.

- 클린 코드와 좋은 설계를 이끄는 단위 테스트를 작성하기 위해서


여기서 효과적인 테스트 코드란 무엇인지 이해하기 어렵다.

그러므로 이 책이 필요한게 아닐까?



아래 내용부터는  책 내용의 특정 부분을 갈무리함으로써 내용을 정리하고자 한다.




## CHAPTER 2 좋은 테스트란?

- 테스트 코드의 가독성과 유지보수성
- 프로젝트 안에서, 그리고 소스 파일 안에서 코드는 적절히 구조화되어 있는가?
- 테스트가 무엇을 검사하는가?
- 테스트는 안정적이고 반복 가능한가?
- 테스트가 테스트 더블을 잘 활용하는가?

*코드가 **좋다**는건 보통 개인 취향에 좌우되고 나 또한 그런 개인 중 한 사람일 뿐이다.*



**1 읽기 쉬운 코드가 유지보수도 쉽다**

- 가독성과 결함 밀도는 반비례한다는 연구결과도 있다. 즉, 읽기 어려운 코드일수록 결함 수가 많다.
- 자동화된 테스트는 결함을 효과적으로 막아주지만, 테스트 역시 코드인지라 가독성 문제에서 벗어날 수는 없다. 읽기 어려운 코드는 검증하기 어렵고, 결과적으로 테스트를 조금만 작성하는 사태로까지 이어진다.
- 가독성...가독성... 읽기 좋은 코드라..

**2 구조화가 잘 되어 있다면 이해하기 쉽다** 

- 구조화해두면 좋다는 점뿐 아니라 제대로 구조화하지 않으면 역으로 피해를 본다는 사실도 기억해둘 필요가 있겠다.
- 아래 그림과 같이 아무 구조나 다 구조를 이해하는 데 도움이 되는 건 아니다. 이해할 수 있는 구조가 필요한 것이다. 즉, 우리 두뇌와 사고 모델이 지지고 볶을 수 있을 정도로 정리된 구조라야 한다.  
  ![image-20200530131900097](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfacvyrnv1j31s90u0e83.jpg)

- 끝나지 않는 통짜 소스와 마주쳤을 때의 가장 확실한 대처법은 작은 조각으로 나누고 코드 뭉텅이를 메서드로 뽑아내는 것. 500줄짜리 통짜 메서드라면 클래스 10개에 메서드 수십 개 정도로 재편할 수 있을거다.
- 하지만, 코드가 도메인 모델이나 머릿속의 개념과 맞지 않아서 나눌 수 있는 명확한 경계를 찾을 수 없다면, 차라리 나누지 않느니만 못할 수도 있다.
- 코드를 읽어보면 특히 코드 동작 방식을 구체적으로 보여주는 테스트 코드를 정독하면 도움이 된다. 다만, 테스트 코드가 제대로 구조화되어 있지 않다면 어디를 봐야하는지 찾아내기 어렵다는 게 함정이다.
- ***결국은 읽기 쉽고, 찾기 쉽고, 이해하기 쉽도록 한 가지 기능에 충실한 테스트가 필요한 것이다.***
  - 현재 작업과 관련된 테스트 클래스를 찾을 수 있다.
  - 그 클래스에서 적절한 테스트 메서드를 고를 수 있다
  - 그 메서드에서 사용하는 객체의 생명주기를 이해할 수 있다.

**3 엉뚱한 걸 검사하는 건 좋지 않다** 

- 이때 가끔은 테스트의 이름을 너무 믿어버리는 실수를 저지르곤 한다. 보통은 테스트의 이름을 보면 그 테스트가 검사하는 내용을 알 수 있는데, 실제로는 이름과 전혀 관련 없는 것을 검사하는 경우가 있다.
- **올바른 것을 검사하는 것 못지않게 올바른 것을 똑바로 검사하는 것도 중요하다. 특히 유지보수 관점에서는 어떻게 구현했느냐가 아니라 의도한 대로 구현했느냐를 검사하는게 중요하다.**

**4 독립적인 테스트는 혼자서도 잘 실행된다** 

- 예컨데 개인적으로는 낯선 코드를 처음 접했을 때 가장 먼저 메서드의 길이부터 살펴본다.
- 테스트 코드라면, 테스트가 **얼마나 독립적인가?** 를 살펴야 한다. 이때 아키텍처의 경계부분이 특히 중요하다. 경계에서 일어나는 일을 관찰하면서 수많은 코드 냄새를 맞을 수 있는데, 다음 요소와 관련이 있다면 각별한 주의가 필요하다.
  - 시간(time)
  - 임의성(Randomness)
  - 동시성(Concurrecy)
  - 인프라(Infrastructure)
  - 기존 데이터(Pre-existing Data)
  - 영속성(Persistency)
  - 네트워킹(Networking)
- 격리와 독립성이 중요한 이유는 그것이 없다면 테스트를 실행하고 관리하기가 휠씬 어렵기 때문이다.
- 같은 테스트 클래스에 속한 테스트 메서드끼리도 순서를 가정하면 안 된다.

***실전에서는 아래와 같이 하는 것이 좋다.***

- 테스트 더블로 서드파티 라이브러리와의 종속성을 제거한다. 손수 만든 어탭터(adapter)로 적절히 감싸주는 것이다. 성가신 부분이 어탭터 안으로 감춰지므로 나머지 애플리케이션 로직과 분리해서 검사할 수 있다.
- 테스트에 필요한 자원을 테스트 코드와 같은 위치에 둔다. 자바 프로젝트라면 같은 패키지에 두면 된다.
- 테스트가 사용할 자원을 직접 만들도록 한다.
- 테스트가 필요한 문맥을 직접 설정하게 한다. 절대 다른 테스트에 의존하지 말자.
- 영속성이 필요한 통합 테스트라면 인메모리 DB를 활용한다. 테스트를 위한 꺠끗한 데이터를 휠씬 간단하게 준비할 수 있다. 덤으로 초기화 시간도 상당히 단축
- **스레드를 사용하는 코드는 동기식과 비동기식을 구분 지어서 골치 아픈 동시성 문제는 소규모의 전문 테스트 그룹에 맡긴다. 평범한 동기식 코드로 작성된 나머지 로직 대부분을 별다른 어려움 없이 검사할 수 있다.**

**5 믿음직한 테스트라야 기댈 수 있다** 

아무것도 검사하지 않는 테스트 => **행복한 테스트**

assert 문은 단 한 줄도 실행하지 않지만, 어쨌든 제품 일부를, 어쩌면 가능한 실행 경로 전부를 신이 나게 휘젓고 간다는  이유에서- 코드 구석구석을 샅샅이 실행한 덕분에 테스트 커버리지는 나무랄 데 없이 높아진다. *다만, 대상 코드가 예외를 던지지 않는 한 테스트가 절대 실패하지 않는다는 게 문제다.*

- 테스트를 믿고 의지하려면 반복할 수 있게 만들어야 한다. 열 번 실행하면 열 번 모두 반드시 같은 결과가 나와야 한다.
- **애플리케이션이 비동기적 요소나 현재 시각에 종속된 코드를 포함한다면 그 부분을 인터페이스로 감싸 격리해야 한다.** 그렇게하면 **테스트 더블** 로 대체 할 수 있어 반복 가능한 테스트를 만ㄷㄹ 수 있다.

**6 모든 일이 그렇듯 테스트에도 도구가 쓰인다** 

> tip)
> *테스트 더블?*
>
> Stub, 가짜 객체, Mock객체 등으로 알고 있는 개념들을 통칭하는 용어.

- 테스트 더블은
  - 원래의 로직을 간소화된 코드로 대체하여 테스트 속도를 개선한다.
  - 만들어내기 어려운 특수한 상황을 시뮬레이션한다.
  - 대상 객체의 내부 상태나 동작 등 테스트가 접근할 수 없던 정보를 얻어낸다.



***JUnit과 같은 테스트 프레임워크, 테스트 더블, 빌드 도구***  중요하다!

**7 요약** 

이들 대부분은 **좋은** 테스트를 만드는 절대적인 진리라기보다는 처한 상황에 따라  달라짐을 알게 되었다.

- **테스트의 필수 미덕 중 하나인 가독성부터 시작해보았다. 아무리 애를 써도 이해할 수 없는 테스트 코드는 그 자체가 곧 큰 골칫거리가 되어 유지보수하기 어렵게 한다. 이렇게 되면 유지 비용이 너무 커져서 차라리 지워버리는 길을 선택하곤 한다.**
- **잘 구조화된 테스트라면 원하는 코드를 빠르게 찾을 수 있고 논리 흐름도 쉽게 이해할 수 있다. 가독성과 직결되는 특성이기도 하다.**
- 엉뚱한 테스트는 개발자를 잘못된 길로 안내하거나 본질을 흐려버려서 테스트가 의도했던 진짜 논리를 감추고 가독성을 떨어뜨리는 결과를 낳는다.
- 가끔 의심스러운 동작을 하는 테스트도 큰 문제 - 이런 불신을 키우는 공통 원인을 찾아내고 반복할 수 있게 만드는 것이 테스트에 얼마나 중요한가를 강조했다.
- 마지막으로, 자동화된 테스트 작성을 보조해주는 테스트 프레임웤, 빌드 도구, 테스트 더블

## CHAPTER 3 테스트 더블
### 1 테스트 더블의 위력 

1.1 테스트 대상 코드를 격리한다 


1.2 테스트 속도를 개선한다 


1.3 예측 불가능한 실행 요소를 제거한다 


1.4 특수한 상황을 시뮬레이션한다 


1.5 감춰진 정보를 얻어낸다 

### 2 테스트 더블의 종류 

2.1 테스트 스텁은 유난히 짧다 


2.2 가짜 객체는 뒤끝 없이 처리한다 


2.3 테스트 스파이는 기밀을 훔친다 


2.4 Mock 객체는 예기치 않은 일을 막아준다 



### 3 테스트 더블 활용 지침 

3.1 용도에 맞는 더블을 선택하라 


3.2 준비하고, 시작하고, 단언하라 


3.3 구현이 아니라 동작을 확인하라 


3.4 자신의 도구를 선택하라


3.5 종속 객체를 주입하라


4 요약 

# PART 2 테스트 냄새

CHAPTER 4 가독성

1 기본 타입 단언 

2 광역 단언 

3 비트 단언 

4 부차적 상세정보 

5 다중 인격 

6 쪼개진 논리 

7 매직 넘버 

8 셋업 설교 

9 과잉보호 테스트 

10 요약 
