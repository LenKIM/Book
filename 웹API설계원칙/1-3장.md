## 원칙

- 원칙이란 무조건 지키기로 합의한 것을 의미함
- 원칙 생성 시는 충분한 근거와 합의가 필요하지만, 정해진 원칙은 바뀌기 전까지는 무조건 지켜야 함
- 원칙은 개인,팀,회사,사회 등 다양한 차원에서 정의되고, 각 차원의 원칙은 충돌하거나 중복됨
- 원칙 간 충돌, 중복해소는 원칙으로 정함
  - 법을 예로 들면 하위법은 상위법을 위배할 수 없다.

1. 미리 절대적인 원칙을 정해 그 안에서 사고하면
2. 일관성을 지키기 쉽고, 문제의 범위도 줄어들어



## 웹 API에 대해

1. Application

최종 사용자가 사용할 소프트웨어. 하지만 API 는 최종사용자가 아니라 서비스 만들 제공하는 측을 대상으로 함.

2. Programming

내 서비스를 만들 때 일부는 남의 서비스를 이용해 만들 수 있음. 이때 남의 서비스로 내 서비스를 만들려면 반드시 남이 그 서비스를 개발에 쓸 수 있는 형태로 열어줘야 함.(보통 개발에 쓸 수 있는 형태가 아니라 사용자가 직접 사용할 형태로만 제공됨, 개발적, 법적으로)

3. Interface

2에서 언급한 남이 서비스를 개발에 쓸 수 있는 열어주는 방법은 다양함. SDK, API 를 비롯하여 메일로 물어보면 답 메일해줄 수도 있음. 이 중 표준적인 요청, 응답형식을 정하여 개발에 사용할 수 있게 공개하는 방법이 API



#### 요점!

남의 서비스가 **우리의 서비스**

여러분의 서비스를 API로 공개하여 자기 서비스를 만들려는 사람들이 가져다 쓰도록 하는 것.

그들은 회사 밖 사람일 수도 있고, 다름 팀의 사람일 수도 있으며, 심지어 말 섞기 싫은 옆자리 사람일 수 있음.

API를 이용하면 인터페이스 문서만 던져주면 되므로 커뮤을 복잡하게 할 필요가 없음.



## API 다양한 측면

1. 사업적 의미

돈 버는데 도움이 되어야 함 = 돈이 안되면 안만듬

단 API는 완제품 가치가 아니라 어떤 사업의 일부분으로도 충분한 가치가 됨. API 사용자가 여러 API를 조합할것이라 오히려 고유한 핵심 가치 제공여부가 중요함.

2. 제품 중심 사고

고객을 무시하면 시장에서 외면 당하므로 기본적으로 기업은 고객중심사고를 함. ex 테슬라.

단점은 고객의 변화에 따라 회사가 끌려다니게 됨. 하지만 API의 고객은 다른 제품을 만드는 기업이므로 고객이면서 공급자임. 핵심 가치만 제대로 제공되면 각 고객들은 자신들의 니즈에 맞쳐 적당히 개조해서 사용하므로 제품을 중심으로 설계하는 사상을 정당화 함.

3. 개발의 도구

API는 대규모 개발에 좋은 설계와 구조를 제공함. 이를 통해 개발 공정을 단축하고 안정성도 높일 수 있어 개발자 만족감 상승과 고객의 수익성도 높일 수 있음. 따라서 개발 상으로도 만족할 만한 구조의 API 가 되어야 함.



#### API 이해관계자

1. **개발자** > 서비스를 만드는 당사자는 개발자
2. **도메인 전문가** > API가 시장에서 가치를 전달하는지를 평가받으려면 그 시장의 도메인 전문가
3. **구동환경** > API가 실행되는 기술과 산업 환경을 고려해야 함. ex) 실시간 항공기 위치를 API 가정하면.



**API도 소프트웨어임. 당연히 소프트웨어 개발 원칙이 적용됨**

**은닉**

특정 내용을 숨기는 것. 은닉은 소프트웨어 설계의 가장 기본 전략. 테슬라는 회생제동 단계를 은닉시켜버림. 스마트폰은 성능만 공개할 뿐 실 부품 정보를 감춤

**캡슐화**

직접적인 표현 또는 수행을 목적지향적인 표현(추상화)으로 바꾼다는 것임. ex) ATM 기기에서 돈을 이체하는 직접적인 수행이 많지만, 이를 추상화하여 이체 계좌, 금액만 설정하는 수행으로 바꿈.



**요약**

웹 API 설계의 5대 원칙

1. 협업 - 다양한 이해관계자들의 충분한 합의
2. 성과 - 가치, 도메인을 중심에 둘 것
3. 기술 - 기술선택은 용도에 맞출 것
4. 문서 - 무엇보다 문서가 우선될 것
5. 약속 - API는 고객과의 약속. 큰 책임을 고려할 것

이후의 장에서는 이러한 원칙을 지지하는 방법론과 배경이 되는 지식을 살펴보게 됨.

#### 프로토콜 우선

1. 모든 개발에서 핵심은 등장한 대상 간의 통신
2. 소프트웨어를 큰 기계라 보면 입력을 받아 출력을 내는 걸로 파악됨
3. 입력, 출력 형식을 미리 정하면 기계를 가정해 일을 진행할 수있음
4. 입력, 출력 형식을 프로토콜이라 함



1. 웹서비스는 데이터 담당의 백엔드와 화면 담당의 프론트엔드로 나눔
2. 프론트엔드는 데이터로 UI 를 구성하므로 백엔드 개발 후 시작.
3. 프로토콜 우선주의에서 문제는 프로토콜을 지키지 않은 쪽으로 귀결됨(보통 목소리(파워)가 큰 넘이 이김)



### 애자일과 스크럼

1. 애자일은 누구도 시장의 가치가 무엇인지 모른다고 가정함
2. 유일한 방법은 제품을 출시하여 시장의 반응을 확인하고
3. 개선 또는 새로운 가치(피봇)로 재출시 해서 다시 확인하는 것
4. 이 과정을 반복하며 제품을 끝없이 출시함.

>  이것을 꼭 지킬 필요가 없긴하다. 애자일을 하지 않아도 성공한 곳이 많지만, 단지 애자일을 통해 성공한 회사가 많아



지키지 어려운 이유로

1. 현실적인 문제
   - 제품 출시는 돈, 노력이 많이 투입되며 사용자 확보 및 유의미한 피드백 수집 어려움
   - 첫 제품에서 안좋은 인상을 주게 되면 개선된 제품이 출시되어도 시장에서 외면당하기 쉽고 투자 받기도 얼워 사업이 영속되기 힘듬
   - 피드백을 받아도 극적인 피봇을 이루기 어렵고 개선 정도만 하기 쉬움. 전통 방식 대비 애자일 방식은 휠씬 큰 비용을 발생시키므로 피봇으로 큰 가치 상승을 반복하지 않으면 감당하지 못함

### 애자일, 스크럼, 제품책임자

1. 애자일 개념을 실현한 많은 방법론이 있음. 그 중 유명한건 스크럼과 칸반
2. 스크럼은 팀 구성을 제품책임자, 스크럼마스터 체계
3. 제품책임자/스크럼마스터.
4. 현실은 제품책임자가 제품 스펙과 개발범위 등에 대한 권한을 갖고 스크럼마스터는 개발에 대해서 권한을 갖기 때문에 상적으로 제품책임자가 중요
5. 2장은 제품책임자 입장에서 할 일 중심으로 기술되어 있음



### API 설계 주의점

1. 캡슐화 부족으로 하위 수준 노출  
   보다 근본적인 사용 목적을 고려할 것(ATM)
2. API 잦은 프로토콜 변경  
   프로토콜 변경은 사용자와의 약속을 깨는 것.
   1. 처음부터 충분한 변화가능성을 염두하고
   2. 느슨하게 정의될 필요가 있음
3. 과대한 기능 욕심  
   애자일 핵심. 시장 검증 전 기능은 상상 속의 가치. 처음부터 많은 기능을 만들 이유가 없음
4. 쓸데 없는 API  
   고립된 소수 또는 무관심한 다수의 API는 시장 가치를 갖기 힘듬. 해당 도메인 관여도가 높은 팀을 구성할 수 없다면 포기해야 함.

#### ADDR과 7단계 프로세스

Align: 관련된 모든 것을 일정하게 나열해 정리하는 것

Define: 정리된 사실, 목표로부터 뭘 만들지 정의하는 것

Design: 정의된 것을 실체화하는 설계(디자인)

Refine: 만들어진 제품을 다듬고 검수하는 것

집을 한 채 지을때는 아키텍쳐라고 하는데, 인테리어는 디자인이라고 한다. 소프트웨어는? 둘을 정의하기 어려워. 

**API에 ADDR을 도입하기 위한 방법론**

1. 디지털 기능 식별: 관련된 것 중 소프트웨어적인 것만 추림
2. API액티비티단계캡쳐: 큰 줄기의 소프트웨어 기능을 정의
3. API경계식별: 2단계의 모든 기능을 그룹으로 나눔
4. API모델링: 실제 개별, API 하나하나를 정의함

5. 하이레벨설계: 4의 설계도를 바탕으로 구체적인 개발방법을 정하는데, 어떤 방식으로 표현?
6. 설계정제: 5번을 개선함. 이해당사자와 유지보수, QA용이성을 고려함.
7. 문서화: 최종 산출물은 문서임. 문서의 표준형식과 사용자를 고려함.



##### ADDR의 현실적인 적용

1. ADDR은 다른 모든 프로세스와 마찬가지로 적용 시 저항이 큼. (쉽지 않음..)
2. 1장에서 제시한 근거로 설득하기 어려움 (API화가 왜 중요한지, API는 기존 개발과 뭐가 다른지 등)
3. ADDR은 광범위한 이해관계자 참여를 요구하므로 전사적 협조가 필요
4. 강한 오너쉽 소유자거나 강력한 설득 논리가 업다면 사내 도입이 힘듬
5. 개인차원 적용, 업무 파악과 관리를 이 프로세스에 맞쳐 수행하는 것만으로도 많은 효과가 생김

### 3장

#### 6하원칙에 따라 문제정의 프레임워크

What - 문제가 무엇인가?: **V**ision**M**ission**S**tratage**A**ction

Why - 왜 이짓을 하는가? 사업타당성 분석등

How - 그럼 그짓을 어떻게 해낼 것인가? : 4P, SWOT

​	When - 어떤 타이밍이 좋은가?

​	Where- 어떤 상황이 좋은가?



**작업스토리** - 개별 디지털 기능을 인식하고 정의하기 위한 도구

1. 소프트웨어 요구사항이기도 함. 은닉과 캡슐화가 그대로 적용
2. 3단계 구조로 기술
   - 1. 목표 및 상황 정의 - API 존재 이유
   - 2. 목표 실현 수단 제공 - API가 실현 수단 자체임
   - 3. 목표가 실현된 상태 - API 사용 고객이 느낄 가치
3. 작업스토리를 이용하면...
   1. 1단계로 API가 엉뚱한 가정을 바탕으로 제작되는 것을 막음
   2. 3단계로 기능구현이 아닌 목표달성을 위해 제작되게 유도함
   3. 1,3단계 하에서 최소 구현으로 최대 효과가 날 수있도록 2단계 구축

#### 작업 스토리 1. 목표 및 상황 정의

1. 각 목표를 발생 상황으로 정리
2. - 도메인에 의해 발생: 도메인 이해도가 관여
   - 사용자 니즈로 발생: 고객에 대한 이해도가 관여

3. 이 둘은 명확히 다르므로 각 그룹으로 나는 것이 좋음
4. 개발 또는 구현의 사정은 반영하지 않음(design, refine 에 반영)

#### 작업 스토리 3. 목표가 실현된 상태

1. 목표가 정의되면 그에 맞춰 실현된 상황도 정의 가능
2. 실현된 상태도 도메인 발생이냐 고객니즈 발생이냐에 따라 상이함

- **도메인에 의한 목표 발생**
  - 도메인 상 해결된 상태. 실현된 상태를 정의하려면 깊은 도메인 이해도 필요 ex) 구매 오류 발생 시 해결은 오류 수정이 아니라 구매취소일 수 있음. 오픈마켓 입점샵이 부정판매 시 해결은 후처리가 아니라 샵 폐쇄 + 플랫폼 보상일 수 있음
- 문제를 사용자가 발생시키는 상황
  - 고객이 만족해야 해결됨. 고객의 논리적 상태 뿐 아니라 감성적인 해결을 포함. 고객 니즈를 만족시키는 포인트를 찾아야 하므로 도메인 전문가 중 고객 접점이 있는 구성원의 의견이 중요함 ex) 품절 시 꼭 구매하려는 고객 니즈의 해결은 ?

#### 작업 스토리 2. 목표실현 수단 제공

1. 실현 수단이 소프트웨어적으로 제공될 수 있는지 검토
2. 100% 소프트웨어적이지 않을 수 있음
   - 배민배달 API는 결국 실제 기사가 움직여야 함
   - 이는 손수 소프트웨어적인 API보다 휠씬 복잡한 상황임
   - 최대한 소프트웨어적인 기능으로 정의
3. 완전히 목표 정의를 바꾸거나 새로운 개념을 창조하여 해결. 파워포인트의 문서, 슬라이드, 노트 등은 발표자료를 재정의하면서 창조한 개념으로 이를 활용한 형태의 프로그램으로 목표를 해결함

### **디지털 기능(으로) 식별**

**작업스토리를 만드는 이유?**

1. API 설계 전문가가 아닌 다양한 이해관계자가 참여가능
2. 디지털 기능 외적인 비지니스 요구사항도 파악가능

**기초작업**

1. 관련된 모든 도메인을 수집
2. 수집된 도메인을 작업스토리로 작성
3. 목표와 관련된 핵심만 추리기(2와 3은 상황에 따라 순서가 다름)

**전문가 영역**

1. 작업스토리 정제
2. 작성이 힘든 도메인을 작업스토리로 변환
3. 작업스토리 중 소프트웨어적으로 해결할 수 있는 것만 추림
4. 추려진 작업스토리들이 가치있는지 평가

**작업 스토리 책의 예제**

p97 5가지 도출

**도메인 발생**

3. 시스템에서 판매 목적 신제품 노출 시 발생

5. 주문으로 배송이 만들어지고 배송의 진행에 따라 발생

도메인적으로 해결해야 한다

**고객 니즈 발생**

1. 평소 구매한 카테고리를 우선으로 보여주기
2. 구매 및 사이트 이용패턴을 학습시켜 흥미 있는 책 추천
3. 절판인 경우 이북이나 중고책을 구매할 수 있게 함