# 스코프

### 1. 컴파일러 이론

전통적인 컴파일러 언어의 처리 과정에서는 보통 3단계를 거침

- 토크나이징/렛싱  
  : 
- 파싱  
  : 파싱의 결과로 AST(추상 구문 트리)를 만든다.
- 코드생성  
  : AST를 컴퓨터에서 실행 코드로 바꾸는 과정. 이 부분은 언어에 따라 또는 목표하는 플랫폼에 따라 크게 달라진다.

자바스크릅트 엔진이 기존 컴파일러와 다른 점은 자바스크립트 컴파일레이션을 미리 수행하지 않아서 최적화할 시간이 많지 않다는 점이다.

어떤 자바스크립트 조각이라도 실행되려면 먼저 컴파일되어야 한다는 것이다. 즉, 자바스크립트 컴파일러는 프로그램 "var a = 2;"를 받아 컴파일하여 바로 실행될 수 있게 한다.



### 스코프 이해하기.

#### 출연진?

- 엔진 - 컴파일레이션의 시작부터 끝까지 전 과정과 자바스크립트 프로그램 실행을 책임진다.
- 컴파일러 - 엔진의 친구로, 파싱과 코드 생성의 모든 잡일을 도맡아 한다.
- 스코프 - 엔진의 또 다른 친구로, 선언된 모든 확인자 검색 목록을 작성하고 유지한다. 또한 엄격한 규칙을 강제하여 현재 실행 코드에서 확인자의 적용 방식을 정한다.

#### 앞과 뒤?



컴파일러가 다음 의사코드로 요약될 수 있는 코드를 생성한다고 생각할 수 있다.

`var a = 2;`

> 변수를 위해 메모리를 할당하고 할당된 메모리를 a라 명명한 후 그 변수에 값 2를 넣는다.

하지만, 이는 그리 정확한 설명이 아니다. 컴파일러는 다음 일을 진행한다.



1. 컴파일러가 var a를 만나면 스코프에 변수 a가 특정한 스코프 컬렉션 안에 있는지 묻는다. 변수 a가 이미 있다면 컴파일러는 선언을 무시하고 지나가고, 그렇지 않으면 컴파일러는 새로운 변수 a를 스코프 컬렉션내에 선언하라고 요청한다.
2. 그 후 컴파일러는  'a = 2' 대입문을 처리하기 위해 나중에 엔진이 실행할 수 있는 코드를 생성한다. 엔진이 실행하는 코드는 먼저 스코프에게 a라 부르는 변수가 현재 스코프 컬렉션 내에서 접근할 수 있는지 확인한다. 가능하다면 엔진은 변수 a를 사용하고, 아니라면 엔진은 다른 곳을 살핀다.



엔진이 마침내 변수를 찾으면 변수에 값2를 넣고, 못 찾는다면 엔진은 손을 들고 에러가 발생했다고 소리칠 것이다. 요약하면, 별개의 두 가지 동작을 취하며 변수 대입문을 처리한다. 첫째, 컴파일러가 변수를 선언한다. 둘째, 엔진이 스코프에서 변수를 찾고 변수가 있다면 값을 대입한다.



### 컴파일러체

2단계에서 컴파일러가 생성한 코드를 실행할 때 엔진은 변수 a가 선언된 적이 있는지 스코프에서 검색한다. 이때 엔진이 어떤 종류의 검색을 하느냐에 따라 검색 결과가 달라진다. 앞의 경우에는 엔진은 변수 a를 찾기 위해 LHS 검색을 수행한다. 다른 종류의 검색은 RHS라 부른다.

각각 왼쪽, 오른쪽 방향

어떤 방향? 바로 대입 연산의 방향을 의미.

좀더 명확히는 RHS는 "Retrieve His/Her source"의 약자로서 "가서 값을 가져오라"

> console.log(a)

의미는 RHS이다. 구문에서 a에 아무것도 대입하지 않았기 때문이다.

`개념적으로는 대입할 대상(LHS)와 대입한 값(RHS)이라고 생각하는 것이 더 낫다.`



### 중첩 스코프