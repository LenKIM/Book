목차  

예제 코드- https://github.com/wikibook/clean-architecture 

▣ 01장: 계층형 아키텍처의 문제는 무엇일까?  
- [X] 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다  
- [X] 지름길을 택하기 쉬워진다  
- [X] 테스트하기 어려워진다  
- [X] 유스케이스를 숨긴다  
- [X] 동시 작업이 어려워진다  
- [X] 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
  
▣ 02장: 의존성 역전하기  
- [X] 단일 책임 원칙  
- [X] 부수효과에 관한 이야기  
- [X] 의존성 역전 원칙  
- [X] 클린 아키텍처  
- [X] 육각형 아키텍처(헥사고날 아키텍처)  
- [X] 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?  



▣ 03장: 코드 구성하기  
- [X] 계층으로 구성하기  
- [X] 기능으로 구성하기  
- [X] 아키텍처적으로 표현력 있는 패키지 구조  
- [X] 의존성 주입의 역할  
- [X] 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?  
  
▣ 04장: 유스케이스 구현하기  
- [X] 도메인 모델 구현하기  
- [X] 유스케이스 둘러보기  
- [X] 입력 유효성 검증  
- [X] 생성자의 힘  
- [X] 유스케이스마다 다른 입력 모델  
- [X] 비즈니스 규칙 검증하기  
- [X] 풍부한 도메인 모델 vs. 빈약한 도메인 모델  
- [X] 유스케이스마다 다른 출력 모델  
- [X] 읽기 전용 유스케이스는 어떨까?  
- [X] 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?  
- [X] 의존성 역전  
  
▣ 05장: 웹 어댑터 구현하기  
- [X] 웹 어댑터의 책임  
- [X] 컨트롤러 나누기  
- [X] 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?  
- [X] 의존성 역전  
  
▣ 06장: 영속성 어댑터 구현하기  
- [X] 영속성 어댑터의 책임  
- [X] 포트 인터페이스 나누기  
- [X] 영속성 어댑터 나누기  
- [X] 스프링 데이터 JPA 예제  
- [X] 데이터베이스 트랜잭션은 어떻게 해야 할까?  
- [X] 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?  
  
▣ 07장: 아키텍처 요소 테스트하기  
- [X] 테스트 피라미드  
- [X] 단위 테스트로 도메인 엔티티 테스트하기  
- [X] 단위 테스트로 유스케이스 테스트하기  
- [X] 통합 테스트로 웹 어댑터 테스트하기  
- [X] 통합 테스트로 영속성 어댑터 테스트하기  
- [X] 시스템 테스트로 주요 경로 테스트하기  
- [X] 얼마만큼의 테스트가 충분할까?  
- [X] 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?  
  
▣ 08장: 경계 간 매핑하기  
- [X] ‘매핑하지 않기’ 전략  
- [X] ‘양방향’ 매핑 전략  
- [X] ‘완전’ 매핑 전략  
- [X] ‘단방향’ 매핑 전략  
- [X] 언제 어떤 매핑 전략을 사용할 것인가?  
- [X] 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?  
- [X] 왜 조립까지 신경 써야 할까?  
  
▣ 09장: 애플리케이션 조립하기  
- [X] 평범한 코드로 조립하기  
- [X] 스프링의 클래스패스 스캐닝으로 조립하기  
- [X] 스프링의 자바 컨피그로 조립하기  
- [X] 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?  
- [X] 경계와 의존성  
  
▣ 10장: 아키텍처 경계 강제하기  
- [X] 접근 제한자  
- [X] 컴파일 후 체크  
- [X] 빌드 아티팩트  
- [X] 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?  
  
▣ 11장: 의식적으로 지름길 사용하기  
- [X] 왜 지름길은 깨진 창문 같을까?  
- [X] 깨끗한 상태로 시작할 책임  
- [X] 유스케이스 간 모델 공유하기  
- [X] 도메인 엔티티를 입출력 모델로 사용하기  
- [X] 인커밍 포트 건너뛰기  
- [X] 애플리케이션 서비스 건너뛰기  
- [X] 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?  
  
▣ 12장: 아키텍처 스타일 결정하기  
- [X] 도메인이 왕이다  
- [X] 경험이 여왕이다  
- [X] 그때그때 다르다  

> p19. 짐작했을지도 모르지만 클린 아키텍처에는 대가가 따른다. 도메인 계층이 영속성이나 UI 같은 외부 계층과 철저하게 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 게층에서 유지보수해야한다.
> 
> 가령 영속성 계층에서 ORM 프레임워크를 사용한다고 가정하면, 일반적으로 ORM 프레임워크는 데이터베이스 구조 및 객체 필드와 데이터베이스 칼럼의 매핑을 서술한 메타데이터를 담고 있는 엔티티 클래스를 필요로 한다.
> 도메인 계층은 영속성 계층을 모르기 때문에 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 함께 사용할 수 없고 두 계층에서 각각 엔티티를 만들어야 한다.
> 즉, 도메인 계층과 영속성 계층이 데이터를 주고받을 때, 두 엔티티를 서로 변환해야 한다는 뜻이다. 이는 도메인 계층과 다른 계층들 사이에서도 마찬가지다.

> p26. AccountService 의 책임을 좁히기 위해 SendMoneyServices 로 클래스명을 바꿨다. 이제 '송금하기' 유스케이스를 구현한 코드는 클래스명만으로도 찾을 수 있게 됐다. 애플리케이션의 기능을 코드를 통해 볼 수 있게 만드는 것을 가리켜 로버트 마틴이
> ' 소리치는 아키텍쳐' 라고 명명한 바있다 왜냐하면 코드가 그 의도를 우리에게 소리치고 있기 때문이다.


> p27. 육각형 아키텍쳐에서 구조적으로 핵심적인 요소는 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉 어탭터이다.

> p28 고수준의 육각형 아키텍쳐를 표현한 그림을 사무실에 걸어놓고, 이야기를 통해 클라이언트를 변경하는 작업을 바로 시작할 수 있다.


> p30 의존성 주입의 역할 > 클린 아키텍쳐의 가장 본질적인 요건은 애플리케이션 계층이 인커밍/아웃고잉 어탭터에 의존성을 갖지 않는 것이다.

![](https://tva1.sinaimg.cn/mw1024/e6c9d24egy1h1ct7fwg31j214j0u0djz.jpg)


> p54. 웹 어탭터는 '주도하는' 혹은 '인커밍' 어탭터다. 외부로부터 요청을 받아 애플리케이션 코어를 호출하고 무슨일을 해야 할지 알려준다. 이때 제어 흐름은 웹 어탭터에 있는 컨트롤러에서 애플리케이션 계층에 있는 서비스로 흐른다.
> 
> 애플리케이션 계층은 웹 어탭터가 통신할 수 있는 특정 포트를 제공한다. 서비스는 이 포트를 구현하고, 웹 어탭터는 이 포트를 호출할 수 있다.


> 웹 어탭터의 책임
> 
> 01.HTTP 요청을 자바 객체로 매핑
> 02.권한 검사
> 03.입력 유효성 검증
> 04.입력을 유스케이스의 입력 모델로 매핑
> 05.유스케이스 호출
> 06.유스케이스 출력을 HTTP로 매핑
> 07.HTTP 응답을 반환

> 영속성 어탭터의 책임
> 
> 01.입력을 받는다.
> 02.입력을 데이터베이스 포맷으로 매핑한다.
> 03.입력을 데이터베이스로 보낸다.
> 04.데이터베이스 출력을 애플리케이션포맷으로 매핑한다.
> 05.출력을 반환한다.

> p65. 영속성 어탭터는 포트 인터페이스를 통해 입력을 받는다. 입력 모델은 인터페이스가 지정한 도메인 엔티티나 특정 데이터베이스 연산 전용 객체가 될 것이다.

> p64. 영속성 어탭터는 '주도하는' 혹은 '아웃고잉'어탭터다. 애플리케이션에 의해 호출될 뿐, 애플리케이션을 호출하지는 않기 때문이다.

> 포트는 사실상 애플리케이션 서비스와 영속성 코드 사이의 간접적인 게층이다. 영속성 문제에 신경 쓰지 않고 도메인 코드를 개발하기 위해, 즉 영속성 계층에 대한 코드 의존성을 없애기 위해 이러한 간접 계층을 추가하고 있다는 사실을 잊지 말자.
> 이렇게 되면 영속성 코드를 리팩토링 하더라도 코어 코드를 변경하는 결과로 이어지지 않을 것이다.


![](https://tva1.sinaimg.cn/large/e6c9d24egy1h1cur6gjgjj20yq0oodj5.jpg)


![](https://tva1.sinaimg.cn/large/e6c9d24egy1h1curgzpnxj20wm0p6tbf.jpg)


책을 읽고 난 뒤에 배운 점과 느낌 점을 정리한다.

레이어드 아키텍쳐의 단점은 무엇인가?(1) - https://happy-coding-day.tistory.com/189

레이어드 아키텍쳐의 단점은 무엇인가?(2) - https://happy-coding-day.tistory.com/223

	
헥사고날 아키텍처(Hexagonal Architecture) 코드로 이해해보기 - https://happy-coding-day.tistory.com/229
