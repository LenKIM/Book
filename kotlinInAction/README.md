
- [ ] __1.1 코틀린 맛보기  
__1.2 코틀린의 주요 특성  
____1.2.1 대상 플랫폼: 서버, 안드로이드 등 자바가 실행되는 모든 곳  
____1.2.2 정적 타입 지정 언어  
____1.2.3 함수형 프로그래밍과 객체지향 프로그래밍  
____1.2.4 무료 오픈소스  
__1.3 코틀린 응용  
____1.3.1 코틀린 서버 프로그래밍  
____1.3.2 코틀린 안드로이드 프로그래밍  
__1.4 코틀린의 철학  
____1.4.1 실용성  
____1.4.2 간결성  
____1.4.3 안전성  
____1.4.4 상호운용성  
__1.5 코틀린 도구 사용  
____1.5.1 코틀린 코드 컴파일  
____1.5.2 인텔리J 아이디어와 안드로이드 스튜디오의 코틀린 플러그인  
____1.5.3 대화형 셸  
____1.5.4 이클립스 플러그인  
____1.5.5 온라인 놀이터  
____1.5.6 자바-코틀린 변환기  
__1.6요약  
  
  
2장. 코틀린 기초  
  
__2.1 기본 요소: 함수와 변수  
____2.1.1 Hello, World!  
____2.1.2 함수  
____2.1.3 변수  
____2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿  
__2.2 클래스와 프로퍼티  
____2.2.1 프로퍼티  
____2.2.2 커스텀 접근자  
____2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지  
__2.3 선택의 표현과 처리: enum과 when  
____2.3.1 enum 클래스 정의  
____2.3.2 when으로 enum 클래스 다루기  
____2.3.3 when과 임의의 객체를 함께 사용  
____2.3.4 인자 없는 when 사용  
____2.3.5 스마트 캐스트: 타입 검사와 타입 캐스트를 조합  
____2.3.6 리팩토링: if를 when으로 변경  
____2.3.7 if와 when의 분기에서 블록 사용  
__2.4 대상을 이터레이션: while과 for 루프  
____2.4.1 while 루프  
____2.4.2 숫자에 대한 이터레이션: 범위와 수열  
____2.4.3 맵에 대한 이터레이션  
____2.4.4 in으로 컬렉션이나 범위의 원소 검사  
__2.5 코틀린의 예외 처리  
____2.5.1 try, catch, finally  
____2.5.2 try를 식으로 사용  
__2.6 요약  
  
  
3장. 함수 정의와 호출  
  
__3.1 코틀린에서 컬렉션 만들기  
__3.2 함수를 호출하기 쉽게 만들기  
____3.2.1 이름 붙인 인자  
____3.2.2 디폴트 파라미터 값  
____3.2.3 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티  
____3.3 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티  
____3.3.1 임포트와 확장 함수  
____3.3.2 자바에서 확장 함수 호출  
____3.3.3 확장 함수로 유틸리티 함수 정의  
____3.3.4 확장 함수는 오버라이드 할 수 없다  
____3.3.5 확장 프로퍼티  
__3.4 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원  
____3.4.1 자바 컬렉션 API 확장  
____3.4.2 가변인자 함수: 인자의 개수가 달라질 수 있는 함수 정의  
____3.4.3 값의 쌍 다루기: 중위 호출과 구조 분해 선언  
__3.5 문자열과 정규식 다루기  
____3.5.1 문자열 나누기  
____3.5.2 정규식과 3중 따옴표로 묶은 문자열  
____3.5.3 여러 줄 3중 따옴표 문자열  
__3.6 코드 다듬기: 로컬 함수와 확장  
__3.7 요약  
  
  
4장. 클래스, 객체, 인터페이스  
  
__4.1 클래스 계층 정의  
____4.1.2 코틀린 인터페이스  
____4.1.2 open, final, abstract 변경자: 기본적으로 final  
____4.1.3 가시성 변경자: 기본적으로 공개  
____4.1.4 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스  
____4.1.5 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한  
__4.2 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언  
____4.2.1 클래스 초기화: 주 생성자와 초기화 블록  
____4.2.2 부 생성자: 상위 클래스를 다른 방식으로 초기화  
____4.2.3 인터페이스에 선언된 프로퍼티 구현  
____4.2.4 게터와 세터에서 뒷받침하는 필드에 접근  
____4.2.5 접근자의 가시성 변경  
__4.3 컴파일러가 생성한 메소드: 데이터 클래스와 클래스 위임  
____4.3.1 모든 클래스가 정의해야 하는 메소드  
____4.3.2 데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성  
____4.3.3 클래스 위임: by 키워드 사용  
__4.4 object 키워드: 클래스 선언과 인스턴스 생성  
____4.4.1 객체 선언: 싱글턴을 쉽게 만들기  
____4.4.2 동반 객체: 팩터리 메소드와 정적 멤버가 들어갈 장소  
____4.4.3 동반 객체를 일반 객체처럼 사용  
____4.4.4 객체 식: 익명 내부 클래스를 다른 방식으로 작성  
__4.5 요약  
  
  
5장. 람다로 프로그래밍  
  
__5.1 람다 식과 멤버 참조  
____5.1.1 람다 소개: 코드 블록을 함수 인자로 넘기기  
____5.1.2 람다와 컬렉션  
____5.1.3 람다 식의 문법  
____5.1.4 현재 영역에 있는 변수에 접근  
____5.1.5 멤버 참조  
__5.2 컬렉션 함수형 API  
____5.2.1 필수적인 함수: filter와 map  
____5.2.2 all, any, count, find: 컬렉션에 술어 적용  
____5.2.3 groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경  
____5.2.4 flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리  
__5.3 지연 계산 lazy 컬렉션 연산  
____5.3.1 시퀀스 연산 실행: 중간 연산과 최종 연산  
____5.3.2 시퀀스 만들기  
__5.4 자바 함수형 인터페이스 활용  
____5.4.1 자바 메소드에 람다를 인자로 전달  
____5.4.2 SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경  
__5.5 수신 객체 지정 람다: with와 apply  
____5.5.1 with함수  
____5.5.2 apply함수  
__5.6 요약  
  
  
6장. 코틀린 타입 시스템  
  
__6.1 널 가능성  
____6.1.1 널이 될 수 있는 타입  
____6.1.2 타입의 의미  
____6.1.3 안전한 호출 연산자: "?."  
____6.1.4 엘비스 연산자 "?:"  
____6.1.5 안전한 캐스트: as?  
____6.1.6 널 아님 단언: !!  
____6.1.7 let함수  
____6.1.8 나중에 초기화할 프로퍼티  
____6.1.9 널이 될 수 있는 타입 확장  
____6.1.10 타입 파라미터의 널 가능성  
____6.1.11 널 가능성과 자바  
__6.2 코틀린의 기본 타입  
____6.2.1 기본 타입: Int, Boolean 등  
____6.2.2 널이 될 수 있는 기본 타입: Int?, Boolean? 등  
____6.2.3 숫자 변환  
____6.2.4 Any, Any?: 최상위 타입  
____6.2.5 Unit 타입: 코틀린의 void  
____6.2.6 Nothing 타입: “이 함수는 결코 정상적으로 끝나지 않는다.”  
__6.3 컬렉션과 배열  
____6.3.1 널 가능성과 컬렉션  
____6.3.2 읽기 전용과 변경 가능한 컬렉션  
____6.3.3 코틀린 컬렉션과 자바  
____6.3.4 컬렉션을 플랫폼 타입으로 다루기  
____6.3.5 객체의 배열과 기본 타입의 배열  
__6.4요약  
  
  
2부. 코틀린답게 사용하기  
  
7장. 연산자 오버로딩과 기타 관례  
  
__7.1 산술 연산자 오버로드  
____7.1.1 이항 산술 연산 오버로딩  
____7.1.2 복합 대입 연산자 오버로딩  
____7.1.3 단항 연산자 오버로딩  
__7.2 비교 연산자 오버로딩  
____7.2.1 동등성 연산자: "equals"  
____7.2.2 순서 연산자: compareTo  
____7.3 컬렉션과 범위에 대해 쓸 수 있는 관례  
____7.3.1 인덱스로 원소에 접근: get과 set  
__7.3.3 in관례  
____7.3.3 rangeTo관례  
____7.3.4 for 루프를 위한 iterator 관례  
__7.4 구조 분해 선언과 component 함수  
____7.4.1 구조 분해 선언과 루프  
__7.5 프로퍼티 접근자 로직 재활용: 위임 프로퍼티  
____7.5.1 위임 프로퍼티 소개  
____7.5.2 위임 프로퍼티 사용: by lazy()를 사용한 프로퍼티 초기화 지연  
____7.5.3 위임 프로퍼티 구현  
____7.5.4 위임 프로퍼티 컴파일 규칙  
____7.5.5 프로퍼티 값을 맵에 저장  
____7.5.6 프레임워크에서 위임 프로퍼티 활용  
__7.6 요약  
  
  
8장. 고차 함수: 파라미터와 반환 값으로 람다 사용  
  
__8.1 고차 함수 정의  
____8.1.1 함수 타입  
____8.1.2 인자로 받은 함수 호출  
____8.1.3 자바에서 코틀린 함수 타입 사용  
____8.1.4 디폴트 값을 지정한 함수 타입 파라미터나 널이 될 수 있는 함수 타입 파라미터  
____8.1.5 함수를 함수에서 반환  
____8.1.6 람다를 활용한 중복 제거  
__8.2 인라인 함수: 람다의 부가 비용 없애기  
____8.2.1 인라이닝이 작동하는 방식  
____8.2.2 인라인 함수의 한계  
____8.2.3 컬렉션 연산 인라이닝  
____8.2.4 함수를 인라인으로 선언해야 하는 경우  
____8.2.5 자원 관리를 위해 인라인된 람다 사용  
__8.3 고차 함수 안에서 흐름 제어  
____8.3.1 람다 안의 return문: 람다를 둘러싼 함수로부터 반환  
____8.3.2 람다로부터 반환: 레이블을 사용한 return  
____8.3.3 무명 함수: 기본적으로 로컬 return  
__8.4 요약  
  
  
9장. 제네릭스  
  
__9.1 제네릭 타입 파라미터  
____9.1.1 제네릭 함수와 프로퍼티  
____9.1.2 제네릭 클래스 선언  
____9.1.3 타입 파라미터 제약  
____9.1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정  
__9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터  
____9.2.1 실행 시점의 제네릭: 타입 검사와 캐스트  
____9.2.2 실체화한 타입 파라미터를 사용한 함수 선언  
____9.2.3 실체화한 타입 파라미터로 클래스 참조 대신  
____9.2.4 실체화한 타입 파라미터의 제약  
__9.3 변성: 제네릭과 하위 타입  
____9.3.1 변성이 있는 이유: 인자를 함수에 넘기기  
____9.3.2 클래스, 타입, 하위 타입  
____9.3.3 공변성: 하위 타입 관계를 유지  
____9.3.4 반공변성: 뒤집힌 하위 타입 관계  
____9.3.5 사용 지점 변성: 타입이 언급되는 지점에서 변성 지정  
____9.3.6 스타 프로젝션: 타입 인자 대신 * 사용  
__9.4 요약  
  
  
10장. 애노테이션과 리플렉션  
  
__10.1 애노테이션 선언과 적용  
____10.1.2 애노테이션 대상  
____10.1.3 애노테이션을 활용한 JSON 직렬화 제어  
____10.1.4 애노테이션 선언  
____10.1.5 메타애노테이션: 애노테이션을 처리하는 방법 제어  
____10.1.6 애노테이션 파라미터로 클래스 사용  
____10.1.7 애노테이션 파라미터로 제네릭 클래스 받기  
__10.2 리플렉션: 실행 시점에 코틀린 객체 내부 관찰  
____10.2.1 코틀린 리플렉션 API: KClass, KCallable, KFunction, KProperty  
____10.2.2 리플렉션을 사용한 객체 직렬화 구현  
____10.2.3 애노테이션을 활용한 직렬화 제어  
____10.2.4 JSON 파싱과 객체 역직렬화  
____10.2.5 최종 역직렬화 단계: callBy(), 리플렉션을 사용해 객체 만들기  
__10.3 요약  
  
  
11장. DSL 만들기  
  
__11.1 API에서 DSL로  
____11.1.1 영역 특화 언어라는 개념  
____11.1.2 내부 DSL  
____11.1.3 DSL의 구조  
____11.1.4 내부 DSL로 HTML 만들기  
__11.2 구조화된 API 구축: DSL에서 수신 객체 지정 DSL 사용  
____11.2.1 수신 객체 지정 람다와 확장 함수 타입  
____11.2.2 수신 객체 지정 람다를 HTML 빌더 안에서 사용  
____11.2.3 코틀린 빌더: 추상화와 재사용을 가능하게 하는 도구  
__11.3 invoke 관례를 사용한 더 유연한 블록 중첩  
____11.3.1 invoke 관례: 함수처럼 호출할 수 있는 객체  
____11.3.2 invoke 관례와 함수형 타입  
____11.3.3 DSL의 invoke 관례: 그레이들에서 의존관계 정의  
__11.4 실전 코틀린 DSL  
____11.4.1 중위 호출 연쇄: 테스트 프레임워크의 should  
____11.4.2 기본 타입에 대한 확장 함수 정의: 날짜 처리  
____11.4.3 멤버 확장 함수: SQL을 위한 내부 DSL  
____11.4.4 안코: 안드로이드 UI를 동적으로 생성하기  
__11.5 요약  
  
  
부록 A. 코틀린 프로젝트 빌드  
  
__A.1 그레이들로 코틀린 코드 빌드  
__A.2 메이븐으로 코틀린 프로젝트 빌드  
__A.3 앤트로 코틀린 코드 빌드  
  
  
부록 B. 코틀린 코드 문서화  
  
__B.1 코틀린 문서화 주석 작성  
__B.2 API 문서 생성  
  
  
부록 C. 코틀린 에코시스템  
  
__C.1 테스팅  
__C.2 의존관계 주입  
__C.3 JSON 직렬화  
__C.4 HTTP 클라이언트  
__C.5 웹 애플리케이션  
__C.6 데이터베이스 접근  
__C.7 유틸리티와 데이터 구조  
__C.8 데스크탑 프로그래밍  
  
  
부록 D. 코틀린 1.1과 1.2, 1.3 소개  
  
__D.1 코틀린 1.1  
__D.2 코틀린 1.2  
__D.3 코틀린 1.3  
  
  
부록 E. 코루틴과 Async/Await  
  
__E.1 코루틴이란?  
__E.2 코틀린의 코루틴 지원: 일반적인 코루틴  
__E.3 suspend 키워드와 코틀린의 일시 중단 함수 컴파일 방법  
__E.4 코루틴 빌더 만들기  
__E.5 결론  
  
  
부록 F. 코틀린/JS  
  
__F.1 코틀린/JS 프로젝트 기본 설정  
__F.2 Hello, World!  
__F.3 코틀린에서 DOM에 접근  
__F.4 js() 함수와 dynamic 타입, external 변환자  
__F.5 자바스크립트에서 코틀린 호출  
__F.6 복잡한 예제: HTML 빌더, jQuery 라이브러리 사용 예제  
__F.7 외부 라이브러리에 대한 코틀린/JS 래퍼  
__F.8 결론  