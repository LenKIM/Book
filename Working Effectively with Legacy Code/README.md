**1부. 코드 변경의 메커니즘**

- [x] 1장. 소프트웨어 변경  
소프트웨어 코드를 변경하는 네 가지 이유  
기능 추가와 버그 수정  
설계 개선  
최적화  
네 가지 이유의 종합  
위험한 변경  

- [x] 2장. 피드백 활용  
단위 테스트란?  
상위 수준의 테스트  
테스트를 통한 코드 보호  
레거시 코드를 변경하는 순서  
변경 지점을 식별한다  
테스트 루틴을 작성할 위치를 찾는다  
의존 관계를 제거한다  
테스트 루틴을 작성한다  
변경 및 리팩토링을 수행한다  
이후의 내용  

- [x] 3장. 감지와 분리  
협업 클래스 위장하기  
가짜 객체  
가짜 객체의 양면성  
가짜 객체의 핵심  
모조 객체  

- [x] 4장. 봉합 모델  
엄청난 양의 테스트  
봉합  
봉합의 종류  
전처리 봉합  
링크 봉합  
객체 봉합  

- [x] 5장. 도구  
리팩토링 자동화 도구  
모조 객체  
단위 테스트 하네스  
JUnit  
CppUnitLite  
NUnit  
기타 xUnit 프레임워크  
일반적인 테스트 하네스  
FIT  
피트니스  
  
**2부. 소프트웨어 변경**  
3월 29일
- [ ] 6장. 고칠 것은 많고 시간은 없고  
발아 메소드  
장점과 단점  
발아 클래스  
장점과 단점  
포장 메소드  
장점과 단점  
포장 클래스  
요약  

- [ ] 7장. 코드 하나 바꾸는 데 왜 이리 오래 걸리지?  
코드 이해하기  
지연 시간  
의존 관계 제거  
빌드 의존 관계  
요약  

- [ ] 8장. 어떻게 기능을 추가할까?  
테스트 주도 개발  
실패 테스트 케이스 작성  
컴파일  
테스트 통과시키기  
중복 제거  
실패 테스트 케이스 작성  
컴파일  
테스트 통과시키기  
중복 제거  
테스트 실패 케이스 작성  
컴파일  
테스트 통과시키기  
중복 제거  
차이에 의한 프로그래밍  
요약  

- [ ] 9장. 뚝딱! 테스트 하네스에 클래스 제대로 넣기  
성가신 매개변수  
숨겨진 의존 관계  
복잡한 생성자  
까다로운 전역 의존 관계  
공포스러운 인클루드 의존 관계  
양파껍질 매개변수  
별명을 갖는 매개변수  

- [ ] 10장. 테스트 하네스에서 이 메소드를 실행할 수 없다  
숨어있는 메소드  
언어의 편리한 기능  
탐지 불가능한 부작용  

- [ ] 11장. 코드를 변경해야 한다  
영향 추론  
전방 추론  
영향 전파  
영향 추론을 위한 도구  
영향 분석을 통한 학습  
영향 스케치의 단순화  

- [ ] 12장. 클래스 의존 관계, 반드시 없애야 할까?  
교차 지점  
간단한 경우  
상위 수준의 교차 지점  
조임 지점을 이용한 설계 판단  
조임 지점의 함정  

- [ ] 13장. 변경해야 하는데, 어떤 테스트를 작성해야 할지 모르겠다  
문서화 테스트  
클래스 문서화  
정해진 목표가 있는 테스트  
문서화 테스트를 작성하기 위한 경험칙  

- [ ] 14장. 나를 미치게 하는 라이브러리 의존 관계  

- [ ] 15장. 애플리케이션에 API 호출이 너무 많다  

- [ ] 16장. 변경이 가능할 만큼 코드를 이해하지 못하는 경우  
노트/스케치  
표시 나열  
책임 분리  
메소드 구조의 이해  
메소드 추출  
변경 영향의 이해  
스크래치 리팩토링  
미사용 코드 삭제  

- [ ] 17장. 내 애플리케이션은 뼈대가 약하다  
시스템의 스토리텔링  
네이키드 CRC  
대화 음미  

- [ ] 18장. 테스트 코드가 방해를 한다  
클래스 명명 규칙  
테스트 코드의 배치  

- [ ] 19장. 내 프로젝트는 객체 지향이 아니다  
간단한 경우  
어려운 경우  
새로운 동작의 추가  
객체 지향의 장점 이용  
모든 것이 객체 지향적이다  

- [ ] 20장. 이 클래스는 너무 비대해서 더 이상 확장하고 싶지 않다  
책임 파악  
그 밖의 기법들  
더 나아가기  
전략  
전술  
클래스 추출을 마친 후  

- [ ] 21장. 반복되는 동일한 수정, 그만할 수는 없을까?  
첫 번째 단계  

- [ ] 22장. ‘괴물 메소드’를 변경해야 하는데 테스트 코드를 작성하지 못하겠다  
괴물 메소드의 다양한 종류  
불릿 메소드  
혼잡 메소드  
리팩토링 자동화 도구를 사용해 괴물 메소드 공략하기  
수동 리팩토링에 도전  
감지 변수 도입  
아는 부분 추출하기  
의존 관계 이삭줍기  
메소드 객체 추출  
전략  
뼈대 메소드  
처리 시퀀스 발견  
우선 현재 클래스 내에서 추출  
작은 조각 추출  
추출을 다시 할 각오  

- [ ] 23장. 기존 동작을 건드리지 않았음을 어떻게 확인할 수 있을까?  
초집중 모드에서 편집하기  
단일 목적 편집  
서명 유지  
컴파일러 의존  
짝 프로그래밍  

- [ ] 24장. 어찌해야 할지 모르겠다. 나아질 것 같지 않아  
3부 의존 관계 제거 기법  
25장 의존 관계 제거 기법  
매개변수 적응  
메소드 객체 추출  
정의 완성  
전역 참조 캡슐화  
정적 메소드 드러내기  
호출 추출과 재정의  
팩토리 메소드 추출과 재정의  
get 메소드 추출과 재정의  
구현체 추출  
더 복잡한 예제  
인터페이스 추출  
인스턴스 위임 도입  
정적 set 메소드 도입  
연결 대체  
생성자 매개변수화  
메소드 매개변수화  
매개변수 원시화  
특징 끌어올리기  
의존 관계 밀어 내리기  
함수를 함수 포인터로 대체  
전역 참조를 get 메소드로 대체  
서브클래스화와 메소드 재정의  
인스턴스 변수 대체  
템플릿 재정의  
텍스트 재정의  
  
부록. 리팩토링  