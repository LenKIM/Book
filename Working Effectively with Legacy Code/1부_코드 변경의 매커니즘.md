### CH1. 소프트웨어 변경

변경하는 네 가지 이유가 있다. 나눠서 생각해보자

1. 새로운 기능의 추가
2. 버그 수정
3. 설계 개선
4. 자원 이용의 최적화



1. 새로운 기능의 추가



### 위험한 변경

위험을 최소화하기 위해서는 다음의 세 가지 질문을 해야 한다.

1. 어떤 변경을 해야 하는가?
2. 변경이 정확하게 이뤄졌는지 어떻게 확인할 수 있는가?
3. 무엇가를 손상시키지 않았는지 어떻게 확인할 수 있는가?



**코드 편집 분량이 줄어들기 때문에 더 안전하다?**

그렇지 않다. 클래스와 메소드를 새로 생성하지 않으면, 기존의 클래스와 메소드는 갈수록 비대해져서 결국 코드를 이해하기 어려운 지경에 이른다.



**변경을 회피하는 것은 또 다른 결과도 초래한다.**

변경을 자주 하지 않으면 개발자의 실력이 녹슬기 쉽다. 거대한 클래스를 분할하는 작업을 일주일에 두세 번 정도 꾸준히 하지 않으면, 나중에는 감당하기 힘든 수준이 된다. 반면에 꾸준히 수행하면 습관이 된다.

무엇을 나누고 무엇을 나누면 안 되는지를 점점 더 잘 판단할 수 있게 된다.

변경 회피의 마지막 문제점은 바로 두려움이다. 많은 팀들이 소프트웨어 변경을 크게 두려워하며 그 두려움이 나날이 커진다.

## CH2. 피드백 활용

 시스템을 변경하는 방법은 크게 두 가지

1. 편집 후 기도하기(Edit and Pray)
2. 보호 후 수정하기(Cover and Modify)



편집 후 기도하기가 보편적이다. '신중함'을 가장 전면에 내세우며, 영향을 미치는 범위가 넓은 변경 작업일 경우에는 더욱 세심한 신중함이 요구된다. 그러나 안전성이 높아진다는 보장은 없다.

반대로 보호 후 수정하기 는 좀 다른 방식으로 코드를 변경한다. 소프트웨어를 변경할 때 '안전망'을 이용하자는 것. 그 중심에는 테스트 루틴이 있고, 테스트 루틴을 통해서 빠르게 피드백을 활용할 수 있다.

이런 방식의 테스트는 '작업 결과의 정확성을 보여주기 위한 테스트'이지만, 다른 목적으로 테스트할 수도 있는데, '변경된 부분을 발견하기 위한 테스트'가 이에 해당한다.

변경 대상 코드의 주변에 배치된 테스트 루틴들은 소프트웨어 바이스(software vise)의 역할을 함으로써, 동작 대부분을 고정시키고 변경하고자 하는 부분만 변경하고 있음을 확인할 수 있다는 뜻이다.



**그럼 왜 회귀테스트를 자주 사용하지 않는걸까?**

애플리케이션 수준의 테스트로서 간주돼왔다. 그러므로 사람들이 하지 않는다.



### 봉합

 테스트를 하기 위해 기존 프로젝트로부터 클래스를 추출하는 작업을 하다 보면, '좋은'설계란 무엇인지에 대한 기존의 생각이 달라진다. 또한 소프트웨어를 기존과 전혀 다른 측변에서 바라보게 될 것이다. 프로그램을 커다란 종이 위에 적힌 문자들의 나열이라고는 더 이상 생각할 수 없게 되기 때문이다.



> **봉합**
>
> 봉합 지점은 코드를 직접 편집하지 않고도 프로그램의 동작을 변경할 수 있는 위치를 말한다.

