---
theme: default
---

- [ ] 2.1 가독성 및 유지보수성 향상
- [ ] __2.1.1 코드 개선
- [ ] __2.1.2 코드가 하는 일을 바꾸지 않고 유지보수하기
- [ ] 2.2 속도, 유연성 및 안정성 확보
- [ ] __2.2.1 상속보다는 컴포지션 사용
- [ ] __2.2.2 수정이 아니라 추가로 코드를 변경
- [ ] 2.3 리팩터링과 일상 업무
- [ ] __2.3.1 학습 방법으로서의 리팩터링
- [ ] 2.4 소프트웨어 분야에서 ‘도메인’ 정의하기  

---

## 1. 가독성 및 유지보수성 향상

리팩토링에 대한 정의를 다시 반복해서 정의해보자.

리팩토링이란? 코드가 하는 일을 변경하지 않고 더 나은 코드를 만드는 것.

그러므로, 

**더 나은 코드를 만드는 것**

**코드가 하는 일을 변경하지 않는다.**

---

이 두 가지 내용을 살펴보자.



더 나은 코드가 되는 것 - 가독성과 유지보수성

**가독성**

의도를 전달하기 위한 코드의 성질. 곧 코드가 의도한 대로 작동한다는 가정이 있으면 코드가 무슨 일을 하는지 파악하기가 매우 쉽다.

여기서 의도를 전달하는 방법으로는

`코드 컨벤션` `주석 달기` `변수` `메서드` `클래스 및 파일 이름 지정` `공백 사용` 



읽기 힘든 코드

```
function checkValue(str: boolean) { >> 바람직하지 않는 메서드먕: 매개변수 타입이 불(booelan)인데, 매개변수명이 str임
	//값 체크 >> 그저 이름만 반복하는 주석
	
	if (str !== false) >> 이중 부정은 읽기 어려움
		return true; // 코드를 반복하는 의미 없는 주석
  else;
  	return str; >> 오해 소지 있는 들여쓰기. 이 시점에서 str은 반드시 false 때문에 그냥 false로 표시하는 것이 명확
}
```



읽기 쉽게 작성된 동일한 코드

```
function isTrue(bool: boolean) {
if(bool) return true;
else return false;
}
```

정리하면

```
function isTrue(bool: boolean) {
	return bool;
}
```



---

**유지보수성**

버그를 고치거나 기능을 추가하기 위해 일부 기능을 변경해야 할 때마다 새 코드를 어디에 놓을지 후보 위치(context)를 조사하는 것

- 현재 코드가 무슨 일을 하는지 파악하고, 새로운 목표를 수용하는 위해 코드를 안전하고 빠르게 쉽게 수정할 수 있는 방법이 무엇인지 찾으려고 시도
- 코드에 대한 조사를 하게 되는데, 만약 오래 걸린다면 그만큼 코드 유지보수성이 나쁘다는 징후
- 어느 시스템에서 한군대서 무엇가를 수정하면 관련 없어 보이는 다른 곳에서 문제가 발생합니다. 그런 시스템을 취약(fragile)



취약의 근원은 일반적으로 전역상태(global state) 

**전역(global)**은 우리가 고려한 범위(scope)를 벗어난 것. 메서드로 생각하면 내부 변수가 전역 변수를 참조하는 것. 

**상태(state)**의 개념은 좀더 추상적인데, 프로그램이 실행되는 동안 변경될 수 있는 모든 것



전역상태의 문제는 내부 변수에 외부의 데이터를 할당하는 경우가 많은데, 이때 전역적인 데이터가 누군가 읽거나 변경할 수 있어 실수로 데이터가 손상될 수 있다. 그래서 코드에서 상태(조건)을 명시적으로 확인하지 않는 속성을 불변속성(invariant) 라 말하고 예를 들면, "이 숫자는 절대 음수일 수 없습니다." 불행히도 불변속성을 유효한 상태로 유지되기란 불가능하다.



---



이 문제를 해결하기 위해서는 변수를 명시적으로 체크해서 불변속성을 제거함으로써 유지보수성을 향상시킬수 있다.

리팩터링은 불변속성을 더욱 쉽게 볼 수 있도록 서로 가깝게 이동시켜 유지보수성을 향상시킨다. 이를 가르켜 "함께 변하는 것은 함께 있어야 한다."의 의미로 **불변속성의 범위제한** 이라 한다.



---

### 1.2 코드가 하는 일을 바꾸지 않고 유지보수하기

리팩토링을 할 때는 블랙박스의 경계를 고려해야 한다. 어느 정도의 코드를 변경할 예정인지? 기본적으로 리팩터링 중인 코드를 **예약**해서 다른 사람이 변경하지 않게 해야 한다. 

리팩터링의 세 가지 핵심은 다음과 같다.

1. 의도를 전달함으로써 가독성 향상
2. 불변속성의 범위제한을 통한 유지보수성 향상
3. 범위 밖의 코드에 영향을 주지 않고 1항과 2항을 수행

---

## 2. 속도 유연성 및 안정성 확보

 좋은 코드베이스에서 작업할 때의 더 생산적이면서 적은 실수를 하고 더 편안합니다.

리팩터링 패턴은 구체적이고 지역적인 것부터 추상적이고 전약적인 것에 이르기까지 여러 수준이 있습니다. 이 책에서 로컬 수준의 리팩터링에 가장 가까운 것은 좋은 메소드명을 짓는 것

---

### 2.1 상속보다는 컴포지션 사용

 범위가 제한하지 않는 불변속성(nonlocal invariants) 유지보수하기 어렵다는 것에 익숙하다.  범위가 제한하지 않는 불변속성(nonlocal invariants)의 일반적인 방법인 상속(inheritance)를 권장하지 않습니다.

 '상속보다는 컴포지션(composition)을 사용하라'

우리가 설명하는 대부분 리팩터링 패턴과 규칙은 구체적으로 **객체 컴포지션**을 돕기 위함. 즉 객체가 내부에 다른 객체의 참조를 가지는 것



```typescript
// 상속을 사용
interface Bird {
  hasBeak(): boolean;
  canFly(): boolean;
}

class CommonBird implements Bird {
  hasBeak() { return true; }
  canFly() { return true; }
}

class Penguin extends CommonBiard { << 상속 사용
  canFly() { return false; }
}

// 컴포지션 사용
interface Bird {
  hasBeak(): boolean;
  canFly(): boolean;
}

class CommonBird implements Bird {
  hasBeak() { return true; }
  canFly() { return true; }
}

class Penguin implements Bird {
  private bird = new CommonBird(); // 컴포지션
  hasBeak() { return bird.hasBeak(); }
  canFly() { return true; }
}
```



왜 이렇게 하라는 걸까?

만약 canSwim이라는 새로운 메소드를 Bird에 추가하는 것을 상상하면 두 경우 모두 Bird 에 메소드 추가된다.

이때 상속을 사용하는 경우에는

```
class CommonBird implements Bird {
	...
  canSwim() {return false;}
}
```

그러나 컴포지션을 사용하는 경우에는 Penguin에서 canSwim을 구현하지 않기 때문에 컴파일 오류가 발생.

따라서 이를 인지하고 수동으로 추가하고 펭귄이 수영할 수 있는지 hasBeak 처럼 구현해야 한다.

반면, 상속 에서는 Penguin이 수영할 수 없다고 가정하면 canSwim을 재정의(override)해야 한다는 것을 작업자가 기억해야 한다. 사람의 기억력은 종종 의존관계에 취약. 특히 다른 기능에 집중하고 있을 때 간과하기 쉽다.



**유연성**

컴포지션을 중심으로 만들어진 시스템을 사용하면 다른 방식보다 더 깔끔하고 코드를 결합하고 재상용할 수 있다.

---

### 2.2 수정이 아니라 추가로 코드를 변경

컴포지션의 가장 큰 장점은 **추가(addition)**로 변경이 가능하다는 것.

이것은 기존 기능에 영향을 주지않고 기능을 추가하거나 변경할 수 있음을 의미하며, 어떤 경우에는 기존 코드를 변경하지 않고도 가능하다.

이것은 OCP(Open-closed principle)과 연관되어 있다.

프래그래밍 속도

안전성

---

## 2.3 리팩터링과 일상업무

리팩터링은 프로그래머의 일상업무가 돼야 한다. 

코드를 리팩터링하지 않고 그냥 전달하기만 하면 다른 프로그래머의 시간을 뺴앗는 셈이다.

- 레거시 시스템에서는 변경하지 전에 먼저 리팩터링하십시오. 그런 다음 작업 절차를 따르십시오
- 코드를 변경한 후에도 리팩터링하십시오.



"항상 여러분이 왔을 때보다 더 좋게 만들어 놓고 떠나세요."

