# 객체 다루기



- 변경 가능한 객체와 변경 불가능한 객체 구별하기
- 변경자(modifier) 메소드를 사용해 상태를 변경하고 변경한 복사본 생성하기
- 객체 비교하기
- 유효하지 않은 상태 변경으로부터 보호하기
- 이벤트를 사용해 변경 가능한 객체의 변경 추적하기



## 1. 개체: 변경을 추적하고 이벤트를 기록하는 식별 가능한 객체

DDD에서는 엔티티라 불리는 것.

 이는 비지니스 도메인의 중요한 개념을 나타내며, 개발자가 비즈니스 도메인에 대해 얻은 지식을 모델로 한다. 오직 관련 있는 데이터를 담으며, 그 데이터를 조작하는 방법을 제공하거나 그 데이터를 바탕으로 하는 유용한 정보를 노출한다.

여기서 식별 가능하다는 것은 즉, 추적이 가능하다는 말이고, 변화를 겪더라도 항상 동일한 객체여야 한다는 점. 그리고 객체를 생성할 때는 식별자를 부여한다.



## 2. 값 객체: 교체할 수 있고 익명이며 변경 불가능한 값

 속성은 하나 혹은 둘 뿐이며 휠씬 더 작다. 이 역시 도메인 개념을 나타낼 수 있지만 이때는 개체의 일부나 그러한 측면을 나타냄.

예를 들어, `OrderId`, `Address` 등이 대표적인 예시이다.

값객체는 식별할 필요 없이, 작업하는 정확한 인스턴스를 신경 쓰지 않는 것은 값 객체에 일어난 변화를 추적할 필요가 없기 때문에, 값 객체는 절대 바뀌지 않아야 한다. 다른 값으로 변환하고 싶다면 변경한 값을 나타내는 새 복사본을 생성한다.



## 3. 데이터 전송 객체: 디자인 규칙이 적은 단순한 객체

타입 값을 감싸는 다른 객체 타입은 데이터 전송 객체.



## 4. 변경 불가능 객체가 우선이다.



엔티티는 변화를 추적하게 디자인하므로 생성 후 조작할 수 있으면 유용하다. 하지만 일반적으로는 변경 불가능한 객체를 우선으로 한다. 사실 개체가 아닌 객체 대부분은 변경 불가능한 값 객체로 구현해야 한다. 그러면 변경 불가능 개체를 우선해야 하는 이유는? 무엇인가?



정의에 따라 객체는 생성한 후 다른 곳에서 재사용할 수 있다. 즉 객체를 메소드 인자냐 생성자 인자로 전달하거나 속성에 할당할 수 있다.

 무슨말이냐?

```java

appointment = new Appointment(new DateTime('12:00'));
time = appointment.time(); //12시 반환
reminderTime = appointment.reminderTime(); // 11시를 설정
time = appointment.time(); // 여기서 11시로 반환됨
```

속성값으로 부여하면서 값이 변경되었지만, 알기 어렵다.

이런 상황을 막는 방법은 개체가 아닌 모든 객체를 변경불가능하게 디자인 하는 것이다. 변경 불가능한 객체에 대한 참조는 항상 안전하다.

### 4.1값을 변경하는 대신 교체한다.

## 5. 변경 불가능한 객체의 변경자는 변경한 복사본을 반환해야 한다.

변경 불가능성에 관한 결론을 바탕으로, 변경 불가능 객체에는 변경자로 간주할 수 있는 메서드만 있을 수 있다. 그럼에도 불구하고, 그 변경자 마저도 상태를 변경하지 않는 대신 메소드의 의도대로 해당 객체의 복사본을 반환한다.

두 가지 방식

1. 생성자를 통해서 새롭게 생성
2. Clone 연산자를 사용해 객체의 실제 복사본을 생성한 다음 원하는 변경을 하는 것. 이는 속성이 여럿인 변경 불가능한 객체에 유용하다.

변경자 메서드를 조금 더 똑똑하게 만들 방법을 찾거나 적어도 기술보다는 도메인 지향적인 이름을 부여하자. 

## 6. 변경 가능 객체의 변경자 메서드는 명령 메서드여야 한다.



명령 메서드라는 것이 어떤 의미인가?

`Position.moveLeft() ` 라는 메소드 명이 가져오는 느낌은 변경 가능성을 표현한다. 또한 void 반환 타입이다.



## 7. 변경 불가능 객체의 변경자 메서드 이름은 서술형이어야 한다.

변경 가능 객체에서 변경자 메서드는 객체 상태를 변경할 것으로 예상하며, 이를 명령 메서드의 기존 특성과 일치한다.



그러나, 변경 불가능 객체의 변경자 메서드에는 서술형이어야 한다. 

위에서 변경 가능 객체는 `moveLeft()` 라고 했다.  그러나 변경 불가능 객체의 경우에는 `toTheLeft()` 라는 식의 서술형으로 했다. 왜그럴까?



변경 불가능 객체의 변경 메서드에 좋은 이름을 지우려면 `이... 을 원한다. 하지만..` 템플릿을 채워본다. Position 이라면, `이 위치를 원한다. 하지만 왼쪽으로 n 걸음 이동한다` 가 되므로 toTheLeft()가 거절하다.

**해당 기술 도메인의 일반적인 이름 대신, 도메인별 고수준의 이름을 목표로 하자.**



## 8. 객체 전체를 비교한다.

## 9. 변경 불가능 객체를 비교할 때는 동일성이 아닌 상등을 확인한다.

변경 불가능 객체를 비교할 때는, 테스트에서 여러 객체의 메모리 참조 위치가 동일하지 않도록 한다. 

## 10. 변경자 메서드를 호출한 결과는 항상 유효한 객체여야 한다.

