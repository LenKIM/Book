# 시간 동기화 문제와 논리적 시계

## 1. 이중화된 데이터베이스 문제

분산된 데이터베이스의 병행 갱신

![image-20240525203153394](https://raw.githubusercontent.com/LenKIM/images/master/2024-05-25/image-20240525203153394.png)



![image-20240525203201639](https://raw.githubusercontent.com/LenKIM/images/master/2024-05-25/image-20240525203201639.png)



입금과 이자 지급이 시간차에 의해서 차이가 발생할 가능성이 높다.

그렇다면, 이 문제를 어떻게 해결할 수 있을까? 입금과 이자 지급 중 먼저 일어난 것을 우선적으로 수행하면 되지 않겠냐는 아이디어를 제시할 수도 있다.

정말정말... 정밀하며 정확하게 동일한 시각이라는 것을 전제로 말이다.

매 순간, 모든 분산된 장치가 항상 동일한 시각을 보고 있다면 얼마나 좋을까? 그러나 분산된 장치가 바라보는 시계는 사실 조금씩 다르고, 이것이 분산 컴퓨팅 문제를 어렵게 하는 요인이다.

### 시간 동기화 기법

![image-20240525203826300](https://raw.githubusercontent.com/LenKIM/images/master/2024-05-25/image-20240525203826300.png)

어떻게 시간을 동기화 시킬 수 있을까? 몇가지 알고리즘이 존재한다.

### 크리스티안 알고리즘

기준 시각을 알려주는 서버가 있다는 전제하에 네트워크에서 메시지가 이동하는 시간을 고려하여, 가장 기본적인 시간 동기화 기법인 '크리스티안 알고리즘'



![image-20240525204524196](https://raw.githubusercontent.com/LenKIM/images/master/2024-05-25/image-20240525204524196.png)

**a(req) + a(res) = (T4-T1) - (T3-T2)**

T4 = T3 + a/2



### 버클리 알고리즘

별도의 기준 시각을 제공하는 시계가 없고, 분산된 장치들은 각자 서로 정확도가 비슷한 시계를 가지고 있으며, 네트워크에 다음과 같이 연결되어 있다고 가정하자.

<img src="https://raw.githubusercontent.com/LenKIM/images/master/2024-05-25/image-20240525213929261.png" alt="image-20240525213929261" style="zoom:50%;" />



<img src="https://raw.githubusercontent.com/LenKIM/images/master/2024-05-25/image-20240525213940765.png" alt="image-20240525213940765" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/LenKIM/images/master/2024-05-25/image-20240525213950942.png" alt="image-20240525213950942" style="zoom:50%;" />

세 장치 간의 평균 시간은 3:05 로 확인할 수 있다. 마스터 장치는 자신을 포함하여 다른 장치들에게 평균 시각에 맞추기 위해 얼마나 시간을 조정해야 하는지 알려준다.


### 네트워크 시간 프로토콜(Network Time Protocal, NTP)

NTP에서 정확한 시각을 필요로 하는 장치들과 기준 시각을 제공하는 서버들은 다음과 같은 계층을 형성하고 있다. 

Stratum 0 / Stratum 1 / Stratum 2 / Stratum 3

일반 분산 장치들은 Stratum3 의 NTP 서버들과 연결되며, 이번에 배운 **크리스티안 알고리즘**에 따라 각자의 시계를 보정

**크리스티안 알고리즘**에 따라 각 클라이언트는 상위 계층의 모든 NTP 서버에서 K번 조정된 시각 t값을 수신. 가장 적은 조정 시각 편차를 보이는 NTP 서버를 기준 시각 서버로 선택하고, 각 클라이언트는 크리스티안 알고리즘에 따라 자신의 시계를 보정한다.



## 3. 논리적 시계

앞에서 소개한 이중화된 데이터베이스를 업데이트할 때 발생할 수 있는 비일관된 상태의 문제를 어떻게 해결할 수 있을까? 앞서 언급한 시간만 해결되면 될까? 그럴 수 없다.



### 램포트 시계(Lamport Clock)

램포트 시계는 정확한 절대 시각은 무시하며, 분산된 장치들 간에 어떤 작업이 먼저 일어났는지 또는 다음에 일어날 것인지에 대한 시간 관계를 규정.



<img src="https://raw.githubusercontent.com/LenKIM/images/master/2024-05-25/image-20240525232837027.png" alt="image-20240525232837027" style="zoom:50%;" />

작업 발생 건을 이벤트. 이벤트 a와 b가 있다고 가정하며 만약 a보다 b보다 먼저 발생했다면, 이러한 시간 관계를 (a > b)로 표현하고, a와 b사이의 시간 관계가 명확하지 않은 경우 (a || b)로 표현을 가정합니다.



**이벤트 전체 순서**

>  램포트 시계 작동 알고리즘(Lamport Clock Algorithm)
>
> 1. 모든 장치 i는 자체 램포트 시계 Ci 를 보우. 장치가 시작하면서 Ci는  0으로 초기화되는데, 이때 램포트 시각은 정수값.
> 2. 각 이벤트가 실행되기 전에 램포트 시계를 현재의 램포트 시각에서 1을 증가시킨다
>    - Ci <= Ci + 1
> 3. 이벤트가 실행되면, 새롭게 1을 증가한 램포트 시각에서 발생했다고 표시
> 4. Ci가 Cj에게 메시지(m)를 보내는 경우, m에 메시지를 보낸 시점의 램포트 시각을 함께 첨부하여 전송
> 5. Cj는 m에 포함된 램포트 시각 C(m)을 자신의 현재 램포트 시각과 비교하고 그 중에서 더 큰 램포트 시각에 1을 더한 시각을, m을 수신한 이벤트의 램포트 시각으로 정한다.

<img src="https://raw.githubusercontent.com/LenKIM/images/master/2024-05-25/image-20240525233858908.png" alt="image-20240525233858908" style="zoom:50%;" />



## 4. 램포트 시계를 활용한 비일관성 문제 해결

램포트 시계의 핵심 개념은 분산 환경에서 발생한 이벤트들 간의 전체적인 순서를 결정할 수 있다는 것.

따라서, 서울 지점과 부산 지점은 모두 DB 내용을 일관된 전체 순서에 따라 업데이트하는 것을 목표로 한다.



각 지점은 다른 지점에서 수행해야 할 작업을 적어둔 메시지에 램포트 시각을 첨부하여 전송. 이때 각 지점은 타 지점에서 전송하는 메시지를 담는 큐(Queue)를 가진다. 이 큐를 활용해 데이터베이스 복제 알고리즘을 설계할 수 있다.

**데이터베이스 복제 알고리즘**

1. 데이터베이스를 업데이트해야 할 작업이 발생하면, 해당 작업을 자신과 다른 지점에 메시지로 통지한다.
2. 업데이트할 작업을 다른 지점에서 수신하면,
   1. 해당 작업을 일단 큐에 저장한다.
   2. 자신과 다른 지점에 대한 수신 확인 메시지를 전송. 다만 해당 업데이트 작업이 큐의 가장 앞에 있는 경우에만 회신한다.
3. 업데이트할 일에 대한 수신 확인 메시지를 받으면, 해당 작업이 다른 지점에서도 확인되었음을 표시한다.
4. 확인된 작업은 큐에서 가장 첫 번째 자리에서 제거하고, 해당 작업을 수행한다.





