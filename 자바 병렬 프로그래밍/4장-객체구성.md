# 4장 객체 구성

## 1. 스레드 안전한 클래스 설계

```java
@ThreadSafe
public final class Counter {
    @GuardedBy("this") private long value = 0;
    
    public synchronized long getValue() {
        return value;
    }
    
    public synchronized long increment() {
        if (value == Long.MAX_VALUE) {
            throw new IlleagalstateException("counter overflow");
        }
        return ++value;
    }
} 
```

- `@ThreadSafe` 어노테이션은 이 클래스가 스레드 안전하다는 것을 나타낸다.
- `@GuardedBy("this")` 어노테이션은 이 클래스의 모든 상태 변수는 객체의 내부 상태로 보호된다는 것을 나타낸다.
- `synchronized` 키워드는 이 메서드가 단일 스레드에서만 실행되도록 보장한다.
- 객체와 변수를 놓고 보면 항상 객체와 변수가 가질 수 있는 가능한 값의 범위를 생각할 수 있는데, 이런 값의 범위를 상태 범위(state space) 라고 하고, 상태 범위가 좁을 수록 객체의 논리적인 상태를 파악하기가 쉽다.

### 상태 의존 연산
 현재 조건에 따라 동작 여부가 결정되는 연산을 상태 의존 연산

### 상태 소유권
 객체의 상태는 해당 객체에 포함되는 모든 객체와 변수가 가질 수 있는 전체 상태의 부분 집합. 왜 부분집합? 객체가 가질 수 있는 상태임에도 불구하고 실제로는 해당 객체의 상태에 속하지 않는 경우는 언제?

 소유권 이라는 단어에 대해서... 객체가 가지고 있는 상태를 소유한다는 것은 객체가 가지고 있는 상태를 보호한다는 것을 의미한다. 객체가 가지고 있는 상태를 보호한다는 것은 객체가 가지고 있는 상태를 변경하는 연산을 보호한다는 것을 의미한다. 컬렉션 클래스에서 '소유권 분리'
### 3. 인스턴스 한정

 아래 코드가 인스턴스 한정을 표현한다.

```java
@ThreadSafe
public class PersonSet {
    @GuardedBy("this") private final Set<Person> mySet = new HashSet<Person>();
    
    public synchronized void addPerson(Person p) {
        mySet.add(p);
    }

    public synchronized boolean containsPerson(Person p) {
        return mySet.contains(p);
    }
}
```
Person 객체가 스레드 세이프 하지 않더라고, PersonSet 클래스는 스레드 세이프하다. 이런 경우에는 PersonSet 클래스가 Person 객체를 보호하고 있기 때문이다.

비슷한 사레를 자바 플렛폼에서도 찾아볼 수 있는데,

- `java.util.concurrent.CopyOnWriteArrayList`
- Collections.synchronizedList
: 데코레이터 패턴을 활용하여 스레드 세이프한 리스트를 만들 수 있다.
- 그 외에도 `java.util.concurrent` 패키지에는 스레드 세이프한 컬렉션들이 많다.

## 2.1 자바 모니터 패턴

자바 모니터 패턴은 객체의 상태를 보호하기 위해 객체의 내부 상태를 보호하기 위해 객체의 내부 상태를 보호하기 위해 객체의 내부 상태에 대한 접근을 제한하는 방법이다.

변경가능한 데이터를 모두 객체 내부에 숨긴 다음 객체의 암묵적인 락으로 동시 접근을 막는다.

```java
public class PrivateLock {
    private final Object myLock = new Object();
    @GuardedBy("myLock") Widget widget;
    
    void someMethod() {
        synchronized (myLock) {
            // Access or modify the state of widget
        }
    }
}
```

위 코드가 자바 모니터 패턴을 활용하는 모습

## 2.2 예제

차량 위치 추적

```java
Map<String, Point> locations = vehicles.getLocations();
for (String key : locations.keySet()) {
    Point point = locations.get(key);
    renderVehicle(key, point);
}
---
void vehicleMoved(VehicleMovedEvent event) {
    Point point = new Point(event.getNewLocation());
    vehicles.getLocations().put(event.getVehicleId(), point);
}
```
뷰 스레드와 업데이트 스레드가 동시 다발적으로 데이터 모델을 사용한다면?

어떻게 스레드 안전성을 확보할 수 있을까?

복사본을 만들거나 deepCopy 메소드를 사용해 새로운 locations 인스턴스 복사본을 만들어 넘겨준다. 이렇게 하면 스레드 안전성을 부분적으로 확보할 수 있다. 일반적인 경우에는 문제되지 않지만, 데이터가 많아지면 성능 문제가 발생할 수 있다.

## 3. 스레드 안전성 위임
 클래스를 구현할 때 바닥부터 새로 만들거나 이미 만들어져 있지만 스레드 안전성이 없는 객체를 조합해 만들면서 스레드 안정성을 확보하고자 한다면 자바 모니터 패턴을 유용하게 사용할 수 있다.

 AtomicLong 클래스가 스레드에 안전하기 때문에 AtomicLong에게 스레드 안전성을 위임할 수 있다.


[[JAVA] Atomic 과 동시성](https://velog.io/@chullll/JAVA-Atomic-%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%84%B1)

```java
public class NumberRange {
    // INVARIANT: lower <= upper
    private final AtomicLong lower = new AtomicLong(0);
    private final AtomicLong upper = new AtomicLong(0);
    
    public void setLower(long i) {
        if (i > upper.get()) {
            throw new IllegalArgumentException("can't set lower to " + i + " > upper");
        }
        lower.set(i);
    }
    
    public void setUpper(long i) {
        if (i < lower.get()) {
            throw new IllegalArgumentException("can't set upper to " + i + " < lower");
        }
        upper.set(i);
    }
    
    public boolean isInRange(long i) {
        return (i >= lower.get() && i <= upper.get());
    }
}
```

 NumberRange 클래스처럼 두 개 이상의 변수를 사용하는 복합 연산 메소드를 갖고 있다면 위임 기법만으로 안정성 확보할 수 없으며, 이때는 내부적으로 락을 활용해서 복합 연산이 단일 연산으로 처리되도록 동기화.

## 4. 스레드 안전하게 구현된 클래스에 기능 추가

```java
@NotThreadSafe
public class BetterVector<E> extends Vector<E> {
    
    public synchronized boolean putIfAbsent(E x) {
        ...
    }
}
```
 위와같이 상속해서 락을 건다면, 상위/하위 클래스 모두 관리해야하기 때문에 문제가 생길 위험이 휠씬 많다.

```java
@NotThreadSafe
public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    ...
    public synchronized boolean putIfAbsent(E x) {
        ...
        
    }
}
```

위 Helper 는 왜 스레드 세이프하지 않을까?
putIfAbsent 에서 synchronized 키워드를 사용했지만, list 를 보호하는 락이 listHelper 객체가 아니라 list 객체이기 때문이다. 결과적으로 putIfAbsent 메서드는 listHelper 객체의 락을 사용하지 않고 list 객체의 락을 사용하게 된다.

올바르게 구현한다면 아래와 같이 구현해 클라이언트 측 락을 사용하도록 한다.

```java
@ThreadSafe
public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    public boolean putIfAbsent(E x) {
        synchronized (list) {
            if (!list.contains(x)) {
                list.add(x);
                return true;
            }
            return false;
        }
    }
}
```
또는 클래스 재구성을 사용. list 를 변수로 사용한다.

```java

@ThreadSafe
public class ImprovedList<T> implements List<T> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    public synchronized boolean putIfAbsent(E x) {
        synchronized (list) {
            if (!list.contains(x)) {
                list.add(x);
                return true;
            }
            return false;
        }
    }
}
```

