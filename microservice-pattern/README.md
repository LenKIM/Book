- [x] 1장 모놀리식 지옥에서 벗어나라  
- [x] 1.1 서서히 모놀리식 지옥에 빠져들다  
- [x] __1.1.1 FTGO 애플리케이션 아키텍처  
- [x] __1.1.2 모놀리식 아키텍처의 장점  
- [x] __1.1.3 모놀리식 지옥의 실상  
- [x] 1.2 이 책의 대상 독자  
- [x] 1.3 이 책의 학습 내용  
- [x] 1.4 마이크로서비스 아키텍처가 답이다  
- [x] __1.4.1 확장 큐브와 마이크로서비스  
- [x] __1.4.2 마이크로서비스는 모듈성을 갖고 있다  
- [x] __1.4.3 서비스마다 DB가 따로 있다  
- [x] __1.4.4 FTGO 마이크로서비스 아키텍처  
- [x] __1.4.5 마이크로서비스 아키텍처와 SOA  
- [x] 1.5 마이크로서비스 아키텍처의 장단점  
- [x] __1.5.1 마이크로서비스 아키텍처의 장점  
- [x] __1.5.2 마이크로서비스 아키텍처의 단점  
- [x] 1.6 마이크로서비스 아키텍처 패턴 언어  
- [x] __1.6.1 마이크로서비스 아키텍처도 만병통치약은 아니다  
- [x] __1.6.2 패턴 및 패턴 언어  
- [x] __1.6.3 마이크로서비스 아키텍처 패턴 언어 개요  
- [x] 1.7 마이크로서비스 너머: 프로세스와 조직  
- [x] __1.7.1 소프트웨어 개발/전달 조직  
- [x] __1.7.2 소프트웨어 개발/전달 프로세스  
- [x] __1.7.3 마이크로서비스를 받아들이는 인간적 요소  
- [x] 1.8 마치며  


- [ ] 2장 분해 전략  
- [ ] 2.1 마이크로서비스 아키텍처란 무엇인가?  
- [ ] __2.1.1 소프트웨어 아키텍처의 정의와 중요성  
- [ ] __2.1.2 아키텍처 스타일 개요  
- [ ] __2.1.3 마이크로서비스 아키텍처는 일종의 아키텍처 스타일이다  
- [ ] 2.2 마이크로서비스 아키텍처 정의  
- [ ] __2.2.1 시스템 작업 식별  
- [ ] __2.2.2 서비스 정의: 비즈니스 능력 패턴별 분해  
- [ ] __2.2.3 서비스 정의: 하위 도메인 패턴별 분해  
- [ ] __2.2.4 분해 지침  
- [ ] __2.2.5 서비스 분해의 장애물  
- [ ] __2.2.6 서비스 API 정의  
- [ ] 2.3 마치며  


- [ ] 3장 프로세스 간 통신  
- [ ] 3.1 마이크로서비스 아키텍처 IPC 개요  
- [ ] __3.1.1 상호 작용 스타일  
- [ ] __3.1.2 마이크로서비스 API 정의  
- [ ] __3.1.3 API 발전시키기  
- [ ] __3.1.4 메시지 포맷  
- [ ] 3.2 동기 RPI 패턴 응용 통신  
- [ ] __3.2.1 동기 RPI 패턴: REST  
- [ ] __3.2.2 동기 RPI 패턴: gRPC  
- [ ] __3.2.3 부분 실패 처리: 회로 차단기 패턴  
- [ ] __3.2.4 서비스 디스커버리  
- [ ] 3.3 비동기 메시징 패턴 응용 통신  
- [ ] __3.3.1 메시징 개요  
- [ ] __3.3.2 메시징 상호 작용 스타일 구현  
- [ ] __3.3.3 메시징 기반 서비스의 API 명세 작성  
- [ ] __3.3.4 메시지 브로커  
- [ ] __3.3.5 수신자 경합과 메시지 순서 유지  
- [ ] __3.3.6 중복 메시지 처리  
- [ ] __3.3.7 트랜잭셔널 메시징  
- [ ] __3.3.8 메시징 라이브러리/프레임워크  
- [ ] 3.4 비동기 메시징으로 가용성 개선  
- [ ] __3.4.1 동기 통신으로 인한 가용성 저하  
- [ ] __3.4.2 동기 상호 작용 제거  
- [ ] 3.5 마치며  


- [ ] 4장 트랜잭션 관리: 사가  
- [ ] 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리  
- [ ] __4.1.1 분산 트랜잭션의 필요성  
- [ ] __4.1.2 분산 트랜잭션의 문제점  
- [ ] __4.1.3 데이터 일관성 유지: 사가 패턴  
- [ ] 4.2 사가 편성  
- [ ] __4.2.1 코레오그래피 사가  
- [ ] __4.2.2 오케스트레이션 사가  
- [ ] 4.3 비격리 문제 처리  
- [ ] __4.3.1 비정상 개요  
- [ ] __4.3.2 비격리 대책  
- [ ] 4.4 주문 서비스 및 주문 생성 사가 설계  
- [ ] __4.4.1 OrderService 클래스  
- [ ] __4.4.2 주문 생성 사가 구현  
- [ ] __4.4.3 OrderCommandHandlers 클래스  
- [ ] __4.4.4 OrderServiceConfiguration 클래스  
- [ ] 4.5 마치며  


- [ ] 5장 비즈니스 로직 설계  
- [ ] 5.1 비즈니스 로직 구성 패턴  
- [ ] __5.1.1 비즈니스 로직 설계: 트랜잭션 스크립트 패턴  
- [ ] __5.1.2 비즈니스 로직 설계: 도메인 모델 패턴  
- [ ] __5.1.3 도메인 주도 설계 개요  
- [ ] 5.2 도메인 모델 설계: DDD 애그리거트 패턴  
- [ ] __5.2.1 불분명한 경계 문제  
- [ ] __5.2.2 애그리거트는 경계가 분명하다  
- [ ] __5.2.3 애그리거트 규칙  
- [ ] __5.2.4 애그리거트 입도  
- [ ] __5.2.5 비즈니스 로직 설계: 애그리거트  
- [ ] 5.3 도메인 이벤트 발행  
- [ ] __5.3.1 변경 이벤트를 발행하는 이유  
- [ ] __5.3.2 도메인 이벤트란 무엇인가?  
- [ ] __5.3.3 이벤트 강화  
- [ ] __5.3.4 도메인 이벤트 식별  
- [ ] __5.3.5 도메인 이벤트 생성 및 발행  
- [ ] __5.3.6 도메인 이벤트 소비  
- [ ] 5.4 주방 서비스 비즈니스 로직  
- [ ] __5.4.1 Ticket 애그리거트  
- [ ] 5.5 주문 서비스 비즈니스 로직  
- [ ] __5.5.1 Order 애그리거트  
- [ ] __5.5.2 OrderService 클래스  
- [ ] 5.6 마치며  


- [ ] 6장 비즈니스 로직 개발: 이벤트 소싱  
- [ ] 6.1 이벤트 소싱 응용 비즈니스 로직 개발  
- [ ] __6.1.1 기존 영속화의 문제점  
- [ ] __6.1.2 이벤트 소싱 개요  
- [ ] __6.1.3 동시 업데이트: 낙관적 잠금  
- [ ] __6.1.4 이벤트 소싱과 이벤트 발행  
- [ ] __6.1.5 스냅샷으로 성능 개선  
- [ ] __6.1.6 멱등한 메시지 처리  
- [ ] __6.1.7 도메인 이벤트 발전시키기  
- [ ] __6.1.8 이벤트 소싱의 장점  
- [ ] __6.1.9 이벤트 소싱의 단점  
- [ ] 6.2 이벤트 저장소 구현  
- [ ] __6.2.1 이벤추에이트 로컬 이벤트 저장소의 작동 원리  
- [ ] __6.2.2 자바용 이벤추에이트 클라이언트 프레임워크  
- [ ] 6.3 사가와 이벤트 소싱을 접목  
- [ ] __6.3.1 코레오그래피 사가 구현: 이벤트 소싱  
- [ ] __6.3.2 오케스트레이션 사가 생성  
- [ ] __6.3.3 이벤트 소싱 기반의 사가 참여자 구현  
- [ ] __6.3.4 사가 오케스트레이터 구현: 이벤트 소싱  
- [ ] 6.4 마치며  


- [ ] 7장 마이크로서비스 쿼리 구현  
- [ ] 7.1 API 조합 패턴 응용 쿼리  
- [ ] __7.1.1 findOrder( ) 쿼리  
- [ ] __7.1.2 API 조합 패턴 개요  
- [ ] __7.1.3 API를 조합 패턴으로 findOrder( ) 쿼리 구현  
- [ ] __7.1.4 API 조합 설계 이슈  
- [ ] __7.1.5 API 조합 패턴의 장단점  
- [ ] 7.2 CQRS 패턴  
- [ ] __7.2.1 CQRS의 필요성  
- [ ] __7.2.2 CQRS 개요  
- [ ] __7.2.3 CQRS의 장점  
- [ ] __7.2.4 CQRS의 단점  
- [ ] 7.3 CQRS 뷰 설계  
- [ ] __7.3.1 뷰 DB 선택  
- [ ] __7.3.2 데이터 접근 모듈 설계  
- [ ] __7.3.3 CQRS 뷰 추가 및 업데이트  
- [ ] 7.4 CQRS 뷰 구현: AWS DynamoDB 응용  
- [ ] __7.4.1 OrderHistoryEventHandlers 모듈  
- [ ] __7.4.2 DynamoDB 데이터 모델링 및 쿼리 설계  
- [ ] __7.4.3 OrderHistoryDaoDynamoDb 클래스  
- [ ] 7.5 마치며  


- [ ] 8장 외부 API 패턴  
- [ ] 8.1 외부 API 설계 이슈  
- [ ] __8.1.1 API 설계 이슈: FTGO 모바일 클라이언트  
- [ ] __8.1.2 API 설계 이슈: 다른 종류의 클라이언트  
- [ ] 8.2 API 게이트웨이 패턴  
- [ ] __8.2.1 API 게이트웨이 패턴 개요  
- [ ] __8.2.2 API 게이트웨이의 장단점  
- [ ] __8.2.3 API 게이트웨이 사례: 넷플릭스  
- [ ] __8.2.4 API 게이트웨이 설계 이슈  
- [ ] 8.3 API 게이트웨이 구현  
- [ ] __8.3.1 기성 API 게이트웨이 제품/서비스 활용  
- [ ] __8.3.2 API 게이트웨이 자체 개발  
- [ ] __8.3.3 API 게이트웨이 구현: GraphQL  
- [ ] 8.4 마치며  


- [ ] 9장 마이크로서비스 테스트 1부  
- [ ] 9.1 마이크로서비스 아키텍처 테스트 전략  
- [ ] __9.1.1 테스트 개요  
- [ ] __9.1.2 마이크로서비스 테스트  
- [ ] __9.1.3 배포 파이프라인  
- [ ] 9.2 서비스 단위 테스트 작성  
- [ ] __9.2.1 단위 테스트 작성: 엔터티  
- [ ] __9.2.2 단위 테스트 작성: 밸류 객체  
- [ ] __9.2.3 단위 테스트 작성: 사가  
- [ ] __9.2.4 단위 테스트 작성: 도메인 서비스  
- [ ] __9.2.5 단위 테스트 작성: 컨트롤러  
- [ ] __9.2.6 단위 테스트 작성: 이벤트/메시지 핸들러  
- [ ] 9.3 마치며  


- [ ] 10장 마이크로서비스 테스트 2부  
- [ ] 10.1 통합 테스트 작성  
- [ ] __10.1.1 통합 테스트: 영속화  
- [ ] __10.1.2 통합 테스트: REST 요청/응답형 상호 작용  
- [ ] __10.1.3 통합 테스트: 발행/구독 스타일 상호 작용  
- [ ] __10.1.4 통합 계약 테스트: 비동기 요청/응답 상호 작용  
- [ ] 10.2 컴포넌트 테스트 개발  
- [ ] __10.2.1 인수 테스트 정의  
- [ ] __10.2.2 인수 테스트 작성: 거킨  
- [ ] __10.2.3 컴포넌트 테스트 설계  
- [ ] __10.2.4 컴포넌트 테스트 작성: 주문 서비스  
- [ ] 10.3 종단 간 테스트 작성  
- [ ] __10.3.1 종단 간 테스트 설계  
- [ ] __10.3.2 종단 간 테스트 작성  
- [ ] __10.3.3 종단 간 테스트 실행  
- [ ] 10.4 마치며  


- [ ] 11장 프로덕션 레디 서비스 개발  
- [ ] 11.1 보안 서비스 개발  
- [ ] __11.1.1 기존 모놀리식 애플리케이션의 보안  
- [ ] __11.1.2 마이크로서비스 아키텍처에서의 보안 구현  
- [ ] 11.2 구성 가능한 서비스 설계  
- [ ] __11.2.1 푸시 기반의 외부화 구성  
- [ ] __11.2.2 풀 기반의 외부화 구성  
- [ ] 11.3 관측 가능한 서비스 설계  
- [ ] __11.3.1 헬스 체크 API 패턴  
- [ ] __11.3.2 로그 수집 패턴  
- [ ] __11.3.3 분산 추적 패턴  
- [ ] __11.3.4 애플리케이션 지표 패턴  
- [ ] __11.3.5 예외 추적 패턴  
- [ ] __11.3.6 감사 로깅 패턴  
- [ ] 11.4 서비스 개발: 마이크로서비스 섀시 패턴  
- [ ] __11.4.1 마이크로서비스 섀시  
- [ ] __11.4.2 이제는 서비스 메시로  
- [ ] 11.5 마치며  


- [ ] 12장 마이크로서비스 배포  
- [ ] 12.1 서비스 배포: 언어에 특정한 패키징 포맷 패턴  
- [ ] __12.1.1 언어에 특정한 패키징 포맷 패턴의 장점  
- [ ] __12.1.2 언어에 특정한 패키징 포맷 패턴의 단점  
- [ ] 12.2 서비스 배포: 가상 머신 패턴  
- [ ] __12.2.1 가상 머신 패턴의 장점  
- [ ] __12.2.2 가상 머신 패턴의 단점  
- [ ] 12.3 서비스 배포: 컨테이너 패턴  
- [ ] __12.3.1 서비스를 도커로 배포  
- [ ] __12.3.2 컨테이너 패턴의 장점  
- [ ] __12.3.3 컨테이너 패턴의 단점  
- [ ] 12.4 FTGO 애플리케이션 배포: 쿠버네티스  
- [ ] __12.4.1 쿠버네티스 개요  
- [ ] __12.4.2 쿠버네티스 배포: 음식점 서비스  
- [ ] __12.4.3 API 게이트웨이 배포  
- [ ] __12.4.4 무중단 배포  
- [ ] __12.4.5 배포와 릴리스 분리: 서비스 메시  
- [ ] 12.5 서비스 배포: 서버리스 패턴  
- [ ] __12.5.1 AWS 람다를 이용한 서버리스 배포  
- [ ] __12.5.2 람다 함수 개발  
- [ ] __12.5.3 람다 함수 호출  
- [ ] __12.5.4 람다 함수의 장점  
- [ ] __12.5.5 람다 함수의 단점  
- [ ] 12.6 REST 서비스 배포: AWS 람다 및 AWS 게이트웨이  
- [ ] __12.6.1 음식점 서비스를 AWS 람다 버전으로 설계  
- [ ] __12.6.2 ZIP 파일로 서비스 패키징  
- [ ] __12.6.3 서버리스 프레임워크로 람다 함수 배포  
- [ ] 12.7 마치며  


- [ ] 13장 마이크로서비스로 리팩터링  
- [ ] 13.1 마이크로서비스 리팩터링 개요  
- [ ] __13.1.1 모놀리스를 왜 리팩터링하는가?  
- [ ] __13.1.2 모놀리스 옥죄기  
- [ ] 13.2 모놀리스 → 마이크로서비스 리팩터링 전략  
- [ ] __13.2.1 새 기능을 서비스로 구현한다  
- [ ] __13.2.2 표현 계층과 백엔드를 분리한다  
- [ ] __13.2.3 기능을 여러 서비스로 추출한다  
- [ ] 13.3 서비스와 모놀리스 간 협동 설계  
- [ ] __13.3.1 통합 글루 설계  
- [ ] __13.3.2 서비스와 모놀리스에 걸쳐 데이터 일관성 유지  
- [ ] __13.3.3 인증/인가 처리  
- [ ] 13.4 새 기능을 서비스로 구현: 배달 실패한 주문 처리  
- [ ] __13.4.1 배달 지연 서비스 설계  
- [ ] __13.4.2 배달 지연 서비스를 위한 통합 글루 설계  
- [ ] 13.5 모놀리스 분해: 배달 관리 추출  
- [ ] __13.5.1 현행 배달 관리 기능  
- [ ] __13.5.2 배달 서비스 개요  
- [ ] __13.5.3 배달 서비스의 도메인 모델 설계  
- [ ] __13.5.4 배달 서비스의 통합 글루 설계  
- [ ] __13.5.5 배달 서비스와 상호 작용할 수 있게 모놀리스를 변경  
- [ ] 13.6 마치며  


- [ ] 한국어판 부록 a 실습 환경 구성  
- [ ] A.1 실습 준비  
- [ ] __A.1.1 운영 체제: 윈도 10 Pro  
- [ ] __A.1.2 하이퍼-V 가상화 지원  
- [ ] __A.1.3 윈도 리눅스용 하위 시스템(WSL) 기능 활성화  
- [ ] A.2 WSL 설치  
- [ ] A.3 도커 설치 및 구성  
- [ ] A.4 소스 내려받아 빌드하기  
- [ ] A.5 컨테이너 실습  
- [ ] __A.5.1 도커 컴포즈 실행  
- [ ] __A.5.2 스웨거 접속  
- [ ] __A.5.3 도커 컴포즈 종료  
- [ ] A.6 더 보기  
