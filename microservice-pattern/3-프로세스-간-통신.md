## 3장 프로세스 간 통신

### 3.1 마이크로서비스 아키텍처 IPC 개요  

IPC? Inter Process Community

__3.1.1 상호 작용 스타일

두 가지로 분류됨

- 일대일

  - 요청/응답(request/response) 
  - 비동기 요청/응답(asynchronous request/response)
  - 단방향 알림(one-way notification)

  대 부분 직교적(서로 연관성 없이 독립적)인 상호 작용 스타일

- 일대다

  - 발행/구독(publish/subscribe)
  - 발행/비동기 응답(publish/async response)

- 동기

- 비동기



__3.1.2 마이크로서비스 API 정의

- 인터페이스를 지정해야 한다. 마이크로서비스 아키텍쳐에서는 API와 인터페이스가 똑같이 중요합니다. 
- 어떤 IPC이든 IDL 로 정의해야 한다.
- API 우선 방식



__3.1.3 API 발전시키기

- 여러 곳에서 사용하는 API를 고치려면 시간이 많이 걸리므로 사실상 변경범위가 유일한 문제이다.
- 시멘틱 버저닝
  - MAJOR - 하위 호환되지 않는
  - MINOR - 하위 호환되는
  - PATCH - 하위 호환되는 오휴 수정
- 가급적 하위 호환성을 보장하는 방향으로 
- 단, "당신이 하는 일은 보수적으로, 다른 사람들이 하는 일은 관대하게 바라보라" . 견고성 원칙을 지켜야 한다.

__3.1.4 메시지 포맷

- 텍스트 메세지 포맷
  - JSON, XML등 자기 서술적 장점이 있다.
  - 단점으로는 다소 길다는 것과 모든 메세지에 속성 값 이외의 속성명이 추가되는 오버헤드가 있고, 덩치가 큰 메시지는 텍스트를 파싱하는 오버헤드도 있습니다. 따라서 효율/성능이 중요한 경우는 이진 포맷을 고려해 봄직합니다.
- 이진 메세지 포맷
  - 프로토콜 버퍼, AVRO
  - 컴파일러가 메시지를 직렬화/역직렬화하는 코드를 생성한다.



### 3.2 동기 RPI 패턴 응용 통신

**RPI > Remote Procedure Invocation 원격 프로시저 호출**

[프로토콜 버퍼, 아브로 비교 분석 글](https://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html)

__3.2.1 동기 RPI 패턴: REST

REST는 (거의 항상)HTTP로 소통하는 IPC이다.

> REST는 컴포넌트 상호 작용의 확장성, 인터페이스 일반화, 컴포넌트의 독립적 배포, 상호 작용 지연을 줄이기 위해 중간 컴포넌트, 보안 강화, 레거시 시스템의 캡슐화에 역점을 둔 아키텍처 제약 조건 세트를 제공한다.



리소스는 REST의 핵심 개념. REST는 HTTP 동사를 사용해서 URL로 참조되는 리소스를 가공한다. [REST API](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)

단점으로는

- 요청 한 번으로 많은 리소스를 가져오기 어렵다.
- 작업을 HTTP 동사에 매핑하기 어렵다.
- 요청/응답 스타일의 통신만 지원한다.
- 가용성이 떨어집니다. 중간에서 메시지를 버퍼링하는 매개자 없이 클라이언트/서비스가 직접 통신하기 때문에 교환이 일어나는 동안 양쪽 다 실행 중이어야 합니다.
- 서비스 인스턴스의 위치(URL)를 클라이언트가 알고 있어야 합니다. 요즘 애플리케이션은 서비스 디스커버리 메커니즘을 이용해서 클라이언트가 서비스 인스턴스 위치를 찾을 수 있으므로 큰 단점이 아니다.



__3.2.2 동기 RPI 패턴: gRPC

HTTP는 한정된 동사만 지원하기 때문에 다양한 업데이트 작업을 지원하는 REST API를 설계하기 어렵다. 그래서 gRPC가 등장했다.

- gRPC는 다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크
- gRPC 는 프로토콜 버퍼 메시지 포맷



장단점

- 다양한 업데이트 작업이 포함된 API를 설계하기 쉽다.
- 특히 큰 메시지를 교환할 때 콤팩트하고 효율적인 IPC
- 양방향 스트리밍 덕분에 RPI, 메시징 두 가지 통신 방식 모두 가능하다.
- 다양한 언어로 작성된 클라이언트/서버 간 연동이 가능



- 자바스크립트 클라이언트가 하는 일이 REST/JSON 기반 API보다 더 많습니다.



__3.2.3 부분 실패 처리: 회로 차단기 패턴

 클라이언트는 응답 대기 도중 블로킹되기 때문에 서비스 실패는 클라이언트의 클라이언트로 거슬러 올라가면서 전체 시스템의 중단을 초래할 위험이다.

> 패턴: 회로 차단기(circuit breaker)
>
> 연속 실패 횟수가 주어진 임계치를 초과하면 일정 시간 동안 호출을 즉시 거부하는 RPI 프록시다.

  ![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h4cjwd3e8gj21bo0h4mxy.jpg)



부분 실패가 애플리케이션 전체에 전파되지 않도록 서비스를 설계해야 한다.

- 무응답 원격 서비스를 처리하기 위해 OrderSerivceProxy 같은 견고한 RPI 프록시를 설계합니다.
- 원격 서비스가 실패하면 어떻게 조치해야 할지 결정한다.



서비스가 다른 서비스를 동기 호출할 때 자기 스스로 방어하는 방법

- 네트워크 타임아웃
  - 응답 대기 중에 무한정 블로킹하면 안되고 항상 타임아웃을 걸어 둔다.
- 미처리 요청(outstanding request) 개수 제한: 클라이언트가 특정 서비스에 요청 가능한 미처리 요청의 최대 개수를 설정한다. 이 개수에 이르면 더 이상의 요청은 무의미하므로 즉시 실패 처리한다.
- 회로 차단기 패턴
  - 성공/실패 요청 개수를 지켜보다가 에러율이 주어진 임계치를 초과하면 그 이후 시도는 바로 실패 처리한다. 실패된 요청이 많다는 것은 서비스가 불능 상태고 더 이상의 요청은 무의미하다는 뜻.
  - 타임아웃 시간 이후 클라이언트가 재시도해서 성공하면 차단기는 닫힌다.

**불능 서비스 복구**

- 부분 실패 시 미리 정해진 기본값이나 캐시된 응답 등 대체 값(fallback value)을  반환하는 방법도 있다.



__3.2.4 서비스 디스커버리

- 애플리케이션 수준의 서비스 디스커버리 패턴
  - 유레카와 같은 것
  - ![server-side discovery](https://tva1.sinaimg.cn/large/e6c9d24egy1h4ckofput0j20sg0hjmys.jpg)
- 플랫폼에 내장된 서비스 디스커버리 패턴 적용
  - 도커나 쿠버네티스 등 최신 배포 플랫폼에는 대부분 서비스 레지스트리, 서비스 디스커버리 메커니즘이 탑재되어 있음.
  - ![image-20220719225011206](/Users/len/Library/Application Support/typora-user-images/image-20220719225011206.png)





### 3.3 비동기 메시징 패턴 응용 통신

__3.3.1 메시징 개요

**메시징 모델**

메시지는 메시지 채널(message channel)을 통해 교환된다

**메시지**

- 문서(document) 데이터만 포함된 제네릭한 메시지. 메시지를 어떻게 해석할지는 수신자가 결정
- 커맨트(command): RPC 요청과 동등한 메시지. 호출할 작업과 전달할 매개변수가 지정됨
- 이벤트(event): 송신자에게 어떤 사건이 발생했음을 알리는 메시지. 이벤트는 대부분 Order, Customer 같은 도메인 객체의 상태 변화를 나타내는 도메인 이벤트.



두 종류의 채널

- 점대점 채널
  - 컨슈머 중 딱 하나만 지정하여 메시지를 전달
- 발행-구독 채널
  - 같은 채널을 바라보는 모든 컨슈머에 메시지를 전달한다. 이벤트 메시지



__3.3.2 메시징 상호 작용 스타일 구현

요청/응답 및 비동기 요청/응답

- 요청/응답은 서비스가 즉시 응답할 것이라고 클라이언트가 기대하지만 비동기 요청/응답은 클라이언트가 그런 기대를 하지 않습니다.

   ![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h4cljani8mj20rq0lw758.jpg)

**단방향 알림**

비동기 메시징을 이용하여 직관적으로 구현할 수 있음

서비스가 소유한 점대점 채널로 클라이언트가 메시지(커맨드 메시지)를 보내면, 서비스는 이 채널을 구독해서 메시지를 처리하는 구조.



__3.3.3 메시징 기반 서비스의 API 명세 작성

채널 및 메시지 타입은 딱히 정해진 문서화 표준이 없다.



작업과 이벤트는 문서화하는 방법이 다르다.

 ![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h4cmwfm18fj21bo0p2myz.jpg)

**비동기 작업 문서화**

두 가지 상호 작용 스타일 중 하나로 호출

- 요청/비동기 응답 스타일 API
  - 서비스의 커맨드 메시지 채널, 서비스가 받은 커맨드 메시지의 타입과 포맷, 서비스가 반환하는 응답 메시지의 타입과 포맷으로 구성
- 단방향 알림 스타일 API
  - 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷



**발행 이벤트 문서화**

- 서비스는 발행/구독 스타일로도 이벤트를 발행할 수 있다. 이런 스타일의 API 명세는 이벤트 채널, 서비스가 채널에 발행하는 이벤트 메시지의 타입과 포맷으로 구성



__3.3.4 메시지 브로커

메시지 브로커 선택시 선택 기준

- 프로그래밍 언어 지원 여부
- 메시징 표준 지원 여부
- 메시지 순서
- 전달 보장
- 영속화
- 내구성
- 확장성
- 지연시간
- 경쟁사 컨슈머

__3.3.5 수신자 경합과 메시지 순서 유지

__3.3.6 중복 메시지 처리

- 중복 메세지를 처리하는 방법 2가지
  - 멱등한  메시지 핸들러 작성
  - 메시지를 추적하고 중복을 솎아 냄
    - 책에서는 메세지 ID 를 DB 테이블에 저장하는 방법을 소개한다.
    - PROCESSED_MESSAGES 라는 전용 테이블

__3.3.7 트랜잭셔널 메시징

- 이벤트 발행 - 폴링 발행기 패턴
- 이벤트 발행 - 트랜잭션 로그 테일링 패턴

__3.3.8 메시징 라이브러리/프레임워크



3.4 비동기 메시징으로 가용성 개선

타 서비스와 동기 통신을 하면 그만큼 가용성이 떨어지므로 가능한 서비스가 비동기 메시징을 이요하여 통신하도록 설계하는 것이 좋다.

__3.4.1 동기 통신으로 인한 가용성 저하

동기 통신이 이뤄지면 가용성이 많이 떨어진다. 이를 비동기 메시징으로 개선할 수 있다.

__3.4.2 동기 상호 작용 제거

**비동기 상호 작용 스타일**

 ![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h4cni02gahj218m0f4t9v.jpg)

비동기 방식으로 모두 변경한다. 어느쪽도 블로킹되지 않는다.

**데이터 복제**

 서비스 요청 처리에 필요한 데이터의 레플리카를 유지하는 방법. 데이터 레플리카는 데이터를 소유한 서비스가 발행하는 이벤트를 구독해서 최신 데이터를 유지할 수 있다. 가령 소비자/음식점 서비스가 소유한 데이터 레플리카를 주문 서비스가 이미 갖고 있다면 주문 서비스가 주문 생성을 요청할 때 굳이 상호작용할 필요가 없다.

 ![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h4cnnfpfc9j21bn0h475k.jpg)

