**외부 API 설계가 무엇일까?**

쉽게 이야기하면, 마이크로서비스에서 각 서비스의 API이 존재하고, 따로 특정 서비스가 원하고자하는 쿼리를 만들기 위해 각 서비스의 API 를 조회해서 조합기를 만드는 행위를 만듭니다.

 이런 외부 API 설계에는 어떤 문제가 있는지 살펴보고,구현방식으로 API 게이트웨이, BFF 의 패턴을 살펴보자.

가장 나이브한 방식은 클라이언트가 필요한 서비스에 직접 요청하는 형태 일 것입니다.

 <img src="https://documents.lucid.app/documents/a6b2e07d-a201-4959-8dad-8c191ba78039/pages/0_0?a=28566&x=-3576&y=19866&w=1232&h=1314&store=1&accept=image%2F*&auth=LCA%20e91654328586839888e60c33694ec81f9107a5f1-ts%3D1662707539" alt="img" style="zoom:50%;" />



거의 이렇게 사용하지 않겠지만, 어떤 문제점이 있을까?

- 서비스 API가 잘게 나뉘어져 있어서 클라이언트가 필요한 데이터를 가져오려면 여러 번 요청을 해야 하고, 그만큼 가용성이 떨어집니다. UX가 좋지 않습니다.
- 클라이언트가 서비스 및 API를 알아야 하는 구조라서 캡슐화가 되지 않고, 나중에 아키텍처와 API를 바꾸기도 어렵습니다.
  = 안드로이드나, ISO 같은 경우 즉시 버전을 업데이트 되지 않습니다. 서비스 API를 모바일에 표출시키는 전략이 API를 발전시키는 데 중대한 걸림돌이 될 수도 있습니다.
- 클라이언트(특히 방화벽 외부에 있는 클라이언트)가 사용하기에 불편하거나 실용적이지 못한 IPC를 서비스에서 사용 중인 경우가 있습니다.



## API 게이트웨이 패턴

> 마이크로서비스 애플리케이션에 외부 API 클라이언트의 진입점에 해당하는 서비스를 구현한다.

캡슐화의 관점에서 서비스에 직접 접근하여 API를 조합한다는 것 자체는 좋은 것이 아닙니다. 



API 게이트웨이는 디자인패턴 중에 퍼사드 패턴을 떠올리면 이해가 쉬운데, 아래와 같은 형태를 가집니다.

 <img src="https://documents.lucid.app/documents/a6b2e07d-a201-4959-8dad-8c191ba78039/pages/0_0?a=28721&x=-8774&y=20320&w=1628&h=1314&store=1&accept=image%2F*&auth=LCA%20ff20d57aae29f1169fad8c56ff12144eec001d30-ts%3D1662707539" alt="img" style="zoom:50%;" />

API 게이트웨이는 내부 애플리케이션 아키텍쳐를 캡슐화하고 자신의 클라이언트에는 API를 제공합니다.

요청 라우팅, API 조합, 프로토콜 변환(protocal trasnlation)을 관장합니다.

외부 클라이언트의 API요청은 모두 API 게이트웨이로 향하고, API 게이트웨이는 적절한 서비스로 요청을 보냅니다. 여러 서비스의 호출 결과를 취합하는 API 조합 패턴 방식으로 요청을 처리하기도 하며, 클라이언트에 친화적인 프로토콜과 비친화적인 프로토콜 간 변환도 합니다.



**요청 라우팅**

**API 조합**



**프로토콜 변환**

REST <---> gRPC 혼용할 경우 외부 클라이언트에는 REST API를 제공할 수 있습니다.



**API 게이트웨이는 클라이언트마다 적합한 API를 제공한다.**

API 게이트웨이는 만능 API를 제공합니다. 개별 API는 각기 다른 클라이언트마다 요건도 천차만별이라는 문제가 있습니다. 

 그러므로, API 게이트웨이가 각 클라이언트에 맞춤 API를 제공하는 방법이 좋습니다. 이를테면 모바일 클라이언트에는 모바일 요건에 맞게 설계된 API를 제공하는 것입니다.



**엣지 기능 구현**

API 게이트웨이는 요청 라우팅, API 조합 등의 주요 기능뿐만 아니라 edge function 을 처리합니다.

> 애플리케이션 주변에 구현된 요청 처리 기능

- 인증(authentication)
- 인가(authorization)
- 사용량 제한(rate limiting)
- 캐싱(caching)
- 지표 수집(metrics collection)
- 요청 로깅: 요청을 기록



엣지 기능이 구현된 곳은 세 군데입니다.

1. 백엔드 서비스
2. 외부 클라이언트와 직접 맞닿은 API 게이트웨이의 상류(upstream)
3. 전용 엣지 서비스입니다. 관심사가 분리되는 큰 장점이 있으며, API 게이트웨이는 API 라우팅/조합에 집중하고 중요한 엣지 기능을 중앙화할 수 있습니다.



### API 게이트웨이 아키텍쳐

API 게이트웨이는 API 계층과 공통 계층으로 구성된 모듈 아키텍쳐 구조입니다. API 계층에는 독립적인 하나 이상의 API 모듈이 있고, 각 API 모듈에는 특정 클라이언트용 API가 구현되어 있습니다.

 <img src="https://documents.lucid.app/documents/a6b2e07d-a201-4959-8dad-8c191ba78039/pages/0_0?a=29524&x=-8777&y=21722&w=1204&h=836&store=1&accept=image%2F*&auth=LCA%208af416af544e00808d82d7067605c89b0744dc7d-ts%3D1662707539" alt="img" style="zoom:50%;" />

위 그림은 전형적인 API 게이트웨이의 계층적 모듈 아키텍처 구조이다. 클라이언트별 API는 별도 모듈로 구현하고, 인증처럼 API 에 필요한 기능은 공통 계층에 구현한다.



**API 게이트웨이 소유권 모델**

API 게이트웨이 개발/운영은 누가할 것인가?

전담할 팀을 따로 신설하는 것이다.

또는 넷플릭스에서 권장하는 바는 API가 표출된 모듈은 해당 클라이언트 팀(모바일, 웹, 퍼블릭 API)팀이 소유하는 구조가 바람직하다. API 게이트웨이 팀은 공통 모듈 개발 및 게이트웨이 운영 이슈에 집중.

이 소유권(ownership) 모델에 따르면 API를 개발한 팀별로 권한을 부여합니다. API 변경할 일이 생기면 해당 팀이 변경된 소스를 API 게이트웨이 소스 리포지터리에 체크인합니다. API 게이트웨이 배포 파이프라인을 완전히 자동화해야만 매끄럽게 협업이 진행됩니다.



**프론트엔드 패턴을 위한 백엔드**

<img src="https://documents.lucid.app/documents/a6b2e07d-a201-4959-8dad-8c191ba78039/pages/0_0?a=29878&x=-9002&y=22663&w=1358&h=1274&store=1&accept=image%2F*&auth=LCA%202dbe8352fd3547567b6d275eaff829b660c99bea-ts%3D1662707539" alt="img" style="zoom:50%;" />

각 클라이언트마다 API 게이트웨이를 따로 두는 Backends For Frontends 패턴을 적용합니다. 

왜 이렇게 해야되는가? 책임 소재가 불분명한 문제와 API 게이트웨이 팀이 관리가 어려워지는 문제점이 발생하기 때문입니다.

BFF 를 적용하게 된다면 아래와 같은 그림이 됩니다.

 <img src="https://documents.lucid.app/documents/a6b2e07d-a201-4959-8dad-8c191ba78039/pages/0_0?a=30088&x=-7540&y=22663&w=1320&h=1274&store=1&accept=image%2F*&auth=LCA%201691d847a20a3855ae56952b48e0215bf2f5fb9a-ts%3D1662707539" alt="img" style="zoom:50%;" />

공통 기능이 중복될 우려가 있으므로 모든 API 게이트웨이에 동일한 기술 스펙을 적용하는 것이 좋습니다. 공통 기능은 API 게이트웨이 팀이 개발한 라이브러리입니다.



## API 게이트웨이의 장단점

장점은?

애플리케이션의 내부 구조를 캡슐화하는 것이다. 클라이언트가 특정 서비스를 호출할 필요없이 무조건 게이트웨이에 이야기를 하면 된다.



단점은?

 개발, 배포, 관리해야 하는 고가용 컴포넌트가 하나 더 늘어나는 부담을 감수해야 한다. API 게이트웨이가 개발 병목 지점이 될 우려가 있다. 자신의 서비스 API를 표출하려면 반드시 API 게이트웨이를 업데이트해야 하는데, 그 프로세스가 가볍지 않으면 여러 개발자가 길게 줄을 서서 기다리게 될 것이다.



## API 게이트웨이 사례



### 넷플릭스

???





## API 게이트웨이 설계시 고려해야할 이슈

- 성능과 확장성
- 리액티브 프로그래밍 추상체를 이용하여 관리 가능한 코드 작성
- 부분 실패 처리
- 애플리케이션 아키텍처에서 선량한 시민 되기



### 성능과 확장성

 API 게이트웨이에 동기 I/O 를 사용할 것인가? 비동기 I/O를 사용할 것인가 하는 문제는 중요한 결정 사항이다.

// TODO 그 그림 넣기



### 리액티브 프로그래밍 추상체

### 부분 실패 처리

 API 게이트웨이는 확장도 가능해야 하지만 안정적으로 동작해야 한다. 부하 분산기 후면에 여러 게이트웨이 인스턴스를 두고 가동하면 된다. 어느 인스턴스가 빌패하면 부하 분산기가 알아서 요청을 다른 인스턴스에 라투이할 것입니다.

### 아키텍쳐의 선량한 시민 되기

 서비스 디스커버리 패턴을 이요하여 API 게이트웨이 같은 서비스 클라이언트가 자신이 호출할 서비스 인스턴스의 네트워크 워치를 파악할 수 있습니다. 관측성 패턴을 활용하면 개발자가 애플리케이션 동작 상태를 모니터링하고 문제를 진단하는데 도움이 된다.



## API 게이트웨이 구현

- 요청 라우팅
- API 조합
- 엣지 기능
- 프로토콜 변환



구현 방식은 2가지로 나눠진다.

1. 기성(off-the-shelf) API 게이트웨이 제품/서비스를 활용
2. API 게이트웨이 프레임워크 또는 웹 프레임워크를 기반으로 API 게이트웨이를 직접 개발







https://junhyunny.github.io/architecture/pattern/backend-for-frontend/



