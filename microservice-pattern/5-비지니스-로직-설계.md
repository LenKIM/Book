# 비지니스 로직 설계

 엔터프라이즈 애플리케이션은 무엇일까?



왜 마이크로 아키텍처는 복잡한 비즈니스 로직을 개발하기 어려울까?

1. 도메인 모델은 대부분 상호 연관된 클래스가 거미줄처럼 뒤얽혀 있다. 모놀리식 에서는 문제되지 않지만, 서비스 경계가 명확한 마이크로서비스에서는 장애물 중 하나이다.
2. 마이크로서비스 아키텍쳐 특유의 트랜잭션 관리 제약 조건하에서도 작동되는 비즈니스 로직을 설계해야 한다. 

**= 서비스 비즈니스 로직을 여러 애그리거트로 구성하는 DDD 애그리거트 패턴으로 해결할 수 있다**

- 애그리거트를 사용하면 객체 레퍼런스가 서비스 경계를 넘나들 일이 없습니다. 객체 참조대신 기본키(PK)를 이용하여 애그리거트가 서로 참조하기 때문이다.
- 한 트랜잭션으로 하나의 애그리거트만 생성/수정할 수 있다. 따라서 애그리거트는 마이크로서비스 트랜잭션 모델의 제약 조건에 잘 맞는다.



## 비즈니스 로직 구성 패턴

'비즈니스 로직을 객체 지향적 방식으로 개발할 것인가? 절차적인 방식으로 개발할 것인가?' 하는 문제가 있다.

비즈니스 로직은 절차적 트랜잭션 스크립트 패턴과 객체 지향적 도메인 모델 패턴, 두 가지 패턴으로 구성된다.

### 트랜잭션 스크립트 패턴

> 비즈니스 로직을 요청 타입별로 하나씩 매핑된 절차적 트랜잭션 스크립트 뭉치로 구성

 비즈니스 로직을 트랜잭션 스크립트로 구성하면, 트랜잭션 스크립트 기반으로 설계하면 일반적으로 동작을 하는 클래스와 상태를 보관하는 클래스로 구성된다.

 <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4tuzk8ml0j20m60gi3z7.jpg" alt="img" style="zoom:50%;" />



### 도메인 모델 패턴

  객체 지향적으로 설계한 비즈니스 로직은 비교적 작은 클래스가 그물망처럼 읽힌 객체 모델로 구성된다. 이런 클래스는 제각기 문제 영역(probloem domain) 개념에 직접 대응된다.

 상태, 동작 둘 중 하나만 있는 클래스도 있지만 대부분은 상태/동작 모두 갖고 있습니다. 이것이 잘 설계된 클래스의 특징이다.



비즈니스 로직을 도메인 모델로 구성. 비즈니스 로직은 대부분 상태와 동작을 가진 클래스로 구성된다.

 <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4tv7njrjmj20y40jawfy.jpg" alt="img" style="zoom:50%;" />





### 도메인 주도 설계 개요

- Entitiy
- Value Object
- Factory - 일반 생성자로 직접 만들기에 족잡한 객체 생성 로직이 구현된 객체 또는 메서드, 인스턴스로 생성할 구상 클래스를 감출 수 있으며, 클래스의 정척 메서드로 구현할 수 있다.
- Repository
- Serivce



## 도메인 모델 설계: DDD 애그리거트 패턴

 ![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h4tvj6wg4lj219y0i4ta8.jpg)



 **이것은 불분명한 경계 문제가 된다.**

Order 라는 비즈니스 객체에 어떤 작업을 수행한다고 합시다. 정확히 무슨 작업을 하는 것이고, 그 범위는 어디까지 일까?

경계가 분명하지 않으면 비즈니스 객체를 업데이트할 때 문제가 생긴다. 

#### 불분명한 경계 문제를 명확하게 하기 위해 애그리거트를 사용한다.

**도메인 모델을 여러 애그리거트로 구성한다. 각 애그리거트는 한 단위로 취급가능한 객체망이다.**

![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h4tvs4is1oj214c0le40j.jpg)

애그리거트는 한 단위로 취급 가능한 경계내부의 도메인 객체들. 하나의 루트 엔티티와 하나 이상의 기타 엔티티 + 벨류 로 구성된다.

 **애그리거트는 일관된 경계를 가진다.**

일관된 경계를 가진다는 것은 어떤 의미일까?

 업데이트 작업이 필요하다면 애그리거트 루트에서 호출되기 때문에 불편 값이 강제되고, 동시성 역시 애그리거트 루트(버전 번호나 DB 수준의 락으로) 잠금하여 처리한다.

**애그리거트를 식별하는 일이 관건이다.**

DDD 도메인 모델 설계의 핵심은 애그리거트와 그 경계, 그리고 루트를 식별하는 것이다. 내부 상세 구조는 부차적인 문제이다. 그러나 애그리거트는 정해진 규칙을 반드시 준수해야 하기 때문에 도메인 모델의 모듈화뿐만 아니라 장점도 무궁무진하다.



### 애그리거트 규칙

*규칙#1: 애그리거트 루트만 참조하라*

 ![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h4udvoj20bj20k60hqmxz.jpg)

**Order 가 아닌 OrderLineItem 을 직접 건들이면 왜 안될까?**

위에서 설명한 것과 같이 일관된 경계를 갖기 위해서는 어그리거트 루트로만 접근해야 한다.



*규칙#2: 애그리거트 간 참조는 반드시 기본키를 사용하라.*

 왜 반드시 기본키를 사용해야 하는 걸까? 기본키를 사용하면

- 애그리거트가 느슨하게 결합되고 애그리거트 간 경계가 분명해지기 때문에 혹여 실수로 다른 애그리거트를 업데이트할 일은 일어나지 않습니다. 또 애그리거트가 다른 서비스의 일부인 경우에도 여러 서비스에 걸친 객체 레퍼런스 문제는 없다.

*규칙#3: 하나의 트랜잭션으로 하나의 애그리거트를 생성/수정하라.*

 하나의 트랜잭션으로 오직 하나의 애그리거트만 생성/수정해야 한다. 이 조건을 충족하기 위해서는 여러 애그리거트를 생성/수정하는 작업을 구현하기가 조금 복잡해진다. 이것을 해결하는 것이 바로 **사가**. 사가의 각 단계는 정확히 애그리거트 하나를 생성/수정한다.



애그리거트 경계는 고정 불편이 아니다. 도메인 모델을 개발할 때에는 경계선을 어디에 그을지 잘 선택해야 한다.



### 애그리거트 입도

애그리거트의 크기는 어떻게 결정하는게 좋을까?

책에서는 일단 애그리거트가 작으면 좋다라고 한다. 

작게 잡으면, 동시 처리 가능한 요청 개수가 늘고 확장성이 좋아진다. 또한 두 사용자가 동시에 같은 애그리거트를 업데이트하더라도 충돌할 가능성이 줄기 때문에 UX면에서도 좋다. 하지만 애그리거트 자체가 곧 트랜잭션의 범위라서 어떤 업데이트를 원자적으로 처리하려면 애그리거트를 크게 잡아야 할 수도 있다.

**그렇다면 만약, 크게 잡으면 어떻게 되는걸까?**

 ![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h4uefhqn5yj215k0r0mzc.jpg)



확장성이 떨어지는 단점이 있다. 동일한 고객의 상이한 주문을 업데이트하는 트랜잭션이 직렬화된다. 마찬가지로 두 사용자가 동일한 고객의 상이한 주문을 고치려고 하면 충돌이 난다.



## 도메인 이벤트 발행

도메인 이벤트란 엇인가?

**이벤트라는 용어를 찾아보면 다음과 같다.**

1. Something that happens(뭔가 일어난 것)
2. A noteworthy happening(주목할 만한 사건)
3. A social occasion or activity(사교적 행사나 활동)
4. An adverse or damaging medical occurrence. a heart attach or other cariac event(건가에 안좋거나 손상을 일으키는 의료 사고. 심장 마비 등 심장 관련 사고)



**DDD 에서 도메인 이벤트는 애그리거트에 발생한 사건이다.**

예를 들어 Order 애그리거트라면, 주문 생성됨, 주문 취소됨, 주문 배달됨 등 상태가 바뀌는 이벤트가 발생한다.

애그리거트는 상태가 전이될때마다 이에 관련된 컨슈머를 위해 이벤트를 발행합니다.



**그럼 왜 변경 이벤트(도메인이벤트)을 발행해야 될까?**

바로 누군가가 상태 변경을 궁금해 하기 때문에 유용하다.

예를 들면 다음과 같다.

- 코레오그래피 사가를 이용하여 여러 서비스에 걸쳐 데이터 일관성을 유지한다.
- 레플리카에 둔 서비스에 소스 데이터가 변경되었음을 알린다.
- 미리 등록된 웹훅(webhook)이나 메세지 브로커를 통해 비즈니스 프로세스의 다음 단계를 진행하도록 다른 애플리케이션에 알릴 수 있다.
- 사용자 브라우저에 웹 소켓 메시지를 보내거나, 엘라스틱서치 같은 텍스트DB를 업데이트 하기 위해 같은 애플리케이션의 다른 컴포넌트에 알린다.
- 사용자에게(텍스트 메시지나 이메일로) 알린다. '주문한 상품이 배달되었다. 처방전이 준비되어 받아 갈 수 있다.' 등의 사실을 알릴 수 있다.
- 애플리케이션이 제대로 작동되고 있는지 도메인 이벤트를 모니터링하면서 확인한다.
- 사용자 행동을 모델링하기 위해 이벤트를 분석한다.



**여기서 변경 이벤트는 도메인 이벤트라 했다. 도메인 이벤트란 무엇일까?**

도메인 이벤트는 과거 분사형 동사로 명명한 클래스이다. 이벤트에 의미를 부여하는 프로퍼티가 있는데, 프로퍼티는 원시 값(primitive value) 또는 밸류 객체(value object) 이다. 가령 OrderCreated 이벤트 클래스에는 orderId 프로퍼티가 있다.





