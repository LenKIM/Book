트랜잭션 관리: 사가

## 1. 마이크로서비스 아키텩처에서의 트랜잭션 관리

마이크로서비스에서 가장 큰 고민은 바로 트랜잭션이다.

**트랜잭션 없이 데이터일관성을 유지한다는 건 힘들다.**



여러 서비스에 걸친 **작업의 일관성을 유지하려면 기존 모놀리식 아키텍쳐에서는 ACID 대신 사가(saga)라는 메시지 주도(message-driven) 방식**의 로컬 트랜잭션을 사용해야 한다.



사가는 ACID 중 I(격리성)이 빠진 ACD만 지원하고 격리가 되지 않기 때문에 동시 비정상(concurrency anomaly)의 영향을 방지하거나 줄일 수 있는 설계 기법(countmeasure)을 적용해야 한다.

> ACID 란?
>
> 원자성(Atomicity) - 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장하는 것(All or Nothing)
>
> 일관성(Consistency) - 트랜잭션이 성공적으로 완료되면 일관적인 DB 상태를 유지하는 것. 일관적이란 표현은 데이터의 타입이 전 후가 동일해야 한다는 의미이다.
>
> 격리성(Isolation) - 트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것. 즉 서로 간섭 할 수 없음
>
> 지속성(Durability) - 성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것을 말함.



### 1.1 어떻게 마이크로서비스 아키텍쳐에서는 트랜잭션을 관리하는가?

우리가 자주 사용하는 스프링부트는 어떠한가?

**@Transactional** 로 트랜잭션을 관리하지 않던가? 이는 선언형 메커니즘이라 한다. 하나의 어플리케이션, 하나의 모놀리식에서는 트랜잭션이 문제되지 않는다. 

그러나, 마이크로서비스 아키텍쳐에서는 어렵다.

**왜?**

아무리 **분산 트랜잭션(대표적으로는 two-phase commit)**이 지원되는 상황이더라도, 지원하지 않는 솔루션이 많다. 카프카,NoSQL 

 <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4kmathwq1j20nf0howfe.jpg" alt="img" style="zoom: 67%;" />

> Two-phase commit 이란 무엇일까?
>
> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4mb6eu7qbj20kv078mxo.jpg" alt="TWO-PHASE COMMIT 이란? | 개발자 이동욱" style="zoom:67%;" />
>
> 분산 시스템에서 트랜잭션을 변경할 수 있는 기능을 제공하는 방식이다.
>
> 2PC 은 투표(prefare) 단계와 커밋(commit) 단계라는 두 단계로 나눈다. 투표 단계에서는 Coordinator가 거래의 일부가 될 모든 대상 서비스에 직접 연결하여 상태 변경이 가능한지 확인 요청한다.
>
> 예를 들어, Database 1 의 한 Row 와 Database 2 의 한 Row 에게 삭제요청을 보냈다. Database1 과 Database2 의 Row 에 Lock 을 잡아놓고, 두 곳 모두 가능하다는 투표 결과가 오면 상태를 변경하고 다음 단계로 넘어간다. 
>
> (만약 두 곳 중 어느 곳이 불가하다는 투표가 나온다면, 트랜잭션을 중단한다)
>
> Commit 단계에서 두 DB에게 삭제 메세지를 전달한다. 각각의 DB는 메세지에 따른 액션을 취한다.



Coordinator의 관리 방식에서 벗어나는 방법, 서비스간 Lock을 피하는 방법, 대기시간을 줄일 수 있는 방법을 벗어날 수 있는 방법을 고안해야 한다. 또한 분산 트랜잭션을 지원하지 않는 서비스에서는 어떻게 해야될까?

 분산 트랜잭션을 사용하지 않고 메시지를 DB 트랜잭션의 일부로 전송하는 방법(트랜잭셔널 아웃박스)을 사용하거나, **사가를** 사용합니다.



### 1.2 사가패턴

- **사가**는 마이크로서비스 아키텍처에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 메커니즘
- **여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의한다. 사가는 일련의 메세지를 활용한 로컬 트랜잭션이다. 사가를 활용해 데이터 일관성을 유지한다.**
- 비동기 메세징은 하나 이상의 사가 참여자가 일시 불능 상태인 경우에도 사가의 전체 단계를 확실히 실행시킬 수 있는 중요한 장점이 있다.



#### 어떻게 사가 패턴을 사용하는 걸까?

 <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4kml1ij6cj214c0fwabo.jpg" alt="img" style="zoom:67%;" />

1. 주문 서비스: 주문을 **APPROVAL_PENDING** 상태로 생성(주문 생성)
2. 소비자 서비스: 주문 가능한 소비자인지 확인(소비자 확인)
3. 주방 서비스: 주문 내역을 확인하고 티켓을 **CREATE_PENDING** 상태로 생성(티켓 생성)
4. 회계 서비스: 소비자 신용카드를 승인(신용카드 승인)
5. 주방 서비스: 티켓 상태를 AWAITING_ACCEPTANCE 를 변경(티켓 승인)
6. 주문 서비스: 주문 상태를 APPROVED 로 변경(주문 승인)



사가는 각각의 참여자를 느슨하게 결합하고 사가가 반드시 완료되도록 보장하는 것이다.

그러나, 만약 도중에 에러가 발생하면 어떻게 롤백할까?

**사가는 보상 트랜잭션으로 변경분을 롤백한다.**

그러나, 모든 트랜잭션에 보상트랜잭션을 적용할 필요는 없다. 

오직 Txn:1 과 Txn:3 이 보상 트랜잭션을 발행할 수 있다. 

*1.주문 서비스: 주문을 APPROVAL_PENDING 상태로 생성* 

*3.주방 서비스: 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성*

--

5. 주방 서비스: 티켓 상태를 AWAITING_REJECTED 를 변경(티켓 거절)

6. 주문 서비스: 주문 상태를 REJECTED 로 변경(주문 취소)

   

**왜 일까?**

DB 의 변화가 온 트랜잭션은 어디일까? 변경분이 발생한 곳은 어디일까? 바로 1, 3번 뿐이다.

그러므로, 보상 트랜잭션을 일으켜야 한다면, 1과 3번에 대응되는 DB 업데이트 밖에 없을 것이다.

그 외는 어떤지 살펴보면, *2.소비자 서비스: 주문 가능한 소비자인지 확인(소비자 확인)* 의 경우는 단순히 Read 만 하는 상태이고, *4.회계 서비스: 소비자 신용카드를 승인(신용카드 승인)* 는 앞에 1,3 이 정상 동작되어야지만 동작하는 부분이다.



위 예시를 통해 알 수 있는 것이 **트랜잭션에도 종류가 있다.** 라는 것이다.

- **보상 트랜잭션(Compensatable transaction)**  
  : 보상 트랜잭션으로 롤백 가능한 트랜잭션
- **피봇 트랜잭션(Pivot transaction)**  
  : 사가의 진행/중단 지점. 피복 트랜잭션이 커밋되면 사가는 완료될 때까지 실행된다. 피봇 트랜잭션은 보상 가능 트랜잭션, 재시도 가능한 트랜잭션 그 어느쪽도 아니고, **최종 보상 가능 트랜잭션** 또는 **최초 재시도 가능 트랜잭션이** 될 수 있다.
- **재시도 가능 트랜잭션(retriable transaction)**  
  : 피봇 트랜잭션 직후의 트랜잭션, 반드시 성공한다.

다시 위의 순서도를 가져오면 다음과 같다.

| 단계 | 서비스        | 트랜잭션              | 보상트랜잭션   | 재시도 가능 트랜잭션 | 피봇트랜잭션 |
| ---- | ------------- | --------------------- | -------------- | -------------------- | ------------ |
| 1    | 주문 서비스   | createOrder()         | rejectOrder()  | X                    | X            |
| 2    | 소비자 서비스 | verifyConsumerDetails | X              | X                    | X            |
| 3    | 주방 서비스   | createTicket()        | rejectTicket() | X                    | X            |
| 4    | 회계 서비스   | authorizeCreditCard() | X              | X                    | O            |
| 5    | 주방 서비스   | approveTicket()       | X              | O                    | X            |
| 6    | 주문 서비스   | approveOrder()        | X              | O                    | X            |



# 2. 사가 편성

 사가를 구성하는 방식에도 두 종류가 있다.

**2.1 코레오그래피(choreography: 댄서)**  
의사 결정과 순서화를 사가 참여자에게 맡깁니다. 사가 참여자는 주로 이벤트 교환 방식으로 통신한다.

**2.2 오케스트레이션(orchestraction: 지휘자)**  
사가 편성 로직을 사가 오케스트레이터에 중앙화합니다. 사가 오케스트레이터는 사가 참여자에게 커멘트 메시지를 보내 수행할 작업을 지시한다.



코레오그래피 방식은 각각의 참여자에게 책임을 위임하는 것입니다.

 <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4kohn6l3aj21ic0s20vw.jpg" alt="img" style="zoom:67%;" />

1. **주문 서비스** - 주문을 APPROVAL_PENDING 상태로 생성 > 주문 생성 이벤트 발행
2. **소비자 서비스** - 주문 생성 이벤트 수신 > 소비자가 주문을 할 수 있는지 확인 > 소비자 확인 이벤트 발행
3. **주방 서비스** - 주문 생성 이벤트 수신 > 주문 내역 확인 > 티켓을 CREATE_PENDING 상태 생성 > 티켓 생성됨 이벤트 발행
4. **회계 서비스** - 주문 생성 이벤트 수신 > 신용카드 승인을 PENDING 상태 생성
5. **회계 서비스** - 티켓 생성 및 소비자 확인 이벤트 수신 > 소비자 신용카드 과금 > 신용카드 승인됨 이벤트 발행
6. **주방 서비스** - 신용카드 승인 이벤트 수신 > 티켓 상태 AWAITING_ACCEPTANCE 로 변경
7. **주문 서비스** - 신용카드 승인됨 이벤트 수신 > 주문 상태 APPROVED 변경 > 주문 승인됨 이벤트 발행



만약에 어떤 사가 참가자가 주문을 실패해서 실패 이벤트가 발행되면?

1. **주문 서비스** - 주문을 APPROVAL_PENDING 상태로 생성 > 주문 생성 이벤트 발행
2. **소비자 서비스** - 주문 생성 이벤트 수신 > 소비자가 주문을 할 수 있는지 확인 > 소비자 확인 이벤트 발행
3. **주방 서비스** - 주문 생성 이벤트 수신 > 주문 내역 확인 > 티켓을 CREATE_PENDING 상태 생성 > 티켓 생성됨 이벤트 발행
4. **회계 서비스** - 주문 생성 이벤트 수신 > 신용카드 승인을 PENDING 상태 생성
5. **회계 서비스** - 티켓 생성 및 소비자 확인 이벤트 수신 > 소비자 신용카드 과금 >🔥 **신용카드 승인 실패 이벤트 발행** // Look At this !!
6. **주방 서비스** - 신용카드 승인 이벤트 수신 > 티켓 상태 REJECTED 로 변경
7. **주문 서비스** - 신용카드 승인됨 이벤트 수신 > 주문 상태 REJECTED 변경



코레오그래피 사가는 문제점이 있다. 

확실한 이벤트 기반의 통신을 하기 위해서는 아래 두 가지 문제를 고려해야 한다.

1. 사가 참여자가 자신의 DB 를 업데이트하고, DB 트랜잭션의 일부로 이벤트를 발행하도록 해야 한다. 해결하기 위해서는 트랜잭셔널 메시징를 사용한다.
2. 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관 지을 수 있어야 한다.



*장점은 다음과 간다.*

1. 단순함 - 비즈니스 객체를 생성,수정,삭제할 때 서비스가 이벤트를 발행한다.
2. 느슨한 결함 - 참여자는 이벤트를 구독할 뿐 서로를 직접 알지 못한다.



*단점*으로는 다음과 같다

1. 이해하기 어렵다. - 여러 서비스에 구현 로직이 흩어져 있기 때문에.
2. 서비스 간 순환 의존성 - 잠재적인 설계 취약점이 될 수 있다.
3. 단단히 결합될 위험성 - 사가 참여자는 각자 자신에게 영향을 미치는 이벤트를 모두 구독해야 한다.



## 오케스트레이션 사가란?

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4kp3yli70j213w0u0wgp.jpg" alt="img" style="zoom:80%;" />

1. 사가 오케스트레이터가 소비자 확인 커맨드를 소비자 서비스에 전송
2. 소비자 서비스는 소비자 확인 메시지 응답
3. 사가 오케스트레이터는 티켓 생성 커맨드를 주방 서비스에 전송
4. 주방 서비스는 티켓 생성 메시지를 응답
5. 사가 오케스트레이터는 신용카드 승인 메시지를 회계 서비스에 전송
6. 회계 서비스는 신용카드 승인됨 메시지를 응답
7. 사가 오케스트레이터는 티켓 승인 커멘드를 주방 서비스에 전송
8. 사가 오케스트레이터는 주문 승인 커맨드를 주문 서비스에 전송



이렇게 표현하는 것은 완전 해피케이스의 경우이다. 만약 소비자 서비스, 주방 서비스, 회계 서비스 한 곳에 오류가 발생한다면? 어떻게 해야될까? 롤백 트랜잭션을 발급해야 되는가? 아니다. 주문 사가 오케스트레이터가 각각에 맞게 대응해줘야 한다. 그러므로, 가능한 모든 시나리오를 기술하는 상태 기계로 사가를 모델링하면 유용하다.

 ![img](https://tva1.sinaimg.cn/large/e6c9d24egy1h4sqwpubsuj20zo0u0myf.jpg)





장점으로는,

- **의존 관계 단순화** > 순환 의존성이 발생하지 않는다. 즉, 오케스트레이터는 참여자에게 의존하지만 그 반대는 성립되지 않으므로 순환 의존성이 발생하지 않는다.
- **낮은 결합도** > 각 서비스는 오케스트레이터가 호출하는 API를 구현할 뿐 사가 참여자가 발행하는 이벤트는 몰라도 된다.
- **관심사를 더 분리하고 비지니스 로직을 단순화** 

단점으로는, 

- **비지니스 로직을 오케스트레이터에 너무 많이 중앙화하면 똑똑한 오케스트레이터 하나가 깡통 서비스에 일일이 지시하는 모양이 된다.**
-  그 외 단점이 무엇이 있을까?



# 3. 비격리 문제 처리

앞서 언급한 것과 같이 마이크로서비스는 ACID 중 I(격리성) 가 빠진 상태이다. 사가를 사용하면, 이 문제를 해결할 수 있지는 않다. 여전히 I 가 빠진 상태이다. 다만 **사가 그 자체가 ACD 가 된다.**

- 원자성 - 사가는 트랜잭션을 모두 완료하거나 모든 변경분을 언두해야 한다.
- 일관성 - 서비스 내부의 참조 무결성은 로컬 DB가, 여러 서비스에 걸친 참조 무결성은 서비스가 처리합니다.
- 지속성 - 로컬 DB로 처리한다.



I(격리성)이 빠짐으로서 비정상(anomaly)이 발생할 수 있다.

- 소실된 업데이트(lost updates)  
  : 한 사가의 변경분을 다른 사가가 미처 못 읽고 덮어 씁니다.
- 더티 읽기(dirty reads)  
  : 사가 업데이트를 하지 않는 변경분을 다른 트랜잭션이나 사가가 읽습니다.
- 퍼지/반복 불가능한 읽기(fuzzy/nonrepeatable reads)  
  : 한 사가의 상이한 두 단계가 같은 데이터를 읽어도 결과가 달라지는 현상. 다른 사가가 그 사이 업데이트를 했기 떄문에 생기는 문제.



#### 소실된 업데이트(lost updates)는

 예를 들어 2개의 사가가 있다고 가정하자.

하나의 서비스에 2개의 사가가 접근하여 데이터 변경을 시도할 경우, 한 사가의 변경분이 다른 사가의 변경을 무시하고 덮어 쓸 수 있게 된다.

#### 더티 읽기(dirty reads)  

 한 사가가 업데읕 중인 데이터를 다른 사가가 읽을 때 발생한다. 예를 들어, A,B 사가가 있다. A의 사가가 1이라는 주문서비스를 Apporval 했는데,  A의 사가는 아직 끝나지 않았음에도 불구하고, 중간에 B의 사가가 1이라는 주문서비스를 Read 하게 된다.



### 어떻게 해결해야 될까?

- 시맨틱 락

이런 문제를 해결하기 위해서 약간의 트릭을 사용하여 비즈니스에 미치는 영향을 최소화하는 방향으로 사가를 작성해야 할 것입니다.  **이미 일전에 보았던 *_PENDING 상태와 같은 플러그를 세팅하는 전략** 또한 이상현상을 예방하는 전략 중 하나입니다. 이는 **시맨틱 락** 이라고 합니다.



그 외에도 다음과 같은 방법이 있습니다.

- 교환적 업데이트(commutative updates)  
  : 업데이트 작업은 어떤 순서로 실행해도 되게끔 설계합니다. 예를 들어 Account debit() 과 credit() 처럼 만드는 것이다.
- 비관적 관점(pessimistic view)  
  **: 사가 단계 순서를 재조정하여 비즈니스 리스크를 최소화합니다.** 
  
  - 회계 서비스: 신용 잔고를 늘립니다.
  - 주문 서비스: 주문을 취소 상태로 변경합니다.
  - 배달 서비스: 배달을 취소합니다.
  
  위와 같은 사가의 경우에 주문 취소 사가가 주문 생성 사가 서로 겹쳐 실행될 경우 다음과 같은 경우가 발생할 수 있다.
  
  - 주문 취소 사가: 신용 잔고를 늘립니다.
  - 주문 생성 사가: 신용 잔고를 줄입니다.
  - 주문 취소 사가: 신용 잔고를 줄이는 보상 트랜잭션이 가동됩니다.
  
  --
  
  비관적 관점에서 위험성을 줄일 수 있습니다.
  
  - 주문 서비스: 주문을 취소 상태로 변경합니다.
  - 배달 서비스: 배달을 취소합니다.
  - **회계 서비스: 신용 잔고를 늘립니다.**



- 값 다시 읽기(reread value)  
  : 데이터를 덮어 쓸 때 그 전에 변경된 내용은 없는지 값을 다시 읽고 확인하여 더티 쓰기(dirty writes)를 방지합니다. 낙관적 오프라인 락 패턴과 유사합니다. 데이터를 업데이트 하기전에 값을 다시 읽어 변경되었는지 확인합니다.
- 버전 파일(version file)  
  : 순서를 재조종할 수 있게 업데이트를 기록합니다.
- 값에 의한(by value)  
  : 요청별 비즈니스 위험성을 기준으로 동시성 메커니즘을 동적 선택합니다.



**교환적 업데이트(commutative updates)**

Account 의 debit() 과 credit() 은 서로 교환적인 작업이다. 그러므로, 어떤 소실된 업데이트가 발생하더라도 문제를 해결할 수 있다.



**비관점 관점(pessimisic view)**

 더티 읽기로 인한 비즈니스 리스크를 최소화하기 위해 **사가 단계의 순서를 재조정합니다.**

예를 들어 다음과 같은 더티 읽기가 발생합니다.

**주문 취소 사가**

- 회계 서비스 : 신용 잔고(available credit) 를 늘림
- 주문 서비스: 주문을 취소 상태로 변경
- 배달 서비스: 배달을 취소

이 때, 만약 주문 취소 사가와 주문 생성 사가의 실행이 겹쳐, 신용잔고를 더치 읽기 할 수 있다.

1. 주문 취소 사가 > 신용잔고 늘림
2. 주문 생성 사가 > 신용 잔고 줄임
3. 주문 취소 사가 > 신용잔고를 줄이는 보상트랜잭션 가동



**주문 취소 사가 단계를 다음과 같이 재조정합니다.**

- 주문 서비스: 주문을 취소 상태로 변경
- 배달 서비스: 배달을 취소
- **회계 서비스 : 신용 잔고(available credit) 를 늘림 // Look At this!!**

이렇게 되면 재시도 가능 트랜잭션에서 증가하므로 더티 읽기 가능성이 사라진다.



**값 다시 읽기(reread value)**  

 소실된 업데이트를 방지하는 대책. 사가가 레코드를 업데이트하기 전에 값을 다시 읽어 값이 변경되지 않았는지 확인하는 것이다. 값을 다시 읽었더니 만약 변경되었다면, 사가를 중단하고 나중에 재시작합니다. 이것은 일종의 낙관적 오프라인 락 패턴입니다.



**버전 파일(version file)**  

레코드에 수행한 작업을 하나하나 기록하는 대책입니다. 즉, 비교환적 작업을 교환적 작업으로 변환하는 방법.

각 순서를 기록하면서, 다음 사가가 동작될 경우 기록을 보고 정확한 순서대로 실행하도록 합니다.



**값에 의한(by value)**  

 애플리케이션 차원에서 각 요청의 속성을 보고 사가를 쓸지, 아니면 분산 트랜잭션을 쓸지 판단. 위험성이 낮은 요청은 사가를 위험성이 높은 요청은 분산 트랜잭션을 실행합니다.



# 4. 주문 서비스 및 주문 생성 사가 설계

```java
//TODO 오케스트레이터 만 표시하기
```

