# 트랜잭션 관리: 사가

## 1. 마이크로서비스 아키텩처에서의 트랜잭션 관리

마이크로서비스에서 가장 큰 고민은 바로 트랜잭션.

**트랜잭션 없이 데이터일관성을 유지한다는 건 힘들다.**



여러 서비스에 걸친 작업의 일관성을 유지하려면 기존 모놀리식 아키텍쳐에서는 ACID 대신 사가(saga)라는 메시지 주도(message-driven) 방식의 로컬 트랜잭션을 사용해야 한다.



사가는 ACID 중 I 가 빠진 ACD만 지원하고 격리가 되지 않기 떄문에 동시 비정상(concurrency anomaly)의 영향을 방지하거나 줄일 수 있는 설계 기법(countmeasure)을 적용해야 한다.

> ACID 란?
>
> 원자성(Atomicity) - 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장하는 것(All or Nothing)
>
> 일관성(Consistency) - 트랜잭션이 성공적으로 완료되면 일관적인 DB 상태를 유지하는 것. 일관적이란 표현은 데이터의 타입이 전 후가 동일해야 한다는 의미이다.
>
> 격리성(Isolation) - 트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것. 즉 서로 간섭 할 수 없음
>
> 지속성(Durability) - 성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것을 말함.



### 1.1 어떻게 마이크로서비스 아키텍쳐에서는 트랜잭션을 관리하는가?

우리가 자주 사용하는 스프링부트는 어떠한가?

@Transactional 로 트랜잭션을 관리하지 않던가? 이는 선언형 메커니즘이라 한다. 하나의 어플리케이션, 하나의 모놀리식에서는 트랜잭션이 문제되지 않는다. 

그러나, 마이크로서비스 아키텍쳐에서는 어렵다.

**왜?**

아무리 분산 트랜잭션(two-phase commit)이 지원되는 상황이더라도, 지원하지 않는 솔루션이 많다.

 <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4kmathwq1j20nf0howfe.jpg" alt="img" style="zoom: 67%;" />

> two-phase commit 이란?
>
> // TODO

그럼 어떻게 해야될까?

분산 트랜잭션을 사용하지 않고 메시지를 DB 트랜잭션의 일부로 전송하는 방법(트랜잭셔널 아웃박스)을 사용하거나, **사가를** 사용합니다.

### 1.2 사가패턴

- 사가는 마이크로서비스 아키텍처에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 메커니즘
- 여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의한다. 사가는 일련의 메세지를 활용한 로컬 트랜잭션이다. 사가를 활용해 데이터 일관성을 유지한다.

#### 어떻게 사가 패턴을 사용할까?

 <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4kml1ij6cj214c0fwabo.jpg" alt="img" style="zoom:67%;" />

1. 주문 서비스: 주문을 APPROVAL_PENDING 상태로 생성
2. 소비자 서비스: 주문 가능한 소비자인지 확인
3. 주방 서비스: 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성
4. 회계 서비스: 소비자 신용카드를 승인
5. 주방 서비스: 티켓 상태를 AWAITING_ACCEPTANCE 를 변경
6. 주문 서비스: 주문 상태를 APPROVED 로 변경



사가는 각각의 참여자를 느슨하게 결합하고 사가가 반드시 완료되도록 보장하는 것이다.

그러나, 만약 도중에 에러가 발생하면 어떻게 롤백할까?

**사가는 보상 트랜잭션으로 변경분을 롤백한다.**

그러나, 모든 트랜잭션에 보상트랜잭션을 적용할 필요는 없다.

1.**주문 서비스: 주문을 APPROVAL_PENDING 상태로 생성** 

3.**주방 서비스: 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성**



오직 1,3 에서만 보상트랜잭션이 필요하다.  왜 일까?

트랜잭션에도 종류가 있다.

- **보상 트랜잭션(Compensatable transaction)**  
  : 보상 트랜잭션으로 롤백 가능한 트랜잭션
- **피봇 트랜잭션(Pivot transaction)**  
  : 사가의 진행/중단 지점. 피복 트랜잭션이 커밋되면 사가는 완료될 때까지 실행된다. 피봇 트랜잭션은 보상 가능 트랜잭션, 재시도 가능한 트랜잭션 그 어느쪽도 아니고, 최종 보상 가능 트랜잭션 또는 최초 재시도 가능 트랜잭션이 될 수 있다.
- **재시도 가능 트랜잭션(retriable transaction)**  
  : 피봇 트랜잭션 직후의 트랜잭션, 반드시 성공한다.

다시 위의 순서도를 가져오면 다음과 같다.

| 단계 | 서비스        | 트랜잭션              | 보상트랜잭션   | 재시도 가능 트랜잭션 | 피봇트랜잭션 |
| ---- | ------------- | --------------------- | -------------- | -------------------- | ------------ |
| 1    | 주문 서비스   | createOrder()         | rejectOrder()  | X                    | X            |
| 2    | 소비자 서비스 | verifyConsumerDetails | X              | X                    | X            |
| 3    | 주방 서비스   | createTicket()        | rejectTicket() | X                    | X            |
| 4    | 회계 서비스   | authorizeCreditCard() | X              | X                    | O            |
| 5    | 주방 서비스   | approveTicket()       | X              | O                    | X            |
| 6    | 주문 서비스   | approveOrder()        | X              | O                    | X            |



# 2. 사가 편성

 사가를 구성하는 방식에도 두 종류가 있다.

2.1 코레오그래피(choreography: 댄서)  
의사 결정과 순서화를 사가 참여자에게 맡깁니다. 사가 참여자는 주로 이벤트 교환 방식으로 통신한다.

2.2 오케스트레이션(orchestraction: 지휘자)  
사가 편성 로직을 사가 오케스트레이터에 중앙화합니다. 사가 오케스트레이터는 사가 참여자에게 커멘트 메시지를 보내 수행할 작업을 지시한다.



코레오그래피 방식은 각각의 참여자에게 책임을 위임하는 것입니다.

 <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4kohn6l3aj21ic0s20vw.jpg" alt="img" style="zoom:67%;" />

1. **주문 서비스** - 주문을 APPROVAL_PENDING 상태로 생성 > 주문 생성 이벤트 발행
2. **소비자 서비스** - 주문 생성 이벤트 수신 > 소비자가 주문을 할 수 있는지 확인 > 소비자 확인 이벤트 발행
3. **주방 서비스** - 주문 생성 이벤트 수신 > 주문 내역 확인 > 티켓을 CREATE_PENDING 상태 생성 > 티켓 생성됨 이벤트 발행
4. **회계 서비스** - 주문 생성 이벤트 수신 > 신용카드 승인을 PENDING 상태 생성
5. **회계 서비스** - 티켓 생성 및 소비자 확인 이벤트 수신 > 소비자 신용카드 과금 > 신용카드 승인됨 이벤트 발행
6. **주방 서비스** - 신용카드 승인 이벤트 수신 > 티켓 상태 AWAITING_ACCEPTANCE 로 변경
7. **주문 서비스** - 신용카드 승인됨 이벤트 수신 > 주문 상태 APPROVED 변경 > 주문 승인됨 이벤트 발행



만약에 어떤 사가 참가자가 주문을 실패해서 실패 이벤트가 발행되면?

1. **주문 서비스** - 주문을 APPROVAL_PENDING 상태로 생성 > 주문 생성 이벤트 발행
2. **소비자 서비스** - 주문 생성 이벤트 수신 > 소비자가 주문을 할 수 있는지 확인 > 소비자 확인 이벤트 발행
3. **주방 서비스** - 주문 생성 이벤트 수신 > 주문 내역 확인 > 티켓을 CREATE_PENDING 상태 생성 > 티켓 생성됨 이벤트 발행
4. **회계 서비스** - 주문 생성 이벤트 수신 > 신용카드 승인을 PENDING 상태 생성
5. **회계 서비스** - 티켓 생성 및 소비자 확인 이벤트 수신 > 소비자 신용카드 과금 > **신용카드 승인 실패 이벤트 발행** // Look At this !!
6. **주방 서비스** - 신용카드 승인 이벤트 수신 > 티켓 상태 REJECTED 로 변경
7. **주문 서비스** - 신용카드 승인됨 이벤트 수신 > 주문 상태 REJECTED 변경

각각의 참여자들이 서로 통신한다.

이렇게 통신할 경우 이슈가 있다.

1. 사가 참여자가 자신의 DB 를 업데이트하고, DB 트랜잭션의 일부로 이벤트를 발행하도록 한다. 해결하기 위해서는 트랜잭셔널 메시징를 사용한다.
2. **사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관 지을 수 있어야 한다.**

*단점*으로는

1. 이해하기 어렵다.
2. 서비스 간 순환 의존성 - 잠재적인 설계 취약점
3. 단단히 결합될 위험성



사가 오케스트레이터는?

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4kp3yli70j213w0u0wgp.jpg" alt="img" style="zoom:80%;" />

1. 사가 오케스트레이터가 소비자 확인 커맨드를 소비자 서비스에 전송
2. 소비자 서비스는 소비자 확인 메시지 응답
3. 사가 오케스트레이터는 티켓 생성 커맨드를 주방 서비스에 전송
4. 주방 서비스는 티켓 생성 메시지를 응답
5. 사가 오케스트레이터는 신용카드 승인 메시지를 회계 서비스에 전송
6. 회계 서비스는 신용카드 승인됨 메시지를 응답
7. 사가 오케스트레이터는 티켓 승인 커멘드를 주방 서비스에 전송
8. 사가 오케스트레이터는 주문 승인 커맨드를 주문 서비스에 전송



장단점

- **의존 관계 단순화**
- **낮은 결합도**
- **관심사를 더 분리하고 비지니스 로직을 단순화**

단점으로는, 비지니스 로직을 오케스트레이터에 너무 많이 중앙화하면 똑똑한 오케스트레이터 하나가 깡통 서비스에 일일이 지시하는 모양이 된다.

저자는 오케스트레이션을 지향하는데, 나는 그렇게 생각하지 않음.

# 3. 비격리 문제 처리

앞서 언급한 것과 같이 마이크로서비스는 ACID 중 I 가 빠진 상태이다. 사가를 사용하면, 이 문제를 해결할 수 있지는 않다. 여전히 I 가 빠진 상태이다. 다만 사가 그 자체가 ACD 가 된다.

- 원자성 - 사가는 트랜잭션을 모두 완료하거나 모든 변경분을 언두해야 한다.
- 일관성 - 서비스 내부의 참조 무결성은 로컬 DB가, 여러 서비스에 걸친 참조 무결성은 서비스가 처리합니다.
- 지속성 - 로컬 DB로 처리합니다.



I 가 빠짐으로서 비정상(anomaly)이 발생할 수 있습니다.

- 소실된 업데이트(lost updates)
- 더티 읽기(dirty reads)
- 퍼지/반복 불가능한 읽기(fuzzy/nonrepeatable reads)



이런 문제를 해결하기 위해서 약간의 트릭을 사용하여 비즈니스에 미치는 영향을 최소화하는 방향으로 사가를 작성해야 할 것입니다.  **이미 일전에 보았던 *_PENDING 상태와 같은 플러그를 세팅하는 전략** 또한 이상현상을 예방하는 전략 중 하나입니다. 이는 **시맨릭 락** 이라고 합니다.

그 외에도 다음과 같은 방법이 있습니다.

- 교환적 업데이트(commutative updates)  
  : 업데이트 작업은 어떤 순서로 실행해도 되게끔 설계합니다.
- 비관적 관점(pessimistic view)  
  : 사가 단계 순서를 재종하여 비즈니스 리스크를 최소화합니다. 
- 값 다시 읽기(reread value)  
  : 데이터를 덮어 쓸 때 그 전에 변경된 내용은 없는지 값을 다시 읽고 확인하여 더티 쓰기(dirty writes)를 방지합니다.
- 버전 파일(version file)  
  : 순서를 재조종할 수 있게 업데이트를 기록합니다.
- 값에 의한(by value)  
  : 요청별 비즈니스 위험성을 기준으로 동시성 메커니즘을 동적 선택합니다.



**교환적 업데이트(commutative updates)**

Account 의 debit() 과 credit() 은 서로 교환적인 작업이다. 그러므로, 어떤 소실된 업데이트가 발생하더라도 문제를 해결할 수 있다.



**비관점 관점(pessimisic view)**

 더티 읽기로 인한 비즈니스 리스크를 최소화하기 위해 **사가 단계의 순서를 재조정합니다.**

예를 들어 다음과 같은 더티 읽기가 발생합니다.

**주문 취소 사가**

- 회계 서비스 : 신용 잔고(available credit) 를 늘림
- 주문 서비스: 주문을 취소 상태로 변경
- 배달 서비스: 배달을 취소

이 때, 만약 주문 취소 사가와 주문 생성 사가의 실행이 겹쳐, 신용잔고를 더치 읽기 할 수 있다.

1. 주문 취소 사가 > 신용잔고 늘림
2. 주문 생성 사가 > 신용 잔고 줄임
3. 주문 취소 사가 > 신용잔고를 줄이는 보상트랜잭션 가동



**주문 취소 사가 단계를 다음과 같이 재조정합니다.**

- 주문 서비스: 주문을 취소 상태로 변경
- 배달 서비스: 배달을 취소
- **회계 서비스 : 신용 잔고(available credit) 를 늘림 // Look At this!!**

이렇게 되면 재시도 가능 트랜잭션에서 증가하므로 더티 읽기 가능성이 사라진다.



**값 다시 읽기(reread value)**  

 소실된 업데이트를 방지하는 대책. 사가가 레코드를 업데이트하기 전에 값을 다시 읽어 값이 변경되지 않았는지 확인하는 것이다. 값을 다시 읽었더니 만약 변경되었다면, 사가를 중단하고 나중에 재시작합니다. 이것은 일종의 낙관적 오프라인 락 패턴입니다.



**버전 파일(version file)**  

레코드에 수행한 작업을 하나하나 기록하는 대책입니다. 즉, 비교환적 작업을 교환적 작업으로 변환하는 방법.

각 순서를 기록하면서, 다음 사가가 동작될 경우 기록을 보고 정확한 순서대로 실행하도록 합니다.



**값에 의한(by value)**  

 애플리케이션 차원에서 각 요청의 속성을 보고 사가를 쓸지, 아니면 분산 트랜잭션을 쓸지 판단. 위험성이 낮은 요청은 사가를 위험성이 높은 요청은 분산 트랜잭션을 실행합니다.

# 4. 주문 서비스 및 주문 생성 사가 설계

