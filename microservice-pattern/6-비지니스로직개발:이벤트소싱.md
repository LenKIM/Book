버그의 원천이 이벤트를 발행하는 것이 되는 것을 염려한다.



이벤트소싱을 사용한다는 것은 애그리거리를 저장하는 또 다른 방법이다. 애그리거트를 일련의 이벤트 형태로 저장한다.
> 이벤트 소싱
> 상태 변화를 나타내는 일련의 도메인 이벤트로 애그리거트를 저장한다.
> 

### 1.1 기존 영속화의 문제
클래스는 DB 테이블에, 클래스 필드는 테이블 칼럼에, 클래스 인스턴스는 테이블 각 로우에 매핑하는 것이 기존 영속화 방식이다.



#### 객체와 관계의 임피던스 부정합

> 온저항(impedance 임피던스)은 회로에서 전압이 가해졌을 때 전류의 흐름을 방해하는 값이다. 

테이블 형태의 관계형 스키마와 관계가 복잡한 리치 도메인 모델의 그래프 구조는 근본적인 개념이 다르다. 

#### 애그리거트 이력이 없다.

기존 영속화 메커니즘은 현재 애그리거트의 상태만 저장한다. 즉, 애그리거트가 업데이트되면 이전 상태는 사라지고 없다. 따라서 애그리거트 이력을 관리 용도로 온전히 보존하려면 개발자가 직접 코드를 구현하는 데 시간이 걸리고, 비즈니스 로직과 동기화해서 하는 코드를 중복 생성하게 된다.



#### 감사 로깅은 구현하기 힘들고 오류도 자주 발생한다.

#### 이벤트 발행 로직이 비즈니스 로직에 추가된다.

기존 영속화의 또 다른 한계는 도메인 이벤트 발행을 지원하지 않는 부분이다. 도메인 이벤트는 애그리거트가 자신의 상태를 변경한 후 발행하는 이벤트이다. MSA에서는 데이터를 동기화하고 알림을 전송하는 용도로 유용하게 쓰인다.



### 1.2 이벤트 소싱

이벤트 소싱은 이벤트를 위주로 비지니스 로직을 구현하고, 애그리거트를 DB에 이련의 이벤트로 저장하는 기법이다.

#### 이벤트를 이용하여 애그리거트를 저장한다.

기존 영속화는 애그리거트를 테이블에, 필드를 컬럼에, 인스턴스를 로우에 각각 매핑하지만 이벤트 소싱은 도메인 이벤트 개념에 기반한 전혀 새로운 방식, 즉 애그리거트를 DB에 있는 이벤트 저장소에 일련의 이벤트로 저장한다.



#### 이벤트는 곧 상태 변화

 도메인 이벤트는 애그리거트의 변경을 구독자에게 알리는 장치로, 이벤트는 애그리거트 ID 같은 최소한의 필수 데이터만 넣거나 컨슈머에 유용한 데이터까지 포함시켜 강화할 수 있다. 

> 우리도 개발하면서 겪었던 문제 인데, Fat하게 가져갈 것인가, 식별자로 가져가서 직접 조회하는 책임을 가지게 할 것인가?

#### 애그리거트 메서드의 관심사는 오직 이벤트



### 1.3 동시 업데이트: 낙관적 잠금

여러 요청이 동일한 애그리거트를 동시에 업데이트하는 일은 드물지 않다.  기존 영속화 메커니즘은 대게 한 트랜잭션이 다른 트랜잭션의 변경을 덮어 쓰지 못하게 낙관적 잠금을 이용한다.

> UPDATE AGGREGATE ROOT TABLE
>
> SET VERSION= VERSION + 1 ...
>
> WHERE VERSION = <원본 버전>



이벤트 저장소 역시 낙관적 잠금 기법으로 동시 업데이트를 처리할 수 있다.



### 1.4 이벤트 소싱과 이벤트 발행

이벤트 소싱은 애그리거트를 여러 이벤트로 저장하며, 이 이벤트를 가져와 현재 애그리거트의 상태를 다시 구성합니다. 이벤트 소싱은 일종의 확실한 이벤트 발행 장치로 활용한다.



**이벤트 발행: 폴링**

이벤트 발행의 문제점은 다음과 같다.

| 트랜잭션 A                                 | 트랜잭션 B                                |
| ------------------------------------------ | ----------------------------------------- |
| BEGIN                                      | BEGIN                                     |
| EVENT_ID=1010 INSERT                       |                                           |
|                                            | EVENT_ID=1020 INSERT                      |
|                                            | COMMIT(최종 커밋)                         |
| SELECT * FROM EVENTS WHERE EVENT_ID > ...  | SELECT * FROM EVENTS WHERE EVENT_ID > ... |
| COMMIT (최종 커밋)                         |                                           |
| SELECT * FROM EVENTS WHERE EVENT_ID > 1020 |                                           |

커밋이 늦게 되서 조회할 경우 1010 은 건너뛰게 된다.



**이벤트 발행: 트랜잭션 로그 테일링**

이벤트 발행을 확실히 보장하면서도 성능/확장성이 우수하다. 

디비지움과 같은(?)



### 1.5 스냅샵으로 성능 개선

Account 와 같이 수명이 긴 애그리거트는 이벤트 수가 꽤 많아 일일이 Load&Fold 하기가 힘듭니다. 그럴 때를 대비해서 주기적으로 애그리거트 상태의 스냅샷을 저장합니다. 가장 최근에 뜬 스냅샷과 그 이후에 발생한 이벤트만 가져오는 식으로 애그리거트 상태를 복원합니다.



### 1.6 멱등한 메시지 처리

메시지 컨슈머는 멱등하게 개발된다.

메시지 켠슈머가 동일한 메시지를 여러 번 호출해도 안전하다면 멱등한 것.

이벤스 소싱 기반의 비즈니스 로직은 이런 메커니즘을 강구해야 하는데, DB가 관계형 DB인지 NoSQL DB 인지에 따라 다르다.



**RDBMS 이벤트 저장소 사용시**, 메시지ID 는 PROCESSED_MESSAGES 테이블에, 이벤트는 EVENTS 테이블에 삽입하는 트랜잭션의 일부로 삽입하면 된다.



**NoSQL 이벤트 저장소 사용시,**



### 1.7 도메인 이벤트 발전시키기

정확성을 담보로 변경 감사 로그를 제공하여 애플리케이션이 애그리거트 상태를 온전히 재구성할 수 있는 반면, 이벤트 구조는 시간이 흐름에 따라 계속 달라지기 때문에 새로운 문제가 생기기 마련이다.



애플리케이션은 잠재적으로 여러 버전의 이벤트를 처리해야 한다.

**이벤트 스키마**

- 하나 이상의 애그리거트로 구성된다.

- 각 애그리거트가 발생시키는 이벤트를 정의한다.

- 이벤트 구조를 정의합니다.

| 수준            | 변경                    | 하위호환성 |
| --------------- | ----------------------- | ---------- |
| 스키마          | 새 애그리거트 타입 정의 | 예         |
| 애그리거트 삭제 | 기존 애그리거트 삭제    | 아니요     |
| 애그리거트 개명 | 애그리거트 타입명 변경  | 아니요     |
| 애그리거트      | 새 이벤트 타입 추가     | 예         |
| 이벤트 삭제     | 이벤트 타입 삭제        | 아니요     |
| 이벤트 개명     | 이벤트 타입명 변경      | 아니요     |
| 이벤트          | 새 필드 추가            | 예         |
| 필드 삭제       | 필드 삭제               | 아니요     |
| 필드 개명       | 필드명 변경             | 아니요     |
| 필드 타입 변경  | 필드 타입 변경          | 아니요     |



### 이벤트 소싱의 장점

- 도메인 이벤트를 확실하게 발행한다.
- 애그리거트 이력이 보존된다.
- O/R 임피던스 불일치 문제를 대부분 방지할 수 있습니다.
- 개발자에게 타임 머신을 제공합니다.



### 이벤트 소싱의 단점

- 새로운 프로그래밍 모델을 배우는 데 시간이 걸립니다.
- 메시징 기반 애플리케이션은 복잡합니다.
- 이벤트를 개량하기가 까다로운 편입니다.
- 데이터를 삭제하기가 어렵습니다.
- 이벤트 저장소를 쿼리하기가 만만치 않습니다.





## 2. 이벤트 저장소 구현

이벤트 저장소는 DB와 메시지 브로커를 합한 것입니다.

애그리거트의 이벤트