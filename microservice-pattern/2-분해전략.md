# 분해 전략

소프트웨어 아키텍쳐의 정의와 중요성

> 애플리케이션을 여러 서비스로 분해하는 다양한 전략을 살펴보면서 서비스가 기술 관심사보다는 비지니스 관심사를 중심으로 구성된다는 사실을 알아야 한다.

소프트웨어 아키텍쳐는 구성 요소 및 그들 간의 디펜던시로 엮인 고수준의 구조물이다.

과거에는 확장성, 신뢰성, 보안이 주 목표였지만, 이제는 신속/안전하게 소프트웨어를 전달하는 능력으로 이는 마이크로서비스의 관리성, 테스트성, 배포성이 높은 애플리케이션을 구축하는 것이다.

### 정의

> 컴퓨팅 시스템의 소프트웨어 아키텍쳐는 소프트웨어 엘리먼트와 그들 간의 관계, 그리고 이 둘의 속성(property)으로 구성된 시스템을 추론하는 데 필요한 구조(structure)의 집합이다.
>  - 바스

### 왜 분리하는게 좋을까?

- 업무(labor)와 지식(knowledge)을 분리한다. 덕분에 전문 지식을 보유한 사람들(또는 여러팀)이 함께 생산적으로 애플리케이션 작업을 할 수 있다.
- 소프트웨어 엘리먼트가 어떻게 상호 작용하는지 밝힙니다.

#### 어떻게 분해하는가?

건물의 아키텍쳐를 구조, 배관, 전기 등의 관점에서 바라보듯이, 애플리케이션 아키텍쳐를 바라보는 관점도 다양하다.
 소프트웨어 아키텍쳐가 4+1 뷰 모델.

- 논리 뷰
- 구현 뷰
- 프로세스 뷰
- 배포 뷰
- 마지막으로 시나리오

![](https://tva1.sinaimg.cn/mw1024/e6c9d24egy1h44jfmqxouj21gc0o079k.jpg)

여기서 1이 바로 시나리오. 각 시나리오는 특정 뷰 내에서 얼마나 다양한 아키텍처 요소가 협동하여 요청을 처리하는지 기술한다.

가령 논리 뷰의 시나리오는 클래스가 협동하는 방법을, 프로세스 뷰의 시나리오는 프로세스가 서로 어떻게 협동하는지 나타낸다.

### 아키텍쳐 중요성

어플리케이션 요건

- 애플리케이션이 해야 할 일을 정의한 기능 요건
  - 유스 케이스나 사용자 스토리 포맷
- 이른바 ~성 으로 끝나는 서비스 품질 요건
  - ex) 확장성, 신뢰성 같은 런타임 품질 외에도 관리성, 테스트성, 배포성처럼 개발 시점의 품질


**계층화 아키텍쳐 스타일**

단점

- 표현 계층이 하나뿐이다: 애플리케이션을 호출하는 시스템이 하나밖에 없을까?
- 영속성 계층이 하나뿐이다: 애플리케이션이 상호 작용하는 DB가 정말 하나뿐일까?
- 비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다.: 이론적으로 이런 디펜던시 때문에 DB없이 비즈니스 로직을 테스트하는 것은 불가능하다.

**마이크로서비스 아키텍쳐 스타일**

모놀리식 아키텍쳐는 구현 뷰를 단일 컴포넌트(하나의 실행 파일이나 WAR 파일)로 구성한 아키텍쳐 스타일. 다른 뷰는 없음.

마이크로서비스 아키텍쳐는 구현 뷰를 다수의 컴포넌트로 구성하는 차이점. 각 컴포넌트는 곧 서비스고 자체 논리 뷰 아키텍쳐를 가진다. 

### 서비스란 무엇인가?

서비스는 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트. 서비스는 클라이언트가 자신이 서비스하는 기능에 접근할 수 있도록 커맨드, 쿼리, 이벤트로 구성된 API

#### 느슨한 결합

느슨하게 결합된 서비스는 마이크로서비스 아키텍쳐의 주요 특정 중 하나. 서비스는 구현 코드를 감싼 API를 통해서만 상호 작용하므로 클라이언트에 영향을 끼치지 않고 서비스 내부 구현 코드를 바꿀 수 없다.

#### 공유 라이브러리

 거의 바뀔 일이 없는 기능을 라이브러리에 담아 쓰는 것이 좋다.

### 마이크로서비스 아키텍쳐 정의

> 아키텍쳐를 정의하는 일은 과학보다는 예술에 가깝다.

3가지 작업을 통해서 아키텍쳐를 정의한다.

1단계: 시스템 작업 식별

- 애플리케이션 요건을 핵심 요청으로 추출하는 것. REST,메시징같은 특정 IPC기술이 아닌 좀 더 추상적인 관념으로 시스템 작업을 바라보고자 한다.

2단계: 서비스 식별

- 어떻게 여러 서비스로 분해할지 결정하는 것. 비즈니스 아키텍쳐 시각에서 비즈니스 능력에 따라 서비스를 정의할 수도 있고, DDD의 하위 도메인별로 서비스를 구성하는 전략도 가능하다.어떻든 기술 개념이 아닌 비즈니스 개념 중심으로 이루어진 서비스들이다.

3단계: 서비스 API 및 협동 정의

- 서비스별로 API를 정의하는 일이다. 

분해하는 것에 대한 장애물
1. 네트워크 지연
2. 서비스간 동기 통신으로 인해 가용성이 떨어지는 문제
3. 여러 서비스에 걸쳐 데이터 일관성을 지키는 요건
4. 애플리케이션 도처에 숨어 있는 만능 클래스이다.

[ 그림 추가 하기 ]

#### 1단계 시스템 작업 식별

**고수준의 도메인 모델 생성**

대략 그려본다. 사용자 시나리오를 만들어보는 것이다.

> 전제(given)
>   소비자가 있다.
>   음식점이 있다.
>   음식점은 소비자의 주소로 제시간에 음식을 배달할 수 있다.
>   주문 총액이 음식점의 최소 주문량 조건에 부합하다.
> 조건(when)
>   소비자가 음식점에 음식을 주문한다.
> 결과(then)
>   소비자가 신용카드가 승인된다.
>   주문이 PENDING_ACCEPTANCE상태로 생성된다.
>   생성된 주문이 소비자와 연관된다.
>   생성된 주문이 음식점과 연관된다.

위 사용자 시나리오에 포함된 명사를 보면 소비자, 주문, 음식점, 신용카드 등 다양한 클래스가 필요하게 되는 것을 알 수 있다.


**시스템 작업 정의**

애플리케이션이 어떤 요청을 처리할지 식별하는 단계이다.

크게 두 종류로 나뉜다.
- 커맨드(command): 데이터 생성, 수정, 삭제
- 쿼리(query): 데이터 읽기

 시스템 커맨드를 식별하려면 사용자 **스토리/시나리오에 포함된 동사를** 먼저 분석해야 한다.

| 액터               | 스토리           | 커맨드                    | 설명                                                         |
| ------------------ | ---------------- | ------------------------- | ------------------------------------------------------------ |
| 소비자(Consumer)   | 주문 생성        | createOrder()             | 주문을 생성한다.                                             |
| 음식점(Restaurant) | 주문접수         | acceptOrder()             | 음식점에 주문이 접수되었고 주어진 시각까지 음식을 준비하도록 지시한다. |
|                    | 주문 픽업 준비됨 | noteOrderReadyForPickup() | 주문한 음식이 픽업 가능함을 알린다.                          |
| 배달원(Courier)    | 위치 업데이트    | noteUpdatedLocation()     | 배달원의 현재 위치를 업데이트한다.                           |
|                    | 배달 픽업        | noteDeliveryPickedUp()    | 주문한 음식을 배달원이 픽업했음을 알린다.                    |
|                    | 주문 배달됨      | noteDeliveryDelivered()   | 주문한 음식을 배달원이 소비자에게 배달했음을 알린다.         |



커맨드는 매개변수, 반환값, 동작 방식의 명세를 도메인 모델 클래스로 정의한다.

이 명세는 작업 호출 시 충족되어야 할 선행조건, 후행조건 으로 구성된다.

|          |                                                              |
| -------- | ------------------------------------------------------------ |
| 작업     | CreateOrder(소비자ID,결제 수단, 배달 주소, 배달 시각, 음식점 ID, 주문 품목) |
| 반환값   | OrderId                                                      |
|          |                                                              |
| 선행조건 | 소비자가 존재하고 주문을 할 수 있다.<br />주문 품목은 음식점의 메뉴 항목에 들어있다.<br />배달 주소/시각은 음식점에서 서비스 할 수 있다. |
|          |                                                              |
| 후행조건 | 소비자 신용카드는 주문 큼액만큼 승인 처리되었다.<br />주문은 PENDING_ACCEPTANCE 상태로 생성되었다. |
|          |                                                              |


선해 조건을 시나리오의 전체(given) 후행조건은 주문하기 시나리오의 결과(then)를 나타낸다.

시스템 작업 호출시 먼저 선행 조건을 확인한 후, 후행 조건을 만족시키는 액션을 수행한다.


