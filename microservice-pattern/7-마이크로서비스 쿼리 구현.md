이번 장에서는 어떻게 마이크로서비스에서 CQRS 패턴을 활용해 View 를 만들 수 있는지 알아보려고 합니다.

*이 책의 내용을 가볍게 흟어보면서 기억하면 좋은 부분을 갈무리하려 합니다.*


쿼리를 구현하기 위해서 2가지 패턴이 있다.

- API 조합(composition) 패턴: 서비스 클라이언트가 데이터를 가진 여러 서비스를 직접 호출하여 그 결과를 조합하는 패턴. 저자가 추천하는 방법이다.
- CQRS(커맨드 쿼리 책임 분산)패턴: 쿼리만 지원하는 하나 이상의 뷰 전용 DB를 유지하는 패턴. 

왜 CQRS 가 강력할까?? 의문이 남네. 무엇이 강력하다는건지?

## API 조합 패턴 응용 쿼리

API 조합 패턴을 만들기 위해서는 2가지 참여자가 등장한다.
- API 조합기: 프로바이더(provider)서비스를 쿼리하여 데이터를 조회한다.
- 프로바이더 서비스: 최종 결과로 반환할 데이터의 일부를 갖고 있는 서비스

![API 조합 패턴 개요](https://tva1.sinaimg.cn/mw1024/e6c9d24egy1h5x9x40qw1j20ya0nqwgy.jpg)

이렇게 하는게 무슨 문제가 있을까?

설계 관점에서 2가지 문제가 있다.

1. 어느 컴포넌트를 쿼리 작업의 API 조합기로 선정할 것인가?
2. 어떻게 해야 효율적으로 취합 로직을 작성할 것인가?

**누가 조합기 역할을 할 것인가? 3가지 방법이 있다.**
1. 서비스 클라이언트를 API 조합기로 임명하는 방법   

![서비스 클라이언트를 API 조합기로 임명하는 방법](https://tva1.sinaimg.cn/mw1024/e6c9d24egy1h5xa3ztju6j20ym0u0tbe.jpg)
   
2. 애플리케이션의 외부 API가 구현된 API 게이트웨이를 API 조합기로 만드는 것

![애플리케이션의 외부 API가 구현된 API 게이트웨이를 API 조합기로 만드는 것](https://tva1.sinaimg.cn/mw1024/e6c9d24egy1h5xacrch4mj20u010zgop.jpg)

모바일 기기 등의 방화벽 외부에서 접근하는 클라이언트가 API 호출 한 번으로 여러 서비스의 데이터를 조회할 수 있기 때문에 효율적입니다.

3. API 조합기를 스탠드얼론 서비스로 구현하는 것

![API 조합기를 스탠드얼론 서비스로 구현하는 것](https://tva1.sinaimg.cn/mw1024/e6c9d24egy1h5xaex99k6j20u011atbt.jpg)

**API 조합기는 리액티브 프로그래밍 모델을 사용해야 합니다.**

쿼리 작업의 반응 시간을 최대한 줄이려면 가능한 한 API 조합기가 프로바이더 서비스를 병렬 호출해야 합니다.

관리가 용이하고 성공/확장성이 우수한 API 조합기를 사용하려면 CompletableFuture 등의 기법이 유용합니다.

#### 그럼 단점은 무엇일까?

- 오버헤드가 증가한다.
- 가용성 저하가 우려된다.
- 데이터 일관성이 결여된다. (? 왜 ?)
 모놀리식이 비해 MSA 는 여러 서비스의 DB에서 쿼리를 실행하기 때문에 일관되지 않은 데이터가 반활될 수 있습니다.

효율적으로 구현하기 어려운(거대한 데이터 뭉치) 쿼리 작업은 CQRS 패턴으로 구현하는 편이 좋습니다.

## CQRS 패턴

*CQRS 패턴는 여러 서비스에 있는 데이터를 가져오는 쿼리를 이벤트를 이용하여 해당 서비스의 데이터를 복제한 읽기 전용 뷰를 유지한다.*

여전히 이해가 안된다. 왜 CQRS 패턴을 해야 되는거지?

원인은 마이크로서비스 패턴에 있다.  마이크로서비스라는 길을 정했다면, 위에서 설명한 API 조합 패턴은 한계가 있다. 각각의 서비스에 불필요하게 많은 쿼리들이 생겨날 것이기 때문입니다.

단일 서비스 쿼리조차도 어려운 경우가 있고, DB가 효율적인 쿼리를 지원하지 않는 경우가 있습니다.

어떤 부분에서 그럴까?

*List\<Object\>  와 같은 다건을 조회하는 경우를 생각해보자.*
API조합 패턴이라면, 각 마이크로서비스마다 List을 만들어내는 쿼리를 조회합니다. 그 뒤에 인메모리에 넣어놓고 모든 조합을 시도해야 할 것입니다. 이 거대한 데이터 뭉치는 API 조합기 안에서는 인메모리를 활용해야 하기 때문에 효율이 떨어지게 될 것입니다.

*그럼 반대로 단일 서비스에서는 어떤 것이 어려운지 생각해보자*

배달앱에서 내가 살고 있는 위치에서 100m 이내에 모든 음식점을 조회한다고 가정해보자. (findAvailableRestaurants())
이 쿼리의 핵심은 효율적으로 지리 공간 쿼리를 수행해야 하는데, 이는 DB의 능력에 좌우된다.
(물론 지리공간 쿼리를 위해 각 DB의 geospatial extenstions 을 이용하면 아주 쉽게 구현할 수 있다.)

만약 DB의 geospatial extenstions 을 지원하지 않는다면? 어떻게 할까? 각 음식점의 정보를 레플리카을 지리 공간 쿼리에 맞게 설계된 형태로 유지해야만 할 것이다.

*관심사를 분리할 필요가 있다*

공간지리쿼리에 관심있는 팀과 서비스 개발하는 팀을 분리해야 할 필요가 있다.

다시한번 정리하면 쿼리를 구현함으로써 봉착하는 세 가지 난관은 다음과 같다.

- API를 조합하여 여러 서비스에 흩어진 데이터를 조회하려면 값비싸고 비효율적인 인-메모리 조인을 해야 합니다.
- 데이터를 가진 서비스는 필요한 쿼리를 효율적으로 지원하지 않는 DB에, 또는 그런 형태로 데이터를 저장합니다.
- 관심사를 분리할 필요가 있다는 것은 데이터를 가진 서비스가 쿼리 작업을 구현할 장소로 적합하지 않다는 뜻입니다.

CQRS 는 커맨드와 쿼리를 분리하기 위한 용도입니다.

![[Pasted image 20220907012323.png]]

별도로 나뉘어진 쿼리 모델은 다소 복잡한 쿼리를 처리합니다. 비즈니스 규칙을 구현할 정도는 아니기 때문에 그래도 커맨드 쪽보다는 단순합니다.
쿼리 쪽에는 도메인 이벤트를 구독하고 DB을 업데이트하는 이벤트 핸들러가 있습니다. 

***이 말은 쿼리가 무조건 Read만 한다는게 아니라, 클라이언트가 View 용으로만 만들기 위해서 필요한 모델을 의미합니다.***

**장단점이 있습니다.**

**마이크로서비스 아키텍처에서 쿼리를 효율적으로 구현할 수 있습니다.**
  
- 다양한 쿼리를 효율적으로 구현할 수 있습니다.
- 이벤트 소싱 애플리케이션에서 쿼리가 가능합니다.
- 관심사가 보다 더 분리됩니다.

**단점으로는, 아키텍쳐가 더욱 복잡해 집니다. **
**복제 시차(replication lag)를 처리해야 합니다.**

커맨드/쿼리 양쪽 뷰 사이의 '시차(lag)' 가 발생하게 됩니다.
어떻게 처리할 수 있을까? 한가지 방법으로는 API에 버전 정보를 전달해서 데이터를 분간할 수 있도록 처리하는 방법을 선택합니다.

## CQRS 뷰 설계

CQRS 뷰 모듈은 다음과 같은 구조를 가집니다.

![](https://tva1.sinaimg.cn/middle/e6c9d24egy1h5xcvi4eqwj20u00uw76e.jpg)

뷰 모듈을 구현시 몃 가지 중요한 설계 결정을 해야 합니다.

- DB를 선정하고 스키마를 설계해야 합니다.
- 데이터 접근 모듈을 설계할 때 멱등한/동시 업데이트 등 다양한 문제를 고려해야 합니다.
- 기존 애플리케이션에 새 뷰를 구현하거나 기존 스키마를 바꿀 경우, 뷰를 효율적으로(재)빌드 할 수 있는 수단을 강구해야 합니다.
- 뷰 클라이언트에서 복제 시차를 어떻게 처리할지 결정해야 합니다.

그렇다면 어떤 뷰 DB 를 사용해야 할까요?

SQL VS NO SQL

뷰를 위해서는 당연 NoSQL 이 좋습니다. 트랜잭션을 위한 처리가 크게 필요하지 않는 처리와 유연한 데이터 모델을 만들 수 있다는 점, 그리고 고정된 쿼리만 사용하므로 NoSQL 과 잘 어울립니다.
그렇다면 무조건 NoSQL 이 좋다는 것은 아닙니다.

RDBMS 의 성능이 예전보다 좋아졌고, 무엇보다 대부분의 개발자는 NoSQL 보다는 RDBM 이 더 익숙하기 때문에 RDBMS 가 더 적합할 수 있습니다.

데이터 접근 모듈을 설계할 경우에는 2가지를 고려해야 합니다.

1. 동시성 처리
	- 비관적 잠금 기법을 사용하기
2. 멱등한 이벤트 핸들러
	- 중복된 이벤트메세지를 걸러야 합니다. 반드시 이벤트 ID를 기록하고 데이터 저장소를 원자적으로 업데이트 해야 합니다.
